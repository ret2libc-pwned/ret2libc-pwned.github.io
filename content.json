{"meta":{"title":"Ret2Libc","subtitle":"Hello, the cruel world.","description":"","author":"ret2libc","url":"https://ret2libc-pwned.github.io","root":"/"},"pages":[{"title":"关于我","date":"2021-10-16T14:14:36.000Z","updated":"2022-04-29T12:17:51.170Z","comments":false,"path":"about/index.html","permalink":"https://ret2libc-pwned.github.io/about/index.html","excerpt":"","text":"自我介绍 你好, 我是Ret2libc, 正在零基础入门算法! 本网站主要是自己的一点笔记和心得, 如果你恰好找到了这里, 我很希望它们能帮助到你! 联系方式 QQ 2184016258, 欢迎和我交朋友, 或者教教我怎么零基础入门算法! 为什么叫Ret2libc? ret2libc是pwn(二进制安全, binary exploitation)里的一个栈溢出利用方法. 这个网站会留多久? 搭这个网站主要是为了在机房能看到自己的笔记, 所以会留比较久. 值得一提的是如果github pages由于各种原因访问不上, 可以去这个网站的香港腾讯云镜像."},{"title":"tags","date":"2021-10-16T12:54:16.000Z","updated":"2021-10-16T13:10:07.521Z","comments":false,"path":"categories/index.html","permalink":"https://ret2libc-pwned.github.io/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-10-16T12:17:58.000Z","updated":"2021-10-16T13:25:50.508Z","comments":false,"path":"conmment/index.html","permalink":"https://ret2libc-pwned.github.io/conmment/index.html","excerpt":"","text":"有什么想说的? 有什么想问的?"},{"title":"tags","date":"2021-10-16T13:18:16.000Z","updated":"2021-10-17T03:36:02.847Z","comments":false,"path":"tags/index.html","permalink":"https://ret2libc-pwned.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"单调队列","slug":"单调队列","date":"2022-04-30T11:11:11.000Z","updated":"2022-05-01T12:29:39.121Z","comments":true,"path":"2022/04/30/单调队列/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/04/30/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","excerpt":"","text":"定义 维护一种序列, 可以从头和尾增加或删除元素(即双端队列), 且元素具有单调性. 实现 本质是维护具有单调性的最优决策集合, 该如何维护最优与单调的性质呢? 维护序列 该操作的本质是对原序列\\(A\\)扫描, 将当前的元素\\(A_i\\)与单调队列队尾比较, 如果\\(A_i\\)更优则将队尾换成\\(A_i\\). //pseudo code Queue q, Array a[]; int head = 0, tail = 0; for each a[i] in a { while(队列过大) ++head; //pop front //此时q[head]为当前最优 while(head &lt; tail &amp;&amp; q[tail]没有a[i]优) --tail; //pop back q[++tail] = 当前值; } 实现双端队列 std::deque 可以使用deque对序列进行操作. using namespace std; deque&lt;int&gt; q; //入队 q.push_front(x); q.push_back(x); //出队 q.pop_front(); q.pop_back(); //取头尾 q.front(); q.back(); //遍历 for(int x: q) { cout &lt;&lt; x &lt;&lt; \" \"; } puts(\"\"); 数组模拟 可以使用两个指针\\(head\\), \\(tail\\)模拟. 需要注意的是数组中下标小的元素在队列前面, 同时指针\\(head \\le tail\\). 例题 滑动窗口 给定一个长度为\\(n\\)的序列, 求其每个长度为\\(k\\)的连续子序列中的最大与最小值. 本题只需维护两个单调队列(一个递减, 队头为min; 另一个反之)即可. 需要注意的是要让窗口大小不超过\\(k\\), 这里采用在队列中存储数组下标的方法统计, 即保证\\(head\\)中存储的下标与当前扫描元素的下标之差小于\\(k\\). #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; const int N = 1e6 + 100; int q[N], a[N]; int n, k; void getMin() { //维护递减序列, 队头即为答案 int head = 0, tail = 0; for(int i = 1; i &lt; k; ++i) { //Step 1: [1, k), push while(head &lt;= tail &amp;&amp; a[q[tail]] &gt;= a[i]) --tail; q[++tail] = i; } for(int i = k; i &lt;= n; ++i) { //Step 2: [k, n] //这个区间窗口可能超过k, 需要特判维护窗口大小 while(head &lt;= tail &amp;&amp; a[q[tail]] &gt;= a[i]) --tail; q[++tail] = i; while(q[head] &lt;= i - k) ++head; cout &lt;&lt; a[q[head]] &lt;&lt; ' '; } } void getMax() { memset(q, 0, sizeof q); int head = 0, tail = 0; for(int i = 1; i &lt; k; ++i) { while(head &lt;= tail &amp;&amp; a[q[tail]] &lt;= a[i]) --tail; q[++tail] = i; } for(int i = k; i &lt;= n; ++i) { while(head &lt;= tail &amp;&amp; a[q[tail]] &lt;= a[i]) --tail; q[++tail] = i; if(q[head] &lt;= i - k) ++head; cout &lt;&lt; a[q[head]] &lt;&lt; ' '; } } int main() { cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; ++i) { cin &gt;&gt; a[i]; } getMin(); puts(\"\"); getMax(); puts(\"\"); return 0; } 最大子序和 给定一个长度为\\(n\\)的序列, 求出一段长度不超过\\(m\\)的连续子序列, 输出子序和. 不难想到前缀和操作, 在前缀和数组\\(S\\)中, 对于右端点\\(r\\), 需要找到左端点\\(l\\)满足如下条件: \\[ \\begin {cases} l \\in [1, r - 1]&amp;&amp;&amp;(1)\\\\ \\min(S_l)&amp;&amp;&amp;(2)\\\\ r - m \\le l&amp;&amp;&amp;(3) \\end {cases} \\] 其中, 3式的意思是让子序列的大小不超过\\(m\\). #include &lt;iostream&gt; const int N = 1e6; using namespace std; int m, n; int a[N], s[N]; int q[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i) { cin &gt;&gt; a[i]; s[i] = s[i - 1] + a[i]; } int head = 0, tail = 0, ans = -0x3f; for(int i = 1; i &lt;= n; ++i) { while(head &lt;= tail &amp;&amp; i - m &gt; q[head]) ++head; ans = max(ans, s[i] - s[q[head]]); while(head &lt;= tail &amp;&amp; s[q[tail]] &gt;= s[i]) --tail; q[++tail] = i; } cout &lt;&lt; ans &lt;&lt; endl; return 0; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"字典树","slug":"trie","date":"2022-04-18T13:21:23.987Z","updated":"2022-04-29T12:25:00.999Z","comments":true,"path":"2022/04/18/trie/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/04/18/trie/","excerpt":"","text":"字典树 定义 应用 像查字典一样\"检索\"字符串 #include &lt;iostream&gt; #include &lt;string&gt; const int N = 1e6; using namespace std; struct Trie { int nxt[N][26], tot = 0; bool ed[N]; void insert(string s) { int p = 0; for(char ch: s) { int key = ch - 'a'; if(nxt[p][key] == 0) { nxt[p][key] = ++tot; } p = nxt[p][key]; } ed[p] = true; } bool isExist(string s) { int p = 0; for(char ch: s) { int key = ch - 'a'; if(nxt[p][key] == 0) { return false; } p = nxt[p][key]; } return ed[p]; } }; Trie tr; //Allocate int main() { int cas; cin &gt;&gt; cas; while(cas--) { string s; cin &gt;&gt; s; tr.insert(s); } puts(\"Inserted!!!!!!\\n\\nAsk Me!!!!!!!\"); cin &gt;&gt; cas; while(cas--) { string s; cin &gt;&gt; s; puts(tr.isExist(s) ? \"Exist.\" : \"Not Exist.\"); } return 0; } 异或极值问题","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"树形dp","date":"2022-03-25T11:36:01.065Z","updated":"2022-03-27T11:58:20.437Z","comments":true,"path":"2022/03/25/树形dp/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/03/25/%E6%A0%91%E5%BD%A2dp/","excerpt":"","text":"树形dp 例题 没有上司的舞会 使用\\(dp(u, 0/1)\\)表示以\\(u\\)来或不来时\\(u\\)为根结点子树的快乐指数总和. 则: \\[ dp(u, 0) = \\sum \\max_{v \\in u.\\mathrm{son}} \\{dp(v, 0), dp(v, 1)\\}\\\\ dp(u, 1) = dp(v, 0) \\] #include &lt;iostream&gt; #include &lt;cstring&gt; const int N = 1e6 + 10; using namespace std; int head[N], to[N], nxt[N], tot, n, r[N], Root = 1, dp[N][2]; bool haveFa[N]; inline void initGraph() { memset(head, -1, sizeof head); tot = -1; } void addEdge(int u, int v) { nxt[++tot] = head[u], head[u] = tot, to[tot] = v; } void calc(int u) { for(int i = head[u]; ~i; i = nxt[i]) { int v = to[i]; calc(v); dp[u][0] += max(dp[v][0], dp[v][1]); dp[u][1] += dp[v][0]; } } int main() { initGraph(); cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) { cin &gt;&gt; dp[i][1]; } for(int i = 1; i &lt; n; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(v, u); haveFa[u] = true; } while(haveFa[Root]) { Root++; } calc(Root); cout &lt;&lt; max(dp[Root][0], dp[Root][1]) &lt;&lt; endl; return 0; } 战略游戏 #include &lt;iostream&gt; #include &lt;cstring&gt; const int N = 1e6 + 10; using namespace std; int head[N], to[N], nxt[N], tot, dp[N][2], n, Root; inline void initGraph() { memset(head, -1, sizeof head); tot = -1; } void addEdge(int u, int v) { nxt[++tot] = head[u], head[u] = tot, to[tot] = v; } void calc(int u) { dp[u][1] = 1, dp[u][0] = 0; for(int i = head[u]; ~i; i = nxt[i]) { int v = to[i]; calc(v); dp[u][0] += dp[v][1]; dp[u][1] += min(dp[v][0], dp[v][1]); } } int main() { initGraph(); cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) { int u, k; cin &gt;&gt; u &gt;&gt; k; for(int j = 1; j &lt;= k; ++j) { int v; cin &gt;&gt; v; addEdge(u, v); } } calc(0); cout &lt;&lt; min(dp[0][0], dp[0][1]) &lt;&lt; endl; return 0; } DP求树的直径 #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;queue&gt; const int N = 1e6 + 10, INF = 0x3f3f3f3f; using namespace std; int n; int head[N], to[N], nxt[N], tot, Root, d1[N], d2[N]; bool vis[N]; inline void initGraph() { memset(head, -1, sizeof head); tot = -1; } void addEdge(int u, int v) { nxt[++tot] = head[u], head[u] = tot, to[tot] = v; } int getDiam(int u) { int ret = -INF; d1[u] = d2[u] = 0; for(int i = head[u]; ~i; i = nxt[i]) { int v = to[i]; getDiam(v); int t = d1[v] + 1; if(t &gt; d1[u]) { d2[u] = d1[u], d1[u] = t; } else if(t &gt; d2[u]) { d2[u] = t; } } ret = max(ret, d1[u] + d2[u]); return ret; } int main() { initGraph(); cin &gt;&gt; n; for(int i = 0; i &lt; n - 1; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, v); } int ans = getDiam(1); cout &lt;&lt; ans &lt;&lt; endl; return 0; } 消防局的设立","categories":[],"tags":[]},{"title":"Splay","slug":"Splay","date":"2022-03-12T13:39:05.000Z","updated":"2022-04-30T02:45:43.529Z","comments":true,"path":"2022/03/12/Splay/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/03/12/Splay/","excerpt":"","text":"Splay 定义 Splay是一种BST, 将访问过的结点不断旋转到根结点, 在满足BST性质的同时保证其\"平衡\", 基于时间、空间局部性原理优化查找性能(这样操作使得高频访问的结点在经常根结点附近). 本文的BST每一个结点只维护单个值(而非键值对), 下面说法中v、val、key都指这个值, BST性质的维护它们的大小关系做依据. BST性质 左子树任意结点的key\\(\\lt\\)根结点key\\(\\lt\\)右子树任意结点key, 即中序遍历单调递增. 常见的BST有Treap、Splay、AVL等. 结点结构 开结构体数组记录两个子结点及父结点的数组下标, 类似于一个链表(实际上很多树状数据结构都是数组模拟链表). 结点同时存储维护的信息. const int SIZE = 1e5; struct Node { //两个子结点及父结点数组下标, val int s[2], p, v; //延迟标记及子树大小 int dat, size; //初始化当前结点 void init(int _v, int _p) { v = _v, p = _p; size = 1; } }; //Allocate Node tr[SIZE]; ``` 其中规定`s[0]`为左子结点, `s[1]`为右子结点, 即: (后续代码均未使用如下define, 只是为了方便理解) ``` cpp #define ls s[0] #define rs s[1] #define son s[k] #define son_bro s[k ^ 1] //son's brother 单旋操作(rotate) 旋转需要保证BST性质; 根结点变量, 即root需要更新; 结点维护的信息(如延迟标记)需要更新. 旋转改变了是树的形态, 本质是改变父子关系. Splay单旋 右旋, 即\\(\\operatorname{Zig}(x)\\)操作 顾名思义就是将\\(x\\)的左子树绕着\\(x\\)的父结点\\(y\\)向右旋转. 需要注意的是\\(x \\lt x_r \\lt y\\), 故\\(x_r\\)应该转到\\(y_r\\)左子树的位置. 这样的操作通过改变\\(y\\)与\\(x_r\\)、\\(\\operatorname{fa}(y)\\)与\\(x\\)、\\(x\\)与\\(y\\)的父子关系达到. 左旋, 即\\(\\operatorname{Zag}(x)\\)操作 同理, \\(x\\)的右子树绕着\\(y\\)向左旋转, \\(x_l\\)接在\\(y\\)右子树位置. 即需要改变\\(y\\)与\\(x_l\\)、\\(\\operatorname{fa}(y)\\)与\\(x\\)、\\(x\\)与\\(y\\)的父子关系. 旋转结点, 即\\(\\operatorname{rotate}(x)\\)操作 上述操作可以使用一个操作\\(\\operatorname{rotate}(x)\\)来完成, 即实现\"自动判定左右\"的单旋操作. \\(x\\)是\\(y\\)的左子树就右旋, 右子树反之. 该操作的精髓就是判定\\(x\\)是\\(y\\)的左结点还是右结点. 前面说过, \"旋转\"的本质是\"改变父子关系\". 每个结点维护了她的左右子树和父结点, 所以该过程需要\"互认\"父子关系, 即需要修改两个结点的信息; 同时因为树的形态被改变, 需要重新统计延迟标记维持的信息(如子树大小). void Rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = (tr[y].s[1] == x); tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; //tr[x].s[k]的含义是取处于yx直线上的x的儿子, k ^ 1是取她的兄弟 Pushup(y), Pushup(x); } 说人话就是: \\(k\\)的获取: inline int k(int x, int y) { /* *@description 返回x是y的哪个儿子, 左0右1. */ return (tr[y].s[1] == x); } rotate伪代码: /* y是x的爸爸, z是x的爷爷; */ /* 以下每一步都需要修改两个结点的值, 即互认关系 */ 用z取到y, 将x转到y的位置上, 并与z互认; /* 以下两部均需操作结点与其父结点\"互认\"过程, 不再赘述 */ x(此时在y的位置上)的兄弟转到原先x(即tr[y].s[k])的位置上; 让y转到原先x的兄弟的位置; 分别更新y, x子树维护的信息; 双旋操作(splay) 通过一或两次rotate, 可以调整BST的形态, 使其更平衡. 通过过程\\(\\operatorname{splay}(x, goal)\\)将结点\\(x\\)转到\\(goal\\)的子结点. 规定\\(y\\)是\\(x\\)父结点, \\(z\\)是\\(y\\)父结点, splay分六种(3 * 2)情况讨论. 当\\(\\operatorname{fa}(x) = \\operatorname{Root}\\)时, 旋转一次\\(x\\)(右或左), 即Zig或Zag; 当\\(\\operatorname{fa}(x) \\ne \\operatorname{Root}\\)且\\(z, y, x\\)在一条直线上, 旋转一次\\(y\\), 再同方向旋转一次\\(x\\), 即Zig-Zig或Zag-Zag; 当\\(\\operatorname{fa}(x) \\ne \\operatorname{Root}\\)且\\(z, y, x\\)形状是在一条直线的中间折了一下, 分别对\\(x\\)执行两次不同方向的旋转, 即Zig-Zag或Zag-Zig. 画图理解即可. 使用rotate就是: 折线2x 直线yx 需要注意的是该操作是将\\(x\\)转到\\(goal\\)下面, 故当\\(x\\)与\\(goal\\)为具有父子关系的两个结点时 (即第1、2种情况)不需要操作(即不需要交换它们). void Splay(int x, int goal) { //把x转到goal下面 while(tr[x].p != goal) { int y = tr[x].p, z = tr[y].p; if(z != goal) { if((tr[z].s[1] == y) ^ (tr[y].s[1] == x)) Rotate(x); //折线先转x再转x else Rotate(y); //直线先转y } Rotate(x); //统一转x } if(goal == 0) Root = x; //更新根结点(0为根结点下标) } 插入操作(insert) 过程\\(\\operatorname{insert}(val)\\)将\\(val\\)插入BST的相应位置\\(x\\), 将插入的数转到根结点, 即执行\\(\\operatorname{splay}(x, 0)\\). 插入时需要维护BST性质, 将插入的这个数与当前节点比较, \"小插左, 大插右\". void Insert(int v) { /* * @param v 要插入值的val. */ int u = Root, p = 0; //从根结点开始, u为当前节点数组下标, p为她的爸爸下标 while(u) { p = u, u = tr[u].s[v &gt; tr[u].v]; //小左大右地插下去, 方括号里的是判定左右 } u = ++idx; //结点又多了一个, idx += 1; if(p) tr[p].s[v &gt; tr[p].v] = u; //将p的儿子u插入适当位置 tr[u].init(v, p); //给这个点初始化爸爸下标和自身value, 并将大小设为1 splay(u, 0); //转到根结点 } 查询指定数的排名(getRank) 不会😄. 查询第\\(k\\)小的数(getValByRank) \\(\\operatorname{getValByRank}(rank)\\)操作分三种情况讨论: \\[ 结点位于:\\, \\begin{cases} 1. 所求结点位于左子树, 左子树结点个数\\ge rank;\\\\ 2. 所求结点为中序遍历第k个数(即左子树的父结点), 左子树结点个数 = rank - 1;\\\\ 3. 所求结点位于右子树(rank需要减去左子树大小加一的和), 左子树结点个数 \\lt rank - 1 \\end{cases} \\] int getValByRank(int rk) { int u = Root; while(true) { Pushdown(u); if(tr[tr[u].s[0]] &gt;= rk) u = tr[u].s[0]; else if(tr[tr[u].s[0]] + 1 == rk) return u; else rk -= (tr[tr[u].s[0]] + 1), u = tr[u].s[1]; } return -1; } 删除操作(delete) 操作\\(\\operatorname{delete}(x)\\)从Splay中删除value为\\(x\\)的结点. 该操作首先将\\(x\\)转到根结点, 再合并\\(x\\)的左右子树. 查询前驱/后继(getPrefix/getSuffix) \\(x\\)的前驱: 小于\\(x\\)的最大数; \\(x\\)的后继: 大于\\(x\\)的最小数. \\(\\operatorname{getPrefix}(x)\\)操作查询\\(x\\)的前驱, 可以通过插入\\(x\\)(插入后位于根结点), 此时\\(x\\)左子树中最右边的结点即为所求, 最后删除结点\\(x\\); \\(\\operatorname{getSuffix}(x)\\)操作反之. 例题 文艺平衡树(Luogu P3391) 翻转一个区间，例如原有序序列是\\(\\{5, 4, 3, 2, 1\\}\\)，翻转区间是\\([2, 4]\\)的话，结果是\\(\\{5, 2, 3, 4, 1\\}\\). 在结点上维护延迟标记\\(flag\\)来判定翻转状态, 避免多次翻转造成性能上的浪费. #include &lt;iostream&gt; const int N = 1e5; using namespace std; struct Node { int s[2], p, v, siz; int flag; //flag == 1则需要翻转 void init(int _v, int _p) { v = _v, p = _p; siz = 1; } }; Node tr[N]; int idx, Root; int cas, n; void Pushup(int x) { tr[x].siz = tr[tr[x].s[0]].siz + tr[tr[x].s[1]].siz + 1; } void Pushdown(int x) { if(tr[x].flag) { swap(tr[x].s[0], tr[x].s[1]); tr[tr[x].s[0]].flag ^= 1; tr[tr[x].s[1]].flag ^= 1; tr[x].flag = 0; } } void Rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = (tr[y].s[1] == x); tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; Pushup(y), Pushup(x); } void Splay(int x, int goal) { while(tr[x].p != goal) { int y = tr[x].p, z = tr[y].p; if(z != goal) { if((tr[z].s[1] == y) ^ (tr[y].s[1] == x)) Rotate(x); else Rotate(y); } Rotate(x); } if(goal == 0) Root = x; } void Insert(int v) { int u = Root, p = 0; while(u) { p = u, u = tr[u].s[v &gt; tr[u].v]; } u = ++idx; if(p) { tr[p].s[v &gt; tr[p].v] = u; } tr[u].init(v, p); Splay(u, 0); } int getValByRank(int rk) { int u = Root; while(true) { Pushdown(u); if(tr[tr[u].s[0]].siz &gt;= rk) u = tr[u].s[0]; else if(tr[tr[u].s[0]].siz == rk - 1) return u; else rk -= (tr[tr[u].s[0]].siz + 1), u = tr[u].s[1]; } return -1; } void Output(int u) { //这一步是翻转 Pushdown(u); //从u开始中序遍历 //左 if(tr[u].s[0]) Output(tr[u].s[0]); //判定哨兵, 输出当前结点 if(tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) cout &lt;&lt; tr[u].v &lt;&lt; ' '; //右 if(tr[u].s[1]) Output(tr[u].s[1]); } int main() { cin &gt;&gt; n &gt;&gt; cas; for(int i = 0; i &lt;= n + 1; ++i) { //插入哨兵防止越界 Insert(i); } while(cas--) { int l, r; cin &gt;&gt; l &gt;&gt; r; l = getValByRank(l), r = getValByRank(r + 2); Splay(l, 0), Splay(r, l); tr[tr[r].s[0]].flag ^= 1; } Output(Root); return 0; } //对零基础即为友好 #include &lt;iostream&gt; const int N = 1e6; using namespace std; struct Node { int v, p, s[2], siz; bool flag; void init(int _v, int _p) { v = _v, p = _p; siz = 0; } }; Node tr[N]; int n, cas, Root, idx; /* * 一些宏定义, 用法简单明了, 跟一大堆杂乱无章的中括号说再见!!! * ex. node(x).init(v, p) //初始化结点x的属性v, p * siz(left(x)) //获取结点x的左子节点size * siz(node(x).ls) //另一种写法 */ #define ls s[0] #define rs s[1] #define isRoot(x) (x == 0) #define BST_getPos(fa, val) tr[fa].s[(val) &gt; tr[(fa)].v] //在fa结点下面根据BST性质插入一个值为val的结点, 判定结点位置(即: 要插在哪里) #define node(x) tr[(x)] //可以理解为x号结点的对象, 方便使用ls, rs #define left(x) tr[(x)].s[0] #define right(x) tr[(x)].s[1] #define val(x) tr[(x)].v #define siz(x) tr[(x)].siz #define flag(x) tr[(x)].flag #define pa(x) tr[(x)].p #define son(fa, x) tr[(fa)].s[(x)] //获取结点fa的儿子, 参数x为左右, 左0右1 #define LoR(fa, x) (tr[(fa)].s[1] == (x)) //L or R, x是fa的哪个儿子 void Pushup(int x) { siz(x) = siz(left(x)) + siz(right(x)) + 1; } void Pushdown(int x) { if(flag(x)) { swap(left(x), right(x)); flag(left(x)) ^= 1; flag(right(x)) ^= 1; flag(x) = 0; } } void Rotate(int x) { int y = pa(x), z = pa(y); int k = LoR(y, x); son(z, LoR(z, y)) = x, pa(x) = z; son(y, k) = son(x, k ^ 1), pa(son(x, k ^ 1)) = y; son(x, k ^ 1) = y, pa(y) = x; Pushup(y), Pushup(x); } void Splay(int x, int goal) { while(pa(x) != goal) { int y = pa(x), z = pa(y); if(z != goal) { if(LoR(z, y) ^ LoR(y, x)) { Rotate(x); } else { Rotate(y); } } Rotate(x); } if(isRoot(goal)) Root = x; } void Insert(int v) { int u = Root, p = 0; while(u) { p = u, u = BST_getPos(u, v); } u = ++idx; if(!isRoot(p)) { BST_getPos(p, v) = u; } node(u).init(v, p); Splay(u, 0); } int getValByRank(int rk) { int u = Root; while(true) { Pushdown(u); if(siz(left(u)) &gt;= rk) u = left(u); else if(siz(left(u)) == rk - 1) return u; else rk -= siz(left(u)) + 1, u = right(u); } return -1; } void Output(int x) { Pushdown(x); if(left(x)) Output(left(x)); if(val(x) &gt;= 1 &amp;&amp; val(x) &lt;= n) cout &lt;&lt; val(x) &lt;&lt; ' '; if(right(x)) Output(right(x)); } int main() { cin &gt;&gt; n &gt;&gt; cas; for(int i = 0; i &lt;= n + 1; ++i) { Insert(i); } while(cas--) { int l, r; cin &gt;&gt; l &gt;&gt; r; l = getValByRank(l), r = getValByRank(r + 2); Splay(l, 0), Splay(r, l); flag(left(r)) ^= 1; } Output(Root); puts(\"\"); return 0; } 普通平衡树(Luogu P3369) 实现增, 删, 查询排名与反查, 查询前驱与后继功能. Solution1: std::vector #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; vector&lt;int&gt; v; int cas; int main() { cin &gt;&gt; cas; while(cas--) { int op, x; cin &gt;&gt; op &gt;&gt; x; switch(op) { case 1: //insert(x) v.insert(lower_bound(v.begin(), v.end(), x), x); break; case 2: //delete(x) v.erase(lower_bound(v.begin(), v.end(), x)); break; case 3: //getRank(x) cout &lt;&lt; lower_bound(v.begin(), v.end(), x) - v.begin() + 1 &lt;&lt; endl; break; case 4: //getValueByRank(x) cout &lt;&lt; v[x - 1] &lt;&lt; endl; break; case 5: //getPre(x) cout &lt;&lt; *--lower_bound(v.begin(), v.end(), x) &lt;&lt; endl; break; case 6: //getNxt(x) cout &lt;&lt; *lower_bound(v.begin(), v.end(), x + 1) &lt;&lt; endl; break; } } return 0; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"二分","slug":"二分","date":"2022-02-20T12:53:53.000Z","updated":"2022-02-20T12:56:05.619Z","comments":true,"path":"2022/02/20/二分/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/02/20/%E4%BA%8C%E5%88%86/","excerpt":"","text":"二分 二分查找 给定一个序列\\(\\{a\\}\\), 查找指定元素\\(x\\)位置. 代码实现 int bsearch(int* a, int x, int l, int r) { while(l &lt; r) { int mid = l + (r - l &gt;&gt; 1); if(a[mid] &gt;= x) r = mid; else l = mid + 1; } return a[l] == x ? l : -1; } 二分答案 单调区间内高效地查找最优答案, 可以看作\"枚举\"的优化. 常用来解决\"最大值最小化\"问题. Luogu P1873 砍树 如果枚举\\([1, 1\\times 10^9]\\)会超时, 使用二分答案. #include &lt;iostream&gt; typedef long long LL; const int N = 1e6; using namespace std; int n; LL a[N], m; bool isValid(LL height) { LL got = 0; for(int i = 0; i &lt; n; ++i) { got += max(a[i] - height, 0ll); } return got &gt;= m; } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i]; } int l = 1, r = 1e9 + 1; //闭合的区间, 1e9需要加一 while(l + 1 &lt; r) { //l, r不能相邻 int mid = l + (r - l &gt;&gt; 1); if(isValid(mid)) { l = mid; } else { r = mid; } } cout &lt;&lt; l &lt;&lt; endl; return 0; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"https://ret2libc-pwned.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"FREE-Figurines","slug":"FREE-Figurines","date":"2021-12-04T14:18:52.000Z","updated":"2021-12-04T14:20:43.140Z","comments":true,"path":"2021/12/04/FREE-Figurines/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/12/04/FREE-Figurines/","excerpt":"","text":"#include &lt;iostream&gt; const int N = 1e6; using namespace std; /* 两种操作: 接在后面 / 删除最前面. 最差情况: \"重组\", 即全部删了再拼起来. 需要2n次操作. 优化: 尾巴上的节点不需要操作. 可以统计有多少个这种节点, 减去节点数 * 2即可. */ int src[N], dest[N], len[N], n, ans; bool vis[N]; inline void debug() { printf(\"ans = %d\\n\", ans); } int main() { cin &gt;&gt; n; /*预处理, 统计最坏情况ans*/ for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; src[i]; vis[src[i]] = true; if(src[i]) ans++; } for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; dest[i]; vis[dest[i]] = true; if(dest[i]) ans++; } for(int i = 1; i &lt;= n; i++) { if(!vis[i]) { int tmpi = i; while(src[tmpi] * dest[tmpi] &amp;&amp; src[tmpi] == dest[tmpi]) { //不为自由的 &amp;&amp; 相等就是不用断开的链 ans -= 2; tmpi = src[tmpi]; } } } cout &lt;&lt; ans &lt;&lt; endl; return 0; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"POI2010 - TESIntelligence Test","slug":"POI2010-TESIntelligence-Test","date":"2021-11-21T13:01:04.000Z","updated":"2021-11-21T13:02:47.638Z","comments":true,"path":"2021/11/21/POI2010-TESIntelligence-Test/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/11/21/POI2010-TESIntelligence-Test/","excerpt":"","text":"#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; const int N = 1e6; #define YES puts(\"TAK\") #define NO puts(\"NIE\"); int len, tc; vector&lt;int&gt; nxt[N]; //思路 开二维vector存一堆指针 nxt[x][y]就是数字x出现的第y次的位置. //vector动态开内存 不会爆空间. //二分去找\"数字k出现第x次的位置\", 实现\"快速跳转\". int bsearch(int num, int expected_pos) { int l = 0, r = nxt[num].size() - 1, res = len + 1; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(nxt[num][mid] &gt; expected_pos) { r = mid - 1; res = mid; } else l = mid + 1; } //return nxt[num][res]; return (res == len + 1 ? res : nxt[num][res]); } int main() { ios_base::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; len; for(int i = 1; i &lt;= len; i++) { int tmp; cin &gt;&gt; tmp; nxt[tmp].push_back(i); } cin &gt;&gt; tc; while(tc--) { int l, a[N]; cin &gt;&gt; l; bool flag = true; int pos = 0; for(int i = 1; i &lt;= l; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= l; i++) { pos = bsearch(a[i], pos); //fprintf(stderr, \"a[%d] = %d,\\tpos = %d\\n\", i, a[i], pos); if(pos &gt; len) { flag = 0; break; } } flag ? YES : NO; } return 0; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-06T06:53:59.209Z","updated":"2021-10-17T09:07:02.605Z","comments":true,"path":"2021/10/06/hello-world/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/06/hello-world/","excerpt":"","text":"如题, 这是我的第一篇文章.","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"算法","slug":"算法","permalink":"https://ret2libc-pwned.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]}