{"meta":{"title":"Ret2Libc","subtitle":"真正的勇士敢于直面惨淡的人生，敢于正视淋漓的鲜血。 --鲁迅","description":"","author":"ret2libc","url":"https://ret2libc-pwned.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-10-16T12:54:16.000Z","updated":"2021-10-16T13:10:07.521Z","comments":false,"path":"categories/index.html","permalink":"https://ret2libc-pwned.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-10-16T14:14:36.000Z","updated":"2021-10-16T13:16:01.576Z","comments":false,"path":"about/index.html","permalink":"https://ret2libc-pwned.github.io/about/index.html","excerpt":"","text":"关于我 你好, 我是Ret2libc, 正在零基础入门算法! 本网站主要是自己的一点笔记和心得, 如果你恰好找到了这里, 我很希望它们能帮助到你! 联系方式 QQ 2184016258, 欢迎和我交朋友! 至于洛谷, poj之类的. 因为我太菜了, 没过几题. 等我 为什么叫Ret2libc? 主要是之前我对安全比较感兴趣, 尤其是pwn. 这是一个栈溢出利用方法. 取这个名字主要是不想让别人找到我(主要是OIer没几个知道这个词......). 这个网站会留多久? 存活时间可能很短, 主要是之前想在github上搭建, 但是无奈git push的时候连不上. 所以在这个平台上搭建. 这个平台我不是很喜欢, 所以可能随时删库跑路. 如果想跟我交流可以加一下QQ."},{"title":"tags","date":"2021-10-16T13:18:16.000Z","updated":"2021-10-17T03:36:02.847Z","comments":false,"path":"tags/index.html","permalink":"https://ret2libc-pwned.github.io/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-10-16T12:17:58.000Z","updated":"2021-10-16T13:25:50.508Z","comments":true,"path":"conmment/index.html","permalink":"https://ret2libc-pwned.github.io/conmment/index.html","excerpt":"","text":"有什么想说的? 有什么想问的?"}],"posts":[{"title":"Rp++","slug":"Rp","date":"2021-10-17T09:01:03.000Z","updated":"2021-10-17T09:02:15.079Z","comments":true,"path":"2021/10/17/Rp/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/17/Rp/","excerpt":"","text":"\\(CSP 2021 Rp++\\)","categories":[],"tags":[]},{"title":"国庆模拟赛后总结","slug":"国庆模拟赛后总结","date":"2021-10-17T03:11:30.000Z","updated":"2021-10-17T03:40:22.082Z","comments":true,"path":"2021/10/17/国庆模拟赛后总结/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/17/%E5%9B%BD%E5%BA%86%E6%A8%A1%E6%8B%9F%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/","excerpt":"","text":"赛后总结 注: 没写完, 因为有的题还没过. 前言 这个文档不一定在写精妙的算法, 有的部分甚至不是在分析满分解法, 更多的是怎么得该得的分以及怎么减少不必要的失分. 即: 目标是在j组复赛中分数最大化. 2021/10/01 T1 在调错上浪费太多时间了, 最后才发现算法没有问题, 是switch语句的问题!!! 教训: 在写代码之前推思路的时候一定要明确它的正确性! 发现运行的结果不一样时不要轻易改代码, 更不要轻易改算法! 调试小技巧: 输出一些东西 or 注释掉大段代码, 这些方法主要是快速定位出错的地方的, 实在不行可以下断点调试(用gdb可以的, 注意加debug symbol). 在怀疑算法出问题的时候在纸上推, 不要动代码!!! 这题的正解是模运算, 可以快速定位到循环运行多次后的指令, 不必一次次模拟了. T2 在推模拟分解质因数时浪费太多时间了, 这种考\"板子\"的数学题要在平时多做. 考场上要减少推板子的时间. 另外还好这题没打表, \"只要是数学题就打表\"终究是一种\"骗分\"的心态. 还是要多推式子. 附: 计算一个数素因数个数的代码 1234567891011int fac(int x) { int res = 0; for(int i = 2; i &lt;= x; i ++) { if(x % i == 0) { res ++; x /= i; i --; //这行推了蛮久的 } } return res;} 还有就是第十个点具体的数据给我们了, 是一个很大的数据, 这个O(N*sqrt(N))的算法显然要算很久(在我电脑上算了一个半小时), 所以只能用特判. 考试的时候可以优先用暴力或正解算着这种数据, 得到特判就行. 注: 这道是我两天模拟赛中唯一觉得做得还不错, 没啥太大遗憾的题. T3 模拟题, 字太多考试的时候懒得看了. 之后这种题要多想想! 至少把样例算算, 知道模拟的过程. T4 四联通问题, 把上下左右当成相邻的节点用bfs访问 2021/10/03 T1 一定要注意看清数据范围! 就比如这道题说了 \\[ N &lt; 1,000,000 \\] 就一定要开1e6, 宁肯开大一点也不要开小!!! 一位数组不会因为开得跟题中一样大而MLE!!! 教训: 1e5的代码52分, 1e6就ac了. 真的是很可惜的, 明明满分算法想出来了, 思路就是正确的, 甚至代码写得都没问题. 就是因为数组没开大, 失分惨重. 思路再说一下吧, 前缀和. 这种区间询问或操作一位数组问题的算法在我目前的知识范围内大多只会是前缀和, 差分, 树状数组, 线段树了, 更高级的感觉j组考不到, 现在也不是学这种东西的时候. 虽然1000万个数似乎很多, 但是, 如果这些数是8字节的整数, 那么将占用大致80MB. Introduction to Algorithms(3rd edition) T2 12const int N = 1e6;int array[N]; //大约占用4MB空间 这道题因为开了1e8的数组, 用了memset导致全部的点MLE. 数组不要开太大!!! (1e8个int约等于380MB) 本来可以得60分暴力分, 结果这题因为这个爆零了. 本题的正解是离线询问, 并记录操作, 类似于化简到最后一个操作, 就不必模拟了. 说到玄学优化, 在这里记录几个好用的玄学优化: cin优化 12ios_base::sync_with_stdio(false);cin.tie(0); //cin.tie(nullptr)在C++11及以上可用 (这两行的意思是关闭与stdio的同步, 以提升cin, cout的速度. 在IO比较多的时候很好用. 注意:用了这个优化就不能用stdio内的函数如printf()和scanf(). 当然printf和scanf的速度是更快的, 如果会写快读快写那更快, putchar()和getchar()的速度不是吹的. ) 寄存器操作 1for(register int i = 0; i &lt; n; i ++) 直接操作寄存器, 这样更快. p.s. csp用不了内联汇编, 所以不要作死, 这个用用就行了 行内函数(inline) 1234567891011121314inline int add(int x, int y) { return x + y;}int main() { add(1, 1); //直接就地展开函数, 没有调用关系 /* 相当于 inline int add(int x, int y) { return x + y; } */ return 0;} 适用于代码少, 调用频繁的函数. 函数调用时会将参数, 基址这些东西压栈. 最后call. 运行结束后会压入返回地址等信息(这些东西快忘了, 不对请指正). 这样调用一次无疑浪费了很多时间精力.(有空的话贴一下反汇编代码看得更清楚) 用inline定义会在调用处就地展开, 个人觉得比较像define(?) T3 这里发现了两轮游戏中的单调性质, 但是竟然在纠结用哪个数据结构实现!!! 最后时间全浪费了, 暴力都没写完. 以后算法较为简单的题, 一定要先写暴力或者基本思路, 不要先默板子或纠结该默哪个板子!!! T4 这一题要采用类似图论存图的方法存能开哪里的灯, 然后bfs. 题干的意思其实是要找到房间之间的 \"连接\" 关系. 想到这里就能知道要用类似邻接表的方式存图了. 考场上我主要的问题在于只想着打暴力就用dfs, 就能拿分. 但是这个dfs在本机都肉眼可见地慢, 就放弃治疗, 也不想剪枝了. 想到bfs而不是用其它方法个人理解是因为本题要先开相邻的灯, 如果dfs需要走完一个方向才能走另一个方向, 不剪枝极其浪费. 2021/10/05 T1 模拟赛中第一次ac. 老师给的题解: 数组模拟 (可以理解为手写双端队列) 自己的解法: stl大法好(使用std::deque, 即双端队列, 可以理解为可操作两端的std::queue) 可能会出现的问题: 一些stl内的函数可能性能不如手写的, 例如std::string里面的S.find(P)就是暴力匹配的, 性能不如手写KMP. 这是个重大的时刻, 贴个代码纪念一下, 顺便复习一下deque的用法. (另外做这题的时候好像cin忘加了, 导致浪费了亿点时间调错) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;deque&lt;int&gt; q; //需要从前后操作, 双端队列int n, id;inline void clearq() { while(q.size()) { q.pop_front(); }}inline void add(char op, int x) { //op == 'L' 左边入队 //op == 'R' 右边入队 //cout &lt;&lt; \"add()\" &lt;&lt; op &lt;&lt; ' ' &lt;&lt; x; if(op == 'L') { q.push_front(x); } if(op == 'R') { q.push_back(x); }}inline void kill_people(char op, int x) { if(op == 'L') { for(int i = 0; i &lt; x; i ++) q.pop_front(); } if(op == 'R') { for(int i = 0; i &lt; x; i ++) q.pop_back(); }}inline int popq() { int res; res = q.front(); q.pop_front(); return res;}int main() { //clearq(); ios_base::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) { //puts(\"LOOP\"); char op, op1; int k; cin &gt;&gt; op &gt;&gt; op1; //cout &lt;&lt; op &lt;&lt; ' ' &lt;&lt; op1; if(op == 'A') { add(op1, ++ id); //只有入队才会有新的编号, 单独记录 //puts(\"added!!!\") } else { cin &gt;&gt; k; kill_people(op1, k); } } while(q.size()) { cout &lt;&lt; q.front() &lt;&lt; endl; //从队首开始pop q.pop_front(); } return 0;} T2 T3 暴力解法是每个数跟它的左边和上面比较, 统计出符合条件的, 计算最大的面积. 正解是dp. 预处理column[i][j]和can[i][j][k](用can[i][j][k]表示从第 i 行到第 j 行中的第 k 列能否接道第 i 行到第 j 行的 k-1 列中): \\[ column[i][j]={column[i-1][j]+1(a[i][j]&gt;=a[i- 1][j]),column[i][j]=1} \\] 其中 \\[ can[i][j][k]=(can[i][j-1][k])\\and(column[j][k]&gt;=j-i+1)\\and(a[j][k]&gt;=a[j][k- 1])\\and(coulumn[j][k-1]&gt;=j-i+1 \\] 贴一个70分解法(用的不是dp, 也不是我写的) 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;//DP?!不过我不想用正常的方法 那就写点玄学的吧。int n,m,ma[205][205],row[205][205],col[205][205];int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)cin&gt;&gt;ma[i][j]; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j){ row[i][j]=1; for(int k=j+1;k&lt;=m;++k){ if(ma[i][k-1]&lt;=ma[i][k])row[i][j]++; else break; } } for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=n;++j){ col[j][i]=1; for(int k=j+1;k&lt;=n;++k){ if(ma[k-1][i]&lt;=ma[k][i])col[j][i]++; else break; } } //完了完了 玄学方法开始了 int temp=0,ans=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) for(int k=1;k&lt;=row[i][j];++k){//k就是一种长度 int len=*min_element(col[i]+j,col[i]+j+k); temp=k*len; ans=max(temp,ans); } cout&lt;&lt;ans&lt;&lt;endl; return 0;} T4 这题不知道为什么写的算法没问题, 比赛的时候交了是零分(赛后交了一遍完全一样的代码ac了). 就当这次ac了吧, 但是一定要明白为什么会出这种问题, 比赛的时候要是还出就叫天天不灵, 叫地地不应了. 这题想了蛮久的, 主要是证明算法的正确性. 要注意的就是如果这种贪心题最后推出了一个比较简单的式子不要怀疑, 只要每一步都确定是对的式子就没错, 不要在这里过于纠结, 浪费时间. 思路再说一下: 要让ci * t最大, 就要让ci越大的获得更大时间差(这不是废话吗), 即把ci进行从大到小排序, 依次把最大的两个一样的放到最前面和最后面. 难点是模拟这个放在最前和最后的过程. 贴一下考场上的代码, 前面是排序. 12345678910111213141516//安排位置 int n1 = 1, n2 = n; //[1, n] //n1: 开始时间偏移量 //n2: 结束时间偏移量 //sigma c = (0 + n1) * c[i + 1] + (n - n2 - n) * c[i] for(int i = 1; i &lt;= k, n1 &lt;= n2; i ++, n1 ++, n2 --) { //两两一对地插入 //if(c[i] == c[i + 1]) //cout &lt;&lt; (c[i] == c[i + 1]) &lt;&lt; ' ' &lt;&lt; c[i] &lt;&lt; ' ' &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; c[i - 1] &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; endl; //把大(c[i])的放在最后 小的(c[i + 1])放在最前 时间差最大 //第一次不得分 求时间差乘以最大的(即c[i])即可 //ans += ((n2 - n1) * c[i] + 0); ans += (n2 - n1) * c[i]; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"模拟赛","slug":"模拟赛","permalink":"https://ret2libc-pwned.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://ret2libc-pwned.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-06T06:53:59.209Z","updated":"2021-10-06T06:53:59.209Z","comments":true,"path":"2021/10/06/hello-world/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"模拟赛","slug":"模拟赛","permalink":"https://ret2libc-pwned.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://ret2libc-pwned.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"}]}