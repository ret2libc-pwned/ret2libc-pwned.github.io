{"meta":{"title":"OI-Cheatsheet","subtitle":"Hello, the cruel world.","description":"","author":"ret2libc-pwned","url":"https://ret2libc-pwned.github.io","root":"/"},"pages":[{"title":"","date":"2022-07-28T11:32:31.591Z","updated":"2022-07-28T11:32:31.591Z","comments":false,"path":"js/music_player.js","permalink":"https://ret2libc-pwned.github.io/js/music_player.js","excerpt":"","text":"// !(function() { // var oldLoadAp = window.onload; // window.onload = function () { // oldLoadAp &amp;&amp; oldLoadAp(); // new APlayer({ // container: document.getElementById('aplayer'), // fixed: true, // autoplay: false, // loop: 'all', // order: 'random', // theme: '#b7daff', // preload: 'none', // audio: [ // { // name: '平凡之路', // artist: '朴树', // lrc: '/downloads/lrc/平凡之路-朴树.lrc', // cover: 'http://p2.music.126.net/W_5XiCv3rGS1-J7EXpHSCQ==/18885211718782327.jpg?param=300x300', // url: 'http://fs.open.kugou.com/cd5cbe8edb012e4f77b0857cefc0956e/5c66accf/G097/M08/0A/1F/AYcBAFkQGpOAMUpuAEm-3SlWMyk951.mp3' // } // ] // }); // } // })();"},{"title":"关于我","date":"2021-10-16T14:14:36.000Z","updated":"2022-06-25T12:05:19.965Z","comments":false,"path":"about/index.html","permalink":"https://ret2libc-pwned.github.io/about/index.html","excerpt":"","text":"自我介绍 你好, 我是 ret2libc-pwned@github, 正在 零基础 入门OI . 这是我的一本小抄, 如果你恰好找到了这里, 我很希望它能帮助到你! 联系方式 QQ 2184016258, 欢迎和我交朋友, 或者教教我怎么零基础入门算法! 这个名字有什么含义? ret2libc 是 pwn (二进制安全, binary exploitation)里的一个利用技巧."},{"title":"tags","date":"2021-10-16T13:18:16.000Z","updated":"2021-10-17T03:36:02.847Z","comments":false,"path":"tags/index.html","permalink":"https://ret2libc-pwned.github.io/tags/index.html","excerpt":"","text":""},{"title":"原创数学讲义与试题","date":"2022-07-02T08:20:04.000Z","updated":"2022-07-02T08:34:11.745Z","comments":true,"path":"math-notebook/index.html","permalink":"https://ret2libc-pwned.github.io/math-notebook/index.html","excerpt":"","text":"欢迎使用 您好, 感谢阅读博主原创的数学讲义与部分原创的习题. 关于讲义 这套讲义使用 Typora 软件编写, 公式使用 \\(\\LaTeX\\) 编辑. 练习题按照学校试卷样式导出到 Word软件再次排版. 讲义和练习的整体难度略高于课内知识, 可以根据您的需要进行拓展延伸. 讲义页眉会标明 release date 和 作者联系方式 , 可以通过下方途径反馈, 反馈时需提供讲义的截图 或 release date. 反馈与勘误 该套讲义是博主自己 个人使用 的, 暂时不开设读者论坛等途径进行交流反馈. 欢迎您将讲义分享给其他人, 或是二次编辑进行 非盈利 活动 (源文件可加QQ索要). 希望可以帮助更多对想要提升数学能力或者对数学感兴趣同学! 注: 如果您不能通过讲义上的联系方式找到我, 可以在页面下方留言!"},{"title":"tags","date":"2021-10-16T12:54:16.000Z","updated":"2021-10-16T13:10:07.521Z","comments":false,"path":"categories/index.html","permalink":"https://ret2libc-pwned.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"OI中的数学知识","slug":"OI中的数学知识","date":"2022-10-15T15:32:08.000Z","updated":"2022-10-15T15:48:16.701Z","comments":true,"path":"2022/10/15/OI中的数学知识/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/10/15/OI%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/","excerpt":"","text":"这也是暑假没填的坑…… 数学复习 运算优化 快速幂 整数可以表达为若干个 2 的整数次幂之和, 即 可以\"二进制拆分\". (该性质应用广泛, 例如树状数组). 同样的道理, 我们也能拆分指数, 实现快速幂. 形式化地说: $a^b=\\sum _{i=0} ^{k-1} a^{{c_i}\\cdot 2i}\\ \\ \\ (k = \\lceil\\log (b + 1)\\rceil). (Hexo渲染不了，请自行复制到可以渲染 \\(\\LaTeX\\) 的地方查看) 实现过程为从低到高取 \\(b\\) 二进制中的每一位 \\(c_i\\) , 若当前位是 \\(1\\) 则将最终答案乘上 \\(a\\) (可以理解为把落单的 \\(a\\) 乘上去), 然后将 \\(a\\) 平方. 12345678const int mod = 1e9 + 7;int pow(int x, int k) { int res = 1 % mod; for(; k; x = (long long)x * x % mod, k &gt;&gt;= 1) { if(k &amp; 1) res = (long long)res * x; } return res;} 快速乘 类比快速幂的二进制拆分思想, 把累\"乘\"变成累加即可. 注意它们的区别!!! 例如 res 应初始为 \\(0\\) 等. 12345678LL mul(LL a, LL b, LL p) { // a*b mod p LL res = 0; for(; b; a = (a &lt;&lt; 1) % p, b &gt;&gt;= 1) { if(b &amp; 1) res = ((LL)res + a) % p; } return res;} 数论 Todo. 线性代数 对于矩阵 \\(A\\), 主对角线 指的是 \\(A_{i,i}\\) 的元素. 主对角线为 \\(1\\), 其他元素为 \\(0\\) 的矩阵称为 单位矩阵. 任何一个矩阵乘以单位矩阵的结果是自己本身, 类似于数字乘法中 \\(1\\) 的作用. 矩阵运算 加法 设矩阵 \\(A\\) 是 \\(M\\) 行 \\(N\\) 列的矩阵, \\(B\\) 是 \\(M\\) 行 \\(N\\) 列的矩阵, \\(C = A + B\\). (\\(C\\) 有 \\(M\\) 行 \\(N\\) 列) 则: \\[ C_{i,j} = A_{i, j} + B_{i, j} \\] 乘法 设矩阵 \\(A\\) 是 \\(M\\) 行 \\(N\\) 列的矩阵, \\(B\\) 是 \\(N\\) 行 \\(Q\\) 列的矩阵, \\(C = A \\cdot B\\). (\\(C\\) 有 \\(M\\) 行 \\(Q\\) 列) 则: \\[ C_{i,j} = \\sum_{k=1}^{N} A_{i, k} \\cdot B_{k, j} \\] 例如: \\[ \\begin{bmatrix} 2 &amp; 1 &amp; 4\\\\ 0 &amp; 1 &amp; 1\\ \\end{bmatrix} \\cdot \\begin{bmatrix} 6 &amp; 3 &amp; -1 &amp; 0\\\\ 1 &amp; 1 &amp; 0 &amp; 4\\\\ -2 &amp; 5 &amp; 0 &amp; 2 \\end{bmatrix} = \\begin{bmatrix} 5 &amp; 27 &amp; -2 &amp; 12 \\\\ -1 &amp; 6 &amp; 0 &amp; 6 \\end{bmatrix} \\] 矩阵乘法满足结合律, 不满足交换律. (因为要保证第一个矩阵的行数等于第二个矩阵的列数). 模板代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e6 + 10;using LL = long long;const int SIZ = 18, MOD = 1e9 + 7;struct Matrix { int a[SIZ][SIZ]; Matrix() { memset(a, 0, sizeof a); } Matrix operator +(const Matrix&amp; B) { Matrix res; for(int i = 1; i &lt;= SIZ; ++i) { for(int j = 1; j = SIZ; ++j) { res.a[i][j] = (a[i][j] + B.a[i][j]) % MOD; } } return res; } Matrix operator -(const Matrix&amp; B) { Matrix res; for(int i = 1; i &lt;= SIZ; ++i) { for(int j = 1; j = SIZ; ++j) { res.a[i][j] = (a[i][j] - B.a[i][j]) % MOD; } } return res; } Matrix operator *(const Matrix&amp; B) { Matrix res; for(int i = 1; i &lt;= SIZ; ++i) { for(int j = 1; j &lt;= SIZ; ++j) { for(int k = 1; k &lt;= SIZ; ++k) { res.a[i][j] += (LL)(a[i][k] * B.a[k][j]); res.a[i][j] %= MOD; } } } return res; }};Matrix pow(Matrix x, int k) { Matrix res; for(int i = 1; i &lt;= SIZ; ++i) res.a[i][i] = 1; for(int i = 1; i &lt;= SIZ; ++i) { for(int j = 1; j &lt;= SIZ; ++j) { x.a[i][j] %= MOD; } } for(; k; k &gt;&gt;= 1) { if(k &amp; 1) res = res * x; x = x * x; } return res;}int main() { // a * b Matrix a, b; int n, m, q; cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for(int i = 1; i &lt;= n; ++i) { for(int j = 1; j &lt;= m; ++j) { cin &gt;&gt; a.a[i][j]; } } for(int i = 1; i &lt;= m; ++i) { for(int j = 1; j &lt;= q; ++j) { cin &gt;&gt; b.a[i][j]; } } Matrix c = a * b; for(int i = 1; i &lt;= m; ++i) { for(int j = 1; j &lt;= q; ++j) { cout &lt;&lt; c.a[i][j] &lt;&lt; ' '; } puts(\"\"); } return 0;} 矩阵加速递推 矩阵变换 初等行变换 初等行变换包含: 互换某两行; 将某一行向量乘上非零实数 \\(\\lambda\\) ; 将某一行向量与另一行向量相加. 高斯消元 求解线性方程组 求解异或方程组","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"暑假OI十日训练记录","slug":"暑假OI十日训练记录","date":"2022-10-15T15:08:18.000Z","updated":"2022-10-15T15:52:11.484Z","comments":true,"path":"2022/10/15/暑假OI十日训练记录/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/10/15/%E6%9A%91%E5%81%87OI%E5%8D%81%E6%97%A5%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/","excerpt":"","text":"暑假里曾经心血来潮想练 OI , 计划着每天花一下午练习然后在这个文档里打卡记录, 记了十天然后发现 Typora 太卡了, 自己效率还很低, 就没坚持下去. 这个文档还有很多题目没补完! 我现在 OI 还什么都不会, 就是因为三分钟热度, 学得太少、练得太少, 还走了很多弯路. 今天把这个文档从旧电脑里翻出来放在 Cheatsheet 上面提醒一下自己, 不能再这样了!!! 下面是文档原文, 计划里的东西都没怎么完成, 到最后完全放弃了...... 这一定是一个教训! 计划 周一到周五下午: 做题. 《算法竞赛进阶指南》完成并打卡; OI Wiki相关例题; Luogu 相关题单. 周末下午: CF VP(2 ~ 2.5h). 打完后 订正 + 题解. 一周保证 20+ 小时的有效做题 / 比赛时间 (指能写代码的时间, 不含上课等). 记录 此处应包含 日期、练习内容、简单题解、备注 等记录. 以下是一个示例: 12345678910111213### 1970-01-01#### 练习内容1. P1001 A + B#### 简单题解这是一道模拟题, 读入两个整数 $a、b$ , 输出它们的和即可.#### 备注可以使用 `(a &amp; b) + (a | b)` 高性能地实现. 2022-06-30 练习内容 acw171 送礼物 \\(88 \\to 100\\). 简单题解 类似0/1背包, 但是DP做法空间开销太大, 考虑用双向DFS进行子集和枚举. 即: 将 g[] 一分为二 (经试验, 分为 \\([1, n / 2 + 2]\\) 与 \\([n/2 + 3, n]\\) 最快), 分别搜索. 写两个 dfs 函数, 一个搜索前半部分选取若干礼物能凑出重量的所有可能值, 存入数组 pre[]. 另一个在后半部分二分搜等于或小于 w - pre[i] 的最大值(即前驱). 可以在执行第一个 dfs 前降序排序 g[], 保证大的重量先被选到, 这是一个剪枝. 备注 双向搜索时, 选取合适的 折半点 有时是一个优化方法; 在二分时, 可以使用 algorithm 库中的 *std::lower_bound(a.begin(), a.end(), val) 查询 val 前驱, *--std::lower_bound(a.begin(), a.end(), val) 查询后继. 2022-07-01 (正式开始!!!) 练习内容 蓝书 acw89 a^b acw90 64位整数乘法 acw91 最短Hamilton路径 Todo acw998 起床困难综合症 简单题解 a^b(快速幂) 整数可以表达为若干个 2 的整数次幂之和, 即 可以\"二进制拆分\". (该性质应用广泛, 例如树状数组). 同样的道理, 我们也能拆分指数, 实现快速幂. 形式化地说:$a^b=\\sum _{i=0} ^{k-1} a^{{c_i}\\cdot 2i}$ $(k = \\lceil\\log (b + 1)\\rceil)$ （Hexo不能渲染，请自行复制到能渲染 \\(\\LaTeX\\) 的编辑器（如 Typora、MathType等 ）查看） . 实现过程为从低到高取 \\(b\\) 二进制中的每一位 \\(c_i\\) , 若当前位是 \\(1\\) 则将最终答案乘上 \\(a\\) (可以理解为把落单的 \\(a\\) 乘上去), 然后将 \\(a\\) 平方. 64位整数乘法 类比快速幂的二进制拆分思想, 把累\"乘\"变成累加即可. 注意它们的区别!!! 例如 res 应初始为 \\(0\\) 等. 最短Hamilton路径 这一题的 BF 解法: 枚举点的全排列取最短, 状态数量 \\(\\mathcal O(n!\\cdot n)\\) . \\(n = 20\\), 时限 5s, 过不了. 考虑状态定义, 需要记录: 走过哪些点; 当前处于哪一个点. 考虑状压 DP . 即将 0/1 状态压缩到一个整数中, 使得可以通过状态调用子问题答案. 设 \\(f_{st, u}\\) 为当前走到 \\(u\\) 号点, 走过与否的局面为 0/1 集合 \\(\\{st\\}\\) . 则: \\[ f_{st, u} = \\min _{0 \\le v \\le n - 1} \\{f_{st_v, v} + dis_{u, v}\\}\\\\ \\] 其中 \\(st_v\\) 为 \\(st\\) 除去 \\(u\\) 得到的状态集合. 可以使用位运算 st ^ (1 &lt;&lt; u) 得到. 现在枚举 \\(st\\) ([0, 1 &lt;&lt; n - 1], 即全 \\(0\\) 到全 \\(1\\))、点\\(u, v\\), 即可. 注意状态是否合法(代码中 if 语句). 时间复杂度 \\(\\mathcal O(n^2 \\cdot 2^n)\\) . 备注 效率还要再高一点. 2022-07-02 练习内容 CF1698 VP (200 pts) acw几道水题 递归实现指数 / 排列 / 组合型枚举 简单题解 A. XOR Mixup 枚举即可. 比赛时一开始不知道本题有 SPJ, 所以看到输出与样例不一样就卡了好久. B. Rising Sand 对于任意一个区间, 选取多个数 \\(+1\\) 对原答案无贡献(因为不能将一个数从\"不高\"到\"高\"). 但是有一种特例: 选取单个数 \\(+1\\) . 因为可以有多次操作(刚开始没看到!), 所以当 \\(k = 1\\) 时, 答案必为\"被夹在中间的元素数量\", 即 \\(\\dfrac{n-1}{2}\\) . C. 3SUM Closure 题看错了! 题意为: 任意 三元组的和都能在原序列中找到, 不是找到一个就行了. DFS实现枚举 将状态抽象成一棵搜索树即可, 想想自顶向下遍历时需要传递什么信息? 回溯上来时需要改变什么为后续搜索做准备? 以及其它类似问题. 备注 第一次打 CF, 不太熟悉. 主要问题如下: 没注意题目的细节. 在 A、B、C 中都有这个问题, 导致了浪费时间; 认为只要修改代码就能碰运气输出正确答案, 导致不重视思考甚至题目的理解; 下次看到\"输出正确的一个就算对\"这类字眼就要知道这题大概率用了 SPJ. 2022-07-03 练习内容 CF1700 VP; 简单题解 A. Optimal Path (贪心) 横着走的代价是 \\(1\\) , 竖着走的代价是 \\(m\\). 所以先从 \\((1, 1)\\) 走到 \\((1, m)\\), 再往下走到 \\((n, m)\\). \\(\\mathcal O(1)\\) 计算, 答案即为: \\[\\dfrac{(1 + m)m}{2} + \\dfrac{m(2 + n)(n - 1)}{2} \\] . B. Palindromic Numbers (构造) 对于首位非 \\(9\\) 的情况, 构造 \\(n\\) 个 \\(9\\) 组成的数即可; 对于首位是 \\(9\\) 的情况, 构造 \\((n + 1)\\) 个 \\(1\\) 即可. 注意 \\(n \\le 10^5\\), 需要高精减法. C. Helping the Nature (差分) 求出序列的差分数组 \\(b\\) , D. 可以发现, 最优构造一定是把所有水管放在最前面的连续一段. 否则后面的水都溢出来了前面的还没满. (Solution 1: 二分) ==Todo== (Solution 2: 数学) 记 \\(\\sum _{j = 1} ^{i} v_i = s_i\\) , 按照上述的构造方法, 开前 \\(i\\) 个水管把前 \\(i\\) 个容器灌满的时间为 \\(t_i = \\lceil \\dfrac{s_i}{i} \\rceil\\) . 我们可以求出 \\(\\max\\{t_i\\}\\) 即为 \\(t\\) 的下界. 如果询问中的 \\(t\\) 小于这个下界即可判定无解, 否则答案为 \\(\\lceil \\dfrac{s_n}{t} \\rceil\\) . E. Serega the Pirate 备注 在计算 ceil(p / q) 时, 可以这样: (p + q - 1) / q. 2022-07-04 练习内容 订正两场CF, 补充简单题解. 简单题解 主要是后面几道题, 已经补充. 备注 无. 2022-07-05 练习内容 继续订正; acw164 可达性统计. 简单题解 订正题解已补. 可达性统计 图 \\(G = (V, E)\\) 中, 顶点 \\(u\\) 可达顶点的集合为: \\[ f(u) = \\{u\\} \\cup \\{\\bigcup_{(u, v) \\in E} f(v)\\} \\] 其中, 集合 \\(f(u)\\) 可以用 \\(n\\) 个 0/1 状态表示对于各个顶点是否可达. 尝试状态压缩, 取并运算即为按位或. 最后每个结点的集合 \\(f\\) 中 1 的个数即为所求. 我们可以发现上式的递推性质, 即需要通过 \\(u\\) 的相邻结点更新 \\(f(u)\\) . 如何做到 通过先访问的结点更新后访问的结点的状态 呢? 答案是 拓扑排序. 预处理拓扑序列, 倒序访问序列中每一个结点, 并向前递推更新即可. 备注 状压时要看清楚数据范围, 合理选择用(32位? 64位? (Linux下) 128位?)整数压还是用bitset压, 这一题 \\(n、m \\le 30000\\), 考虑使用 bitset. 2022-07-06 练习内容 acw165 小猫爬山 Luogu P1605 迷宫 Luogu P1219 八皇后 简单题解 小猫爬山 考虑使用 DFS . 用 cab[] 记录每辆缆车的重量. 使用 dfs(idx, cnt) 求解第 \\(idx\\) 只猫用了 \\(cnt\\) 辆车的情况. 加两个剪枝: c[] 从大到小排序, 使得重的猫 (较难装的) 先被装进去; 当 \\(cnt \\gt ans\\) 时结束搜索. 答案 \\(ans\\) 初值设为最坏情况 \\(n\\) , 即每只猫给一辆车的情况. 迷宫(回溯法模板) 回溯法简述: 在搜索时, 我们有时需要给状态打上标记(如是否访问某个结点或当前状态的某个权值). 这个标记可能会影响到后续搜索. 例如这一题中在一条路径中被搜过的点在另一条路径还能走. 这时就需要在回溯时清除或修改这个标记. 因为 DFS 的回溯是自底向上的, 所以能够方便地清除搜索树中自根结点至叶结点路径上的标记. 参考实现如下: 12345678910111213void dfs(PII now) { if(now == ed) { ++ans; return; } for(int i = 0; i &lt; 4; ++i) { PII nxt = make_pair(now.x + dx[i], now.y + dy[i]); if(obs[nxt.x][nxt.y] || vis[nxt.x][nxt.y] || nxt.x &lt; 1 || nxt.x &gt; n || nxt.y &lt; 1 || nxt.y &gt; m) continue; vis[nxt.x][nxt.y] = 1; dfs(nxt); vis[nxt.x][nxt.y] = 0; }} 八皇后 该题也是回溯法的一道例题. 难点在于如何判定对角线与平行线是否摆了棋子. 设列为 \\(x\\) , 行为 \\(y\\) . 则对角线和平行线的方程为: \\[ \\begin{cases}\\ell_1: y=-x+b_1,\\\\\\ell_2: y=x+b_2\\\\\\end{cases} \\Rightarrow \\begin{cases}b_1 = x + y,\\\\ b_2 = y - x\\end{cases} \\] 可以使用截距 \\(b_{1,2}\\) 为关键字访问 vis[] 数组中对角线上的情况. 注意 \\(b_2\\) 可能为负, 所以在数组中统一加上大于等于 \\(x,y\\) 的 \\(n\\) . 备注 2022-07-07 练习内容 上课. 2020-07-08 练习内容 搜索补题. 2020-07-09 练习内容 CF 1699 vp 简单题解 A. The Third Three Number Problem (构造) 可以发现异或运算的性质: \\(x \\oplus x = 0, 0 \\oplus x = x\\). 可以构造出 \\(\\{\\dfrac n 2, 0, 0\\}\\) 或者是 \\(\\{\\dfrac n 2, \\dfrac n 2, 0\\}\\). B. Almost Ternary Matrix (构造) 答案是如下的矩阵 旋转 而成的: 121 00 1 所以可以构造出下图的矩阵来: 注：赛时想到的如下： 12341, 0, 0, 10, 1, 1, 00, 1, 1, 01, 0, 0, 1 C. The Third Problem 根据定义, 有: \\(\\operatorname{MEX}(P) = \\min\\{\\complement_{\\mathbb N^*} P\\}\\). 备注","categories":[{"name":"随记","slug":"随记","permalink":"https://ret2libc-pwned.github.io/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[]},{"title":"初三一模数学练习一","slug":"初三一模数学练习一","date":"2022-10-01T08:57:34.000Z","updated":"2022-10-02T06:56:26.469Z","comments":true,"path":"2022/10/01/初三一模数学练习一/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/10/01/%E5%88%9D%E4%B8%89%E4%B8%80%E6%A8%A1%E6%95%B0%E5%AD%A6%E7%BB%83%E4%B9%A0%E4%B8%80/","excerpt":"","text":"数学一模练习一 一模将至，博主提供练习。 试卷共 10 题，100 分，题目均是原题。 进入试卷","categories":[{"name":"文化课","slug":"文化课","permalink":"https://ret2libc-pwned.github.io/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"}],"tags":[{"name":"课内数学","slug":"课内数学","permalink":"https://ret2libc-pwned.github.io/tags/%E8%AF%BE%E5%86%85%E6%95%B0%E5%AD%A6/"},{"name":"平面几何","slug":"平面几何","permalink":"https://ret2libc-pwned.github.io/tags/%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/"}]},{"title":"电脑换新","slug":"电脑换新","date":"2022-10-01T08:34:10.000Z","updated":"2022-10-01T08:38:39.103Z","comments":true,"path":"2022/10/01/电脑换新/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/10/01/%E7%94%B5%E8%84%91%E6%8D%A2%E6%96%B0/","excerpt":"","text":"终于换新电脑了，hexo博客迁移成功！","categories":[{"name":"随记","slug":"随记","permalink":"https://ret2libc-pwned.github.io/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[]},{"title":"状态压缩技巧","slug":"状态压缩技巧","date":"2022-07-29T08:53:54.000Z","updated":"2022-07-29T09:42:13.558Z","comments":true,"path":"2022/07/29/状态压缩技巧/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/07/29/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E6%8A%80%E5%B7%A7/","excerpt":"","text":"状态压缩 状态压缩, 是将 0/1 状态构成的集合用空间占用较小的载体 (如整数、bitset) 表示的技巧. 例如在数组 [1, 8, 7, 2, 5, 3] 中, 一个状态表示选取子序列 [1, 7, 5] , 它就可以表示为 0b10100 . 注意事项 选择合适的载体进行压缩 对于上文所说的状态集合, 为什么不开一个bool 类型的数组存储呢? 如果是那样多方便! 答案是: 费空间 . 注意到, 一个 bool 类型的变量占用 1 字节 (8 bit) 的空间, 而不是 1 bit. 这是因为需要方便计算机寻址. (在较早的 C 语言标准中甚至没有引入 bool 类型, 需要程序员根据习惯使用 unsigned short 或者 char 等进行宏定义). 状态集合可能会很大, 所以, 直接用 bool 数组存储这个集合不太合适. 同时, bool 数组不方便进行数学与位运算. 故需要将这些状态压缩到更合适的载体中存储. 整数状态压缩 将 0/1 状态集合压缩到二进制整数中. 优势 可作为数组下标访问数组元素(需要在 size_t 范围内). 例如在状压 DP 时将 0/1 状态集合压缩成的整数作为访问答案的其中一个关键字, 能通过当前局面进行递推计算答案. 可以进行数学运算. 缺陷 集合的大小有限制( \\(2^{状态数量}\\) 不能超过当前类型数据范围). 操作较为繁琐; 过多使用位运算会使代码可读性较差. std::bitset 优势 支持位运算. 像一个数组一样, 操作较为简便. 长度不受限制. 缺陷 不支持数学运算. 不能访问数组元素. 应用 子集枚举 例题 (动态规划中) 表示状态","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://ret2libc-pwned.github.io/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"搜索算法入门","slug":"搜索算法入门","date":"2022-06-24T06:04:12.000Z","updated":"2022-07-29T08:57:31.128Z","comments":true,"path":"2022/06/24/搜索算法入门/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/06/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/","excerpt":"","text":"深度优先搜索 (DFS) 本质是将状态的集合表达为一棵搜索树, 自顶向下地递归求解子问题 (抽象为图就是: 每一层为一个阶段, 每一个结点表示一个决策. 深度优先遍历每一棵子树). 该方法可能会多次重复递归求解相同子问题 (表现为 dfs 函数多次在调用时传入相同参数) , 效率较低. 此时可以使用 记忆化搜索 (自顶向下、带备忘录的方法) 或 动态规划 (自底向上方法). 几个简单例子 数的分解 将 \\(n\\) 分解成不多于 \\(k\\) 的数相加的形式. 123456789101112131415161718192021#include &lt;iostream&gt;const int N = 1e6 + 10;using namespace std;int n, k, ans[N];void dfs(int idx, int lst, int left) { // 填入第 idx 项, 上一个数为 lst, 还剩下的总和为 lst if(left == 0 &amp;&amp; idx == k + 1) { // Output; for(int i = 1; i &lt;= idx - 1; ++i) cout &lt;&lt; ans[i] &lt;&lt; ' '; puts(\"\"); } for(int i = lst; i &lt;= left; ++i) { ans[idx] = i; dfs(idx + 1, i, left - i); }}int main() { cin &gt;&gt; n &gt;&gt; k; dfs(1, 1, n); return 0;} 输出全排列方案 输出编号为 \\(1\\cdots n\\) 元素的全排列. 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;int n, ans[21];bool vis[21];void dfs(int idx) { if(idx == n + 1) { for(int i = 1; i &lt;= idx - 1; ++i) { cout &lt;&lt; setw(5) &lt;&lt; ans[i]; } puts(\"\"); return; } for(int i = 1; i &lt;= n; ++i) { if(vis[i]) continue; ans[idx] = i; vis[i] = 1; dfs(idx + 1); vis[i] = 0; // 回溯 }}int main() { cin &gt;&gt; n; dfs(1); return 0;} 输出组合方案 输出编号为 \\(1\\cdots n\\) 元素中取 \\(k\\) 个元素的组合方案. 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;iomanip&gt;const int N = 33;using namespace std;int n, k, ans[23];bool vis[23];void dfs(int idx, int lst) { if(idx == k + 1) { for(int i = 1; i &lt;= idx - 1; ++i) cout &lt;&lt; setw(3) &lt;&lt; ans[i]; puts(\"\"); return; } for(int i = 1; i &lt;= n; ++i) { if(vis[i] || i &lt;= lst) continue; ans[idx] = i, vis[i] = 1; dfs(idx + 1, i); vis[i] = 0; }}int main() { cin &gt;&gt; n &gt;&gt; k; dfs(1, -1); return 0;}","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"搜索","slug":"搜索","permalink":"https://ret2libc-pwned.github.io/tags/%E6%90%9C%E7%B4%A2/"}]},{"title":"树形DP","slug":"树形DP","date":"2022-06-22T14:30:41.865Z","updated":"2022-06-22T14:32:16.066Z","comments":true,"path":"2022/06/22/树形DP/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/06/22/%E6%A0%91%E5%BD%A2DP/","excerpt":"","text":"树形DP 例题 没有上司的舞会 使用\\(dp(u, 0/1)\\)表示以\\(u\\)来或不来时\\(u\\)为根结点子树的快乐指数总和. 则: \\[ dp(u, 0) = \\sum \\max_{v \\in u.\\mathrm{son}} \\{dp(v, 0), dp(v, 1)\\}\\\\ dp(u, 1) = dp(v, 0) \\] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstring&gt;const int N = 1e6 + 10;using namespace std;int head[N], to[N], nxt[N], tot, n, r[N], Root = 1, dp[N][2];bool haveFa[N];inline void initGraph() { memset(head, -1, sizeof head); tot = -1;}void addEdge(int u, int v) { nxt[++tot] = head[u], head[u] = tot, to[tot] = v;}void calc(int u) { for(int i = head[u]; ~i; i = nxt[i]) { int v = to[i]; calc(v); dp[u][0] += max(dp[v][0], dp[v][1]); dp[u][1] += dp[v][0]; }}int main() { initGraph(); cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) { cin &gt;&gt; dp[i][1]; } for(int i = 1; i &lt; n; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(v, u); haveFa[u] = true; } while(haveFa[Root]) { Root++; } calc(Root); cout &lt;&lt; max(dp[Root][0], dp[Root][1]) &lt;&lt; endl; return 0;} 战略游戏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;const int N = 1e6 + 10;using namespace std;int head[N], to[N], nxt[N], tot, dp[N][2], n, Root;inline void initGraph() { memset(head, -1, sizeof head); tot = -1;}void addEdge(int u, int v) { nxt[++tot] = head[u], head[u] = tot, to[tot] = v;}void calc(int u) { dp[u][1] = 1, dp[u][0] = 0; for(int i = head[u]; ~i; i = nxt[i]) { int v = to[i]; calc(v); dp[u][0] += dp[v][1]; dp[u][1] += min(dp[v][0], dp[v][1]); }}int main() { initGraph(); cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) { int u, k; cin &gt;&gt; u &gt;&gt; k; for(int j = 1; j &lt;= k; ++j) { int v; cin &gt;&gt; v; addEdge(u, v); } } calc(0); cout &lt;&lt; min(dp[0][0], dp[0][1]) &lt;&lt; endl; return 0;} DP求树的直径 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;const int N = 1e6 + 10, INF = 0x3f3f3f3f;using namespace std;int n;int head[N], to[N], nxt[N], tot, Root, d1[N], d2[N];bool vis[N];inline void initGraph() { memset(head, -1, sizeof head); tot = -1;}void addEdge(int u, int v) { nxt[++tot] = head[u], head[u] = tot, to[tot] = v;}int getDiam(int u) { int ret = -INF; d1[u] = d2[u] = 0; for(int i = head[u]; ~i; i = nxt[i]) { int v = to[i]; getDiam(v); int t = d1[v] + 1; if(t &gt; d1[u]) { d2[u] = d1[u], d1[u] = t; } else if(t &gt; d2[u]) { d2[u] = t; } } ret = max(ret, d1[u] + d2[u]); return ret;}int main() { initGraph(); cin &gt;&gt; n; for(int i = 0; i &lt; n - 1; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, v); } int ans = getDiam(1); cout &lt;&lt; ans &lt;&lt; endl; return 0;} 消防局的设立","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ret2libc-pwned.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"图论","slug":"图论","permalink":"https://ret2libc-pwned.github.io/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"最短路算法","slug":"最短路算法","date":"2022-06-04T13:23:47.000Z","updated":"2022-06-04T14:25:15.923Z","comments":true,"path":"2022/06/04/最短路算法/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/06/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/","excerpt":"","text":"简介 模板代码 这样\"三合一\"过不了. 需要哪个直接用哪个即可. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120// 最短路模板三合一// TODO: SPFA#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;ctime&gt;#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;enum Algo { DIJKSTRA = 0, FLOYD = 1, BELLMAN_FORD = 2 };const int N = 1e6 + 10, INF = 0x3f3f3f3f;using namespace std;int h[N], e[N], to[N], ne[N], tot = -1;int n, m, s;inline void add(int u, int v, int w) { ne[++tot] = h[u], h[u] = tot, e[tot] = w, to[tot] = v;}namespace Dijkstra { int dis[N], head, tail; bool vis[N]; struct Node { int u, dis; inline bool operator &gt;(const Node&amp; b) const { return dis &gt; b.dis; } }; priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt; &gt; q; void work(int n, int s) { memset(dis, INF, sizeof dis); dis[s] = 0; q.push({s, n}); while(!q.empty()) { int u = q.top().u; q.pop(); if(vis[u]) continue; vis[u] = true; for(int i = h[u]; ~i; i = ne[i]) { int v = to[i], w = e[i]; if(dis[v] &gt; dis[u] + w) { dis[v] = dis[u] + w; q.push({v, dis[v]}); } } } }} // namespace Dijkstranamespace Floyd { int dis[1001][1001], n, m; void pre(int _n, int _m) { n = _n, m = _m; memset(dis, INF, sizeof dis); for(int i = 1; i &lt;= n; ++i) dis[i][i] = 0; } void read() { for(int i = 1; i &lt;= m; ++i) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; dis[u][v] = min(dis[u][v], w); } } void work() { for(int k = 1; k &lt;= n; ++k) { for(int i = 1; i &lt;= n; ++i) { for(int j = 1; j &lt;= n; ++j) { dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]); } } } }} // namespace Floydnamespace Bellman_Ford { int dis[N]; bool work(int n, int s) { // 判定s为源点路径是否有负环 memset(dis, INF, sizeof dis); dis[s] = 0; bool fl; for(int i = 1; i &lt;= n; ++i) { fl = false; for(int u = 1; u &lt;= n; ++u) { if(dis[u] == INF) continue; for(int j = h[u]; ~j; j = ne[j]) { int v = to[j], w = e[j]; if(dis[v] &gt; dis[u] + w) { dis[v] = dis[u] + w; fl = true; } } } if(!fl) break; } return fl; }} // namespace Bellman_Fordint main() { srand((unsigned)time(0)); memset(h, -1, sizeof h); cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; enum Algo magic = (enum Algo)(rand() % 3); // printf(\"Magic = %d\\n\", magic); if(magic == FLOYD) { Floyd::pre(n, m); Floyd::read(); Floyd::work(); for(int i = 1; i &lt;= n; ++i) cout &lt;&lt; Floyd::dis[s][i] &lt;&lt; \" \"; puts(\"\"); } else { for(int i = 1; i &lt;= m; ++i) { int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; add(u, v, w); } switch(magic) { case DIJKSTRA: Dijkstra::work(n, s); for(int i = 1; i &lt;= n; ++i) { cout &lt;&lt; Dijkstra::dis[i] &lt;&lt; \" \"; } puts(\"\"); break; case BELLMAN_FORD: bool neg_ring = Bellman_Ford::work(n, s); for(int i = 1; i &lt;= n; ++i) { cout &lt;&lt; Bellman_Ford::dis[i] &lt;&lt; \" \"; } puts(\"\"); break; } } return 0;}","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://ret2libc-pwned.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://ret2libc-pwned.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"DP斜率优化","slug":"DP斜率优化","date":"2022-05-28T14:12:50.000Z","updated":"2022-05-28T14:14:36.193Z","comments":true,"path":"2022/05/28/DP斜率优化/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/05/28/DP%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/","excerpt":"","text":"简介 刷完题再写 例题 [HNOI2008]玩具装箱 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;const int N = 1e6 + 10;#define int long longusing namespace std;int f[N], q[N], head = 1, tail = 1;int n, L, sc[N];inline int pow2(int a) { return a * a; }inline int S(int i) { return sc[i] + i; }inline int Y(int j) { return f[j] + pow2(S(j)); }inline int X(int j) { return S(j); }#define L_ (L + 1)signed main() { cin &gt;&gt; n &gt;&gt; L; for(int i = 1; i &lt;= n; ++i) { int cc; cin &gt;&gt; cc; sc[i] = sc[i - 1] + cc; } for(int i = 1; i &lt;= n; ++i) { int k = 2 * (S(i) - L_); while(head &lt; tail &amp;&amp; (Y(q[head + 1]) - Y(q[head])) &lt;= k * (X(q[head + 1]) - X(q[head]))) ++head; f[i] = f[q[head]] + pow2(S(i) - S(q[head]) - L_); while(head &lt; tail &amp;&amp; (Y(i) - Y(q[tail])) * (X(q[tail]) - X(q[tail - 1])) &lt;= \\ (Y(q[tail]) - Y(q[tail - 1])) * (X(i) - X(q[tail]))) --tail; q[++tail] = i; } cout &lt;&lt; f[n] &lt;&lt; endl; return 0;}","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ret2libc-pwned.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"单调队列优化DP","slug":"单调队列优化DP","date":"2022-05-01T12:31:36.000Z","updated":"2022-06-22T14:31:40.585Z","comments":true,"path":"2022/05/01/单调队列优化DP/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/05/01/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP/","excerpt":"","text":"简介 不会. 例题 Fance 有\\(n\\)块木板从左到右排成一行，有\\(m\\)个工匠对这些木板进行粉刷，每块木板至多被粉刷一次。 第\\(i\\)个木匠要么不粉刷，要么粉刷包含木板\\(S_i\\)的，长度不超过\\(L_i\\)的连续的一段木板，每粉刷一块可以得到\\(P_i\\)的报酬。 不同工匠的\\(S_i\\)不同。 请问如何安排能使工匠们获得的总报酬最多。 先按照\\(S\\)排序, 去除后效性. DP, 设\\(F_{i, j}\\)为前\\(i\\)人刷前\\(j\\)块板获得的最大报酬. 则有: 第\\(i\\)人不干了; 第\\(j\\)块板空着不刷; 第\\(i\\)人刷了\\([k + 1, j]\\)的连续一段. \\[ \\begin{array}{c} F_{i, j} = F_{i - 1, j}\\\\ F_{i, j} = F_{i, j - 1}\\\\ F_{i, j} = \\max_{k\\in [j - L_i, S_i)} \\{F_{i - 1, j} + P_i \\cdot (j - k)\\} \\end{array} \\] 注意观察三式, 如果枚举\\(i, j, k\\)肯定超时. 该怎么优化呢? 观察等号左侧, 这是一个关于\\(i, j\\)的式子, 所以肯定要嵌套循环枚举它们. 此时可以通过防止不优的\\(k\\)做dp来优化. 先看看式子, 尝试先把不含\\(k\\)项提出来(下式加号左边): \\[ F_{i, j} = P_i \\cdot j + \\max _{k \\in [j - L_i, S_i)} \\{F_{i - 1, k} - P_i \\cdot k\\} \\] 注意观察加号右边: 当\\(j\\)从小到大地枚举时, 下界增大, 上界不变. 设\\(k_1 \\lt k_2 \\le S_i\\). 不难发现随着\\(j\\)增加, \\(k_1\\)先离开这个区间. 此时如果\\(k_1\\)带来的价值不比\\(k_2\\)多(\\(\\le\\)), 最后的答案就必然不是最优! 此时可以果断踢掉\\(k_1\\). 可以使用单调队列优化\\(k\\), 具体操作为: for循环枚举\\(k\\): 踢掉小于下界的队头; 此时队头为最优, 可以拿来做DP; 将当前枚举的\\(k\\)与队尾作比较, 如果队尾获得的价值不大于\\(k\\)获得的价值, 就踢队尾, \\(k\\)入队. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;const int N = 1e6 + 10;using namespace std;struct Person { int l, p, s; bool operator &lt;(const Person &amp;p2) { return s &lt; p2.s; }};Person a[N];int n, m;int q[N], f[200][20000];int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; ++i) { int l, p, s; cin &gt;&gt; l &gt;&gt; p &gt;&gt; s; a[i] = (Person){l, p, s}; } sort(a + 1, a + 1 + m); for(int i = 1; i &lt;= m; ++i) { #define money(_i, _k) (f[(_i) - 1][(_k)] - a[(_i)].p * (_k)) int head = 0, tail = 0; for(int k = max(0, a[i].s - a[i].l); k &lt; a[i].s; ++k) { while(head &lt;= tail &amp;&amp; money(i, q[tail]) &lt;= money(i, k)) --tail; q[++tail] = k; } for(int j = 1; j &lt;= n; ++j) { //1, 2 f[i][j] = max(f[i - 1][j], f[i][j - 1]); //3 if(j &lt; a[i].s) continue; while(head &lt;= tail &amp;&amp; q[head] &lt; j - a[i].l) ++head; if(head &lt;= tail) f[i][j] = max(f[i][j], j * a[i].p + money(i, q[head])); } } cout &lt;&lt; f[m][n] &lt;&lt; endl; return 0;} CF372C Watching Fireworks is Fun 一个城镇有\\(n\\)个区域,从左到右从1编号为\\(n\\),每个区域之间距离1个单位距离。 节日中有\\(m\\)个烟火要放，给定放的地点\\(a_i\\),时间\\(t_i\\),如果你当时在区域\\(x\\),那么你可以获得\\(b_i - \\vert a_i - x\\vert\\)的开心值。 你每个单位时间可以移动不超过\\(d\\)个单位距离。 你的初始位置是任意的(初始时刻为1),求你通过移动能获取到的最大的开心值。 \\(1 \\le n \\le 150000, 1 \\le m \\le 300, 1 \\le d \\le n\\). 单调队列优化dp, 滚动数组优化空间. 设\\(F_{i, j}\\)为在第\\(i\\)个单位时间, 位于\\(j\\)的最大开心值; 设\\(\\Delta s = (t_i - t_{i - 1}) \\cdot d\\), 则有 则有: \\[ \\begin{array}{d} F_{i, j} = \\max _{j - \\Delta s \\le k\\le j + \\Delta s}\\{F_{i - 1, k} + b_i - |a_i - j|\\}\\\\ \\Rightarrow F_{i, j} =b_i - |a_i - j| + \\max _{j - \\Delta s \\le k\\le j + \\Delta s}\\{F_{i - 1, k}\\} \\end{array} \\] 观察数据范围, 开不下这么大的数组; 观察右式, 发现\\(F_{i, j}\\)只跟\\(F_{i - 1, j}\\)有关. 考虑使用滚动数组优化掉第一维. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cstring&gt;const int N = 1.5e6 + 10, M = 310, INF = 0x3f3f3f3f;using namespace std;typedef long long LL;struct P { LL a, b, t;};P a[M];LL f[2][N], q[N];int n, m, d;inline LL delta_s(int i) { return d * (a[i].t - a[i - 1].t); }int main() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m &gt;&gt; d; for(int i = 1; i &lt;= m; ++i) { int aa, bb, tt; cin &gt;&gt; aa &gt;&gt; bb &gt;&gt; tt; a[i] = (P){aa, bb, tt}; } //dp bool flag = 1; for(int i = 1; i &lt;= m; ++i) { int head = 1, tail = 0, k = 1; //TODO: k在for循环里定义第7个点会TLE??? for(int j = 1; j &lt;= n; ++j) { for(; k &lt;= min(1ll * n, j + delta_s(i)); ++k) { while(head &lt;= tail &amp;&amp; f[flag ^ 1][q[tail]] &lt;= f[flag ^ 1][k]) --tail; q[++tail] = k; } while(head &lt;= tail &amp;&amp; q[head] &lt; max(1ll, j - delta_s(i))) ++head; f[flag][j] = f[flag ^ 1][q[head]] - abs(a[i].a - j) + a[i].b; } flag ^= 1; } LL ans = -INF; for(int j = 1; j &lt;= n; ++j) { ans = max(ans, f[flag ^ 1][j]); } cout &lt;&lt; ans &lt;&lt; endl; return 0;} PTA-Little Bird 有\\(n\\)棵树，第\\(i\\)棵树的高度是\\(d_i\\)。 要去第\\(n\\)棵树。 第\\(i\\)棵树可以跳到第\\(i+1,i+2,\\cdots,i+k\\)棵树。 如果跳到一棵不矮于当前树的树，那么劳累值会\\(+1\\)；否则不会。 求到达第\\(n\\)棵树的最小劳累值。","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"https://ret2libc-pwned.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DP优化","slug":"DP优化","permalink":"https://ret2libc-pwned.github.io/tags/DP%E4%BC%98%E5%8C%96/"}]},{"title":"单调队列","slug":"单调队列","date":"2022-04-30T11:11:11.000Z","updated":"2022-05-28T14:16:01.303Z","comments":true,"path":"2022/04/30/单调队列/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/04/30/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","excerpt":"","text":"定义 维护一种序列, 可以从头和尾增加或删除元素(即双端队列), 且元素具有单调性. 实现 本质是维护具有单调性的最优决策集合, 该如何维护最优与单调的性质呢? 维护序列 该操作的本质是对原序列\\(A\\)扫描, 将当前的元素\\(A_i\\)与单调队列队尾比较, 如果\\(A_i\\)更优则将队尾换成\\(A_i\\). 123456789//pseudo codeQueue q, Array a[];int head = 0, tail = 0;for each a[i] in a { while(队列过大) ++head; //pop front //此时q[head]为当前最优 while(head &lt;= tail &amp;&amp; q[tail]没有a[i]优) --tail; //pop back q[++tail] = 当前值;} 实现双端队列 std::deque 可以使用deque对序列进行操作. 123456789101112131415161718192021using namespace std;deque&lt;int&gt; q;//入队q.push_front(x);q.push_back(x);//出队q.pop_front();q.pop_back();//取头尾q.front();q.back();//遍历for(int x: q) { cout &lt;&lt; x &lt;&lt; \" \";}puts(\"\"); 数组模拟 可以使用两个指针\\(head\\), \\(tail\\)模拟. 需要注意的是数组中下标小的元素在队列前面, 同时指针\\(head \\le tail\\). 例题 滑动窗口 给定一个长度为\\(n\\)的序列, 求其每个长度为\\(k\\)的连续子序列中的最大与最小值. 本题只需维护两个单调队列(一个递减, 队头为min; 另一个反之)即可. 需要注意的是要让窗口大小不超过\\(k\\), 这里采用在队列中存储数组下标的方法统计, 即保证\\(head\\)中存储的下标与当前扫描元素的下标之差小于\\(k\\). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1e6 + 100;int q[N], a[N];int n, k;void getMin() { //维护递减序列, 队头即为答案 int head = 0, tail = 0; for(int i = 1; i &lt; k; ++i) { //Step 1: [1, k), push while(head &lt;= tail &amp;&amp; a[q[tail]] &gt;= a[i]) --tail; q[++tail] = i; } for(int i = k; i &lt;= n; ++i) { //Step 2: [k, n] //这个区间窗口可能超过k, 需要特判维护窗口大小 while(head &lt;= tail &amp;&amp; a[q[tail]] &gt;= a[i]) --tail; q[++tail] = i; while(q[head] &lt;= i - k) ++head; cout &lt;&lt; a[q[head]] &lt;&lt; ' '; }}void getMax() { memset(q, 0, sizeof q); int head = 0, tail = 0; for(int i = 1; i &lt; k; ++i) { while(head &lt;= tail &amp;&amp; a[q[tail]] &lt;= a[i]) --tail; q[++tail] = i; } for(int i = k; i &lt;= n; ++i) { while(head &lt;= tail &amp;&amp; a[q[tail]] &lt;= a[i]) --tail; q[++tail] = i; if(q[head] &lt;= i - k) ++head; cout &lt;&lt; a[q[head]] &lt;&lt; ' '; }}int main() { cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; ++i) { cin &gt;&gt; a[i]; } getMin(); puts(\"\"); getMax(); puts(\"\"); return 0;} 最大子序和 给定一个长度为\\(n\\)的序列, 求出一段长度不超过\\(m\\)的连续子序列, 输出子序和. 不难想到前缀和操作, 在前缀和数组\\(S\\)中, 对于右端点\\(r\\), 需要找到左端点\\(l\\)满足如下条件: \\[ \\begin {cases} l \\in [1, r - 1]&amp;&amp;&amp;(1)\\\\ \\min(S_l)&amp;&amp;&amp;(2)\\\\ r - m \\le l&amp;&amp;&amp;(3) \\end {cases} \\] 其中, 3式的意思是让子序列的大小不超过\\(m\\). 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;const int N = 1e6;using namespace std;int m, n;int a[N], s[N];int q[N];int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i) { cin &gt;&gt; a[i]; s[i] = s[i - 1] + a[i]; } int head = 0, tail = 0, ans = -0x3f; for(int i = 1; i &lt;= n; ++i) { while(head &lt;= tail &amp;&amp; i - m &gt; q[head]) ++head; ans = max(ans, s[i] - s[q[head]]); while(head &lt;= tail &amp;&amp; s[q[tail]] &gt;= s[i]) --tail; q[++tail] = i; } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"字典树","slug":"trie","date":"2022-04-18T13:21:23.987Z","updated":"2022-05-03T11:12:28.474Z","comments":true,"path":"2022/04/18/trie/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/04/18/trie/","excerpt":"","text":"字典树 定义 应用 像查字典一样\"检索\"字符串 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;string&gt;const int N = 1e6;using namespace std;struct Trie { int nxt[N][26], tot = 0; bool ed[N]; void insert(string s) { int p = 0; for(char ch: s) { int key = ch - 'a'; if(nxt[p][key] == 0) { nxt[p][key] = ++tot; } p = nxt[p][key]; } ed[p] = true; } bool isExist(string s) { int p = 0; for(char ch: s) { int key = ch - 'a'; if(nxt[p][key] == 0) { return false; } p = nxt[p][key]; } return ed[p]; }};Trie tr; //Allocateint main() { int cas; cin &gt;&gt; cas; while(cas--) { string s; cin &gt;&gt; s; tr.insert(s); } puts(\"Inserted!!!!!!\\n\\nAsk Me!!!!!!!\"); cin &gt;&gt; cas; while(cas--) { string s; cin &gt;&gt; s; puts(tr.isExist(s) ? \"Exist.\" : \"Not Exist.\"); } return 0;} 异或极值问题","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Splay","slug":"Splay","date":"2022-03-12T13:39:05.000Z","updated":"2022-06-25T11:31:58.921Z","comments":true,"path":"2022/03/12/Splay/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/03/12/Splay/","excerpt":"","text":"Splay 定义 Splay是一种平衡树, 将访问过的结点不断旋转到根结点, 在满足BST性质的同时保证其\"平衡\", 基于时间、空间局部性原理优化查找性能(这样操作使得高频访问的结点在经常根结点附近). 本文的BST每一个结点只维护单个值(而非键值对), 下面说法中v、val、key都指这个值, BST性质的维护它们的大小关系做依据. BST性质 左子树任意结点的key\\(\\lt\\)根结点key\\(\\lt\\)右子树任意结点key, 即中序遍历单调递增. 常见的BST有Treap、Splay、AVL等. 结点结构 开结构体数组记录两个子结点及父结点的数组下标, 类似于一个链表(实际上很多树状数据结构都是数组模拟链表). 结点同时存储维护的信息. 12345678910111213141516const int SIZE = 1e5;struct Node { //两个子结点及父结点数组下标, val int s[2], p, v; //延迟标记及子树大小 int dat, size; //初始化当前结点 void init(int _v, int _p) { v = _v, p = _p; size = 1; }};//AllocateNode tr[SIZE]; 其中规定s[0]为左子结点, s[1]为右子结点, 即: (后续代码均未使用如下define, 只是为了方便理解) 1234#define ls s[0]#define rs s[1]#define son s[k]#define son_bro s[k ^ 1] //son's brother 单旋操作(rotate) 旋转需要保证BST性质; 根结点变量, 即root需要更新; 结点维护的信息(如延迟标记)需要更新. 旋转改变了是树的形态, 本质是改变父子关系. Splay单旋 右旋, 即\\(\\operatorname{Zig}(x)\\)操作 顾名思义就是将\\(x\\)的左子树绕着\\(x\\)的父结点\\(y\\)向右旋转. 需要注意的是\\(x \\lt x_r \\lt y\\), 故\\(x_r\\)应该转到\\(y_r\\)左子树的位置. 这样的操作通过改变\\(y\\)与\\(x_r\\)、\\(\\operatorname{fa}(y)\\)与\\(x\\)、\\(x\\)与\\(y\\)的父子关系达到. 左旋, 即\\(\\operatorname{Zag}(x)\\)操作 同理, \\(x\\)的右子树绕着\\(y\\)向左旋转, \\(x_l\\)接在\\(y\\)右子树位置. 即需要改变\\(y\\)与\\(x_l\\)、\\(\\operatorname{fa}(y)\\)与\\(x\\)、\\(x\\)与\\(y\\)的父子关系. 旋转结点, 即\\(\\operatorname{rotate}(x)\\)操作 上述操作可以使用一个操作\\(\\operatorname{rotate}(x)\\)来完成, 即实现\"自动判定左右\"的单旋操作. \\(x\\)是\\(y\\)的左子树就右旋, 右子树反之. 该操作的精髓就是判定\\(x\\)是\\(y\\)的左结点还是右结点. 前面说过, \"旋转\"的本质是\"改变父子关系\". 每个结点维护了她的左右子树和父结点, 所以该过程需要\"互认\"父子关系, 即需要修改两个结点的信息; 同时因为树的形态被改变, 需要重新统计延迟标记维持的信息(如子树大小). 12345678void Rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = (tr[y].s[1] == x); tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; //tr[x].s[k]的含义是取处于yx直线上的x的儿子, k ^ 1是取她的兄弟 Pushup(y), Pushup(x);} 说人话就是: \\(k\\)的获取: 123456inline int k(int x, int y) { /* *@description 返回x是y的哪个儿子, 左0右1. */ return (tr[y].s[1] == x);} rotate伪代码: 123456/* y是x的爸爸, z是x的爷爷; *//* 以下每一步都需要修改两个结点的值, 即互认关系 */用z取到y, 将x转到y的位置上, 并与z互认; /* 以下两部均需操作结点与其父结点\"互认\"过程, 不再赘述 */x(此时在y的位置上)的兄弟转到原先x(即tr[y].s[k])的位置上;让y转到原先x的兄弟的位置;分别更新y, x子树维护的信息; 双旋操作(splay) 通过一或两次rotate, 可以调整BST的形态, 使其更平衡. 通过过程\\(\\operatorname{splay}(x, goal)\\)将结点\\(x\\)转到\\(goal\\)的子结点. 规定\\(y\\)是\\(x\\)父结点, \\(z\\)是\\(y\\)父结点, splay分六种(3 * 2)情况讨论. 当\\(\\operatorname{fa}(x) = \\operatorname{Root}\\)时, 旋转一次\\(x\\)(右或左), 即Zig或Zag; 当\\(\\operatorname{fa}(x) \\ne \\operatorname{Root}\\)且\\(z, y, x\\)在一条直线上, 旋转一次\\(y\\), 再同方向旋转一次\\(x\\), 即Zig-Zig或Zag-Zag; 当\\(\\operatorname{fa}(x) \\ne \\operatorname{Root}\\)且\\(z, y, x\\)形状是在一条直线的中间折了一下, 分别对\\(x\\)执行两次不同方向的旋转, 即Zig-Zag或Zag-Zig. 画图理解即可. 使用rotate就是: 折线2x 直线yx 需要注意的是该操作是将\\(x\\)转到\\(goal\\)下面, 故当\\(x\\)与\\(goal\\)为具有父子关系的两个结点时 (即第1、2种情况)不需要操作(即不需要交换它们). 123456789101112void Splay(int x, int goal) { //把x转到goal下面 while(tr[x].p != goal) { int y = tr[x].p, z = tr[y].p; if(z != goal) { if((tr[z].s[1] == y) ^ (tr[y].s[1] == x)) Rotate(x); //折线先转x再转x else Rotate(y); //直线先转y } Rotate(x); //统一转x } if(goal == 0) Root = x; //更新根结点(0为根结点下标)} 插入操作(insert) 过程\\(\\operatorname{insert}(val)\\)将\\(val\\)插入BST的相应位置\\(x\\), 将插入的数转到根结点, 即执行\\(\\operatorname{splay}(x, 0)\\). 插入时需要维护BST性质, 将插入的这个数与当前节点比较, \"小插左, 大插右\". 12345678910111213void Insert(int v) { /* * @param v 要插入值的val. */ int u = Root, p = 0; //从根结点开始, u为当前节点数组下标, p为她的爸爸下标 while(u) { p = u, u = tr[u].s[v &gt; tr[u].v]; //小左大右地插下去, 方括号里的是判定左右 } u = ++idx; //结点又多了一个, idx += 1; if(p) tr[p].s[v &gt; tr[p].v] = u; //将p的儿子u插入适当位置 tr[u].init(v, p); //给这个点初始化爸爸下标和自身value, 并将大小设为1 splay(u, 0); //转到根结点} 查询指定数的排名(getRank) 不会😄. 查询第\\(k\\)小的数(getValByRank) \\(\\operatorname{getValByRank}(rank)\\)操作分三种情况讨论: \\[ 结点位于:\\, \\begin{cases} 1. 所求结点位于左子树, 左子树结点个数\\ge rank;\\\\ 2. 所求结点为中序遍历第k个数(即左子树的父结点), 左子树结点个数 = rank - 1;\\\\ 3. 所求结点位于右子树(rank需要减去左子树大小加一的和), 左子树结点个数 \\lt rank - 1 \\end{cases} \\] 12345678910int getValByRank(int rk) { int u = Root; while(true) { Pushdown(u); if(tr[tr[u].s[0]] &gt;= rk) u = tr[u].s[0]; else if(tr[tr[u].s[0]] + 1 == rk) return u; else rk -= (tr[tr[u].s[0]] + 1), u = tr[u].s[1]; } return -1;} 删除操作(delete) 操作\\(\\operatorname{delete}(x)\\)从Splay中删除value为\\(x\\)的结点. 该操作首先将\\(x\\)转到根结点, 再合并\\(x\\)的左右子树. 查询前驱/后继(getPrefix/getSuffix) \\(x\\)的前驱: 小于\\(x\\)的最大数; \\(x\\)的后继: 大于\\(x\\)的最小数. \\(\\operatorname{getPrefix}(x)\\)操作查询\\(x\\)的前驱, 可以通过插入\\(x\\)(插入后位于根结点), 此时\\(x\\)左子树中最右边的结点即为所求, 最后删除结点\\(x\\); \\(\\operatorname{getSuffix}(x)\\)操作反之. 例题 文艺平衡树(Luogu P3391) 翻转一个区间，例如原有序序列是\\(\\{5, 4, 3, 2, 1\\}\\)，翻转区间是\\([2, 4]\\)的话，结果是\\(\\{5, 2, 3, 4, 1\\}\\). 在结点上维护延迟标记\\(flag\\)来判定翻转状态, 避免多次翻转造成性能上的浪费. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;const int N = 1e5;using namespace std;struct Node { int s[2], p, v, siz; int flag; //flag == 1则需要翻转 void init(int _v, int _p) { v = _v, p = _p; siz = 1; }};Node tr[N];int idx, Root;int cas, n;void Pushup(int x) { tr[x].siz = tr[tr[x].s[0]].siz + tr[tr[x].s[1]].siz + 1;}void Pushdown(int x) { if(tr[x].flag) { swap(tr[x].s[0], tr[x].s[1]); tr[tr[x].s[0]].flag ^= 1; tr[tr[x].s[1]].flag ^= 1; tr[x].flag = 0; }}void Rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = (tr[y].s[1] == x); tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; Pushup(y), Pushup(x);}void Splay(int x, int goal) { while(tr[x].p != goal) { int y = tr[x].p, z = tr[y].p; if(z != goal) { if((tr[z].s[1] == y) ^ (tr[y].s[1] == x)) Rotate(x); else Rotate(y); } Rotate(x); } if(goal == 0) Root = x;}void Insert(int v) { int u = Root, p = 0; while(u) { p = u, u = tr[u].s[v &gt; tr[u].v]; } u = ++idx; if(p) { tr[p].s[v &gt; tr[p].v] = u; } tr[u].init(v, p); Splay(u, 0);}int getValByRank(int rk) { int u = Root; while(true) { Pushdown(u); if(tr[tr[u].s[0]].siz &gt;= rk) u = tr[u].s[0]; else if(tr[tr[u].s[0]].siz == rk - 1) return u; else rk -= (tr[tr[u].s[0]].siz + 1), u = tr[u].s[1]; } return -1;}void Output(int u) { //这一步是翻转 Pushdown(u); //从u开始中序遍历 //左 if(tr[u].s[0]) Output(tr[u].s[0]); //判定哨兵, 输出当前结点 if(tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) cout &lt;&lt; tr[u].v &lt;&lt; ' '; //右 if(tr[u].s[1]) Output(tr[u].s[1]);}int main() { cin &gt;&gt; n &gt;&gt; cas; for(int i = 0; i &lt;= n + 1; ++i) { //插入哨兵防止越界 Insert(i); } while(cas--) { int l, r; cin &gt;&gt; l &gt;&gt; r; l = getValByRank(l), r = getValByRank(r + 2); Splay(l, 0), Splay(r, l); tr[tr[r].s[0]].flag ^= 1; } Output(Root); return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//对零基础即为友好#include &lt;iostream&gt;const int N = 1e6;using namespace std;struct Node { int v, p, s[2], siz; bool flag; void init(int _v, int _p) { v = _v, p = _p; siz = 0; }};Node tr[N];int n, cas, Root, idx;/* * 一些宏定义, 用法简单明了, 跟一大堆杂乱无章的中括号说再见!!! * ex. node(x).init(v, p) //初始化结点x的属性v, p * siz(left(x)) //获取结点x的左子节点size * siz(node(x).ls) //另一种写法 */#define ls s[0]#define rs s[1]#define isRoot(x) (x == 0)#define BST_getPos(fa, val) tr[fa].s[(val) &gt; tr[(fa)].v] //在fa结点下面根据BST性质插入一个值为val的结点, 判定结点位置(即: 要插在哪里)#define node(x) tr[(x)] //可以理解为x号结点的对象, 方便使用ls, rs#define left(x) tr[(x)].s[0]#define right(x) tr[(x)].s[1]#define val(x) tr[(x)].v#define siz(x) tr[(x)].siz#define flag(x) tr[(x)].flag#define pa(x) tr[(x)].p#define son(fa, x) tr[(fa)].s[(x)] //获取结点fa的儿子, 参数x为左右, 左0右1#define LoR(fa, x) (tr[(fa)].s[1] == (x)) //L or R, x是fa的哪个儿子void Pushup(int x) { siz(x) = siz(left(x)) + siz(right(x)) + 1;}void Pushdown(int x) { if(flag(x)) { swap(left(x), right(x)); flag(left(x)) ^= 1; flag(right(x)) ^= 1; flag(x) = 0; }}void Rotate(int x) { int y = pa(x), z = pa(y); int k = LoR(y, x); son(z, LoR(z, y)) = x, pa(x) = z; son(y, k) = son(x, k ^ 1), pa(son(x, k ^ 1)) = y; son(x, k ^ 1) = y, pa(y) = x; Pushup(y), Pushup(x);}void Splay(int x, int goal) { while(pa(x) != goal) { int y = pa(x), z = pa(y); if(z != goal) { if(LoR(z, y) ^ LoR(y, x)) { Rotate(x); } else { Rotate(y); } } Rotate(x); } if(isRoot(goal)) Root = x;}void Insert(int v) { int u = Root, p = 0; while(u) { p = u, u = BST_getPos(u, v); } u = ++idx; if(!isRoot(p)) { BST_getPos(p, v) = u; } node(u).init(v, p); Splay(u, 0);}int getValByRank(int rk) { int u = Root; while(true) { Pushdown(u); if(siz(left(u)) &gt;= rk) u = left(u); else if(siz(left(u)) == rk - 1) return u; else rk -= siz(left(u)) + 1, u = right(u); } return -1;}void Output(int x) { Pushdown(x); if(left(x)) Output(left(x)); if(val(x) &gt;= 1 &amp;&amp; val(x) &lt;= n) cout &lt;&lt; val(x) &lt;&lt; ' '; if(right(x)) Output(right(x)); }int main() { cin &gt;&gt; n &gt;&gt; cas; for(int i = 0; i &lt;= n + 1; ++i) { Insert(i); } while(cas--) { int l, r; cin &gt;&gt; l &gt;&gt; r; l = getValByRank(l), r = getValByRank(r + 2); Splay(l, 0), Splay(r, l); flag(left(r)) ^= 1; } Output(Root); puts(\"\"); return 0;} 普通平衡树(Luogu P3369) 实现增, 删, 查询排名与反查, 查询前驱与后继功能. Solution1: std::vector 12345678910111213141516171819202122232425262728293031323334353637#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; v;int cas;int main() { cin &gt;&gt; cas; while(cas--) { int op, x; cin &gt;&gt; op &gt;&gt; x; switch(op) { case 1: //insert(x) v.insert(lower_bound(v.begin(), v.end(), x), x); break; case 2: //delete(x) v.erase(lower_bound(v.begin(), v.end(), x)); break; case 3: //getRank(x) cout &lt;&lt; lower_bound(v.begin(), v.end(), x) - v.begin() + 1 &lt;&lt; endl; break; case 4: //getValueByRank(x) cout &lt;&lt; v[x - 1] &lt;&lt; endl; break; case 5: //getPre(x) cout &lt;&lt; *--lower_bound(v.begin(), v.end(), x) &lt;&lt; endl; break; case 6: //getNxt(x) cout &lt;&lt; *lower_bound(v.begin(), v.end(), x + 1) &lt;&lt; endl; break; } } return 0;}","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"https://ret2libc-pwned.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"二分","slug":"二分","date":"2022-02-20T12:53:53.000Z","updated":"2022-07-13T06:41:06.857Z","comments":true,"path":"2022/02/20/二分/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/02/20/%E4%BA%8C%E5%88%86/","excerpt":"","text":"二分 原理及实现 能用二分解决的问题本质上是 求可行域的界 ．在本文中，我们定义：若在一个单调区间 \\([st, ed]\\) 内，问题的最优答案为 \\(ans\\) ，有 \\(\\forall x \\in [st, ans]\\) 满足问题的要求，则称 \\([st, ans]\\) 为该问题的 可行域．即，在 \\((ans, ed]\\) 的答案都不能满足该问题的条件．因为区间的单调性，可行域的一个界往往是最优答案. （这玩意是自己定义方便理解的） 二分算法的本质实际上使用两个指针 \\(l、r\\) 确定查找的区间，通过 \\(mid\\) 来判断区间是否在可行域内以及是否需要进一步缩小，迭代地逐步缩小这个区间．循环结束，某一个指针停留在可行域的某一端点上，表示了最终答案． 二分的一般思路 1. 可行域的确定 明确单调性．即明确该问题是否能用二分解决，这类问题一般需要： 容易判断答案是否可行； 区间离散（即只含有有限个元素）； 区间单调（区间的一侧是可行域，另一侧不满足要求）． 判定可行性．对于一个候选答案，如何判定是否可行？ 获得上下界．可行域的一个界往往是最优答案，我们需要大致描绘这个界的情况（如：答案位于可行域上界还是下界？）． 划分区间．设计算法，让二分结束后（区间不再进一步缩小时），一个指针停在这个界上． 例一：二分查找 给定一个 单调递增的 序列 a[1...n] ，返回指定元素 \\(key\\) 在序列中的位置. 如不存在值为 \\(key\\) 的元素，则返回 \\(key\\) 的后继（第一个大于 \\(key\\) 的元素）的位置． 问题分析 【单调性】 该序列本身单调递增，同时可以得到可行域的界：设 \\(i\\) 为答案（即 \\(a_i\\) 为 \\(key\\) 或 \\(key\\) 的后继），有 \\(a_{i - 1} \\lt a_i\\) ，则 \\(i - 1\\) 不为答案． 【可行域】 集合 \\(\\{i | a_i \\ge key \\and 1 \\le i \\le n\\}\\)．（可能需要取到后继，所以是往大取） 【流程】维护两个指针 \\(l、r\\) ．我们知道答案为可行域的下界，就让搜索结束后 \\(l\\) 为答案． 计算 \\(mid\\) ； 将整个查找区间划分为 \\([l, mid]\\) 和 \\([mid + 1, r]\\)； 当 \\(a_{mid} \\ge key\\) 时，\\(mid\\) 在可行域内，移动 \\(r\\) 到 \\(mid\\) ，缩小搜索区间；否则，\\(a_{mid} \\le key\\) ，移动 \\(l\\) 到 \\(mid + 1\\)，使搜索区间逼近可行域； 当 \\(l = r\\) 时，搜索结束，\\(l\\) 即为答案． 代码实现 1234567int binary_search(int a[], int key, int l, int r) { while(l &lt; r) { int mid = l + (r - l &gt;&gt; 1); if(a[mid] &gt;= key) r = mid; else l = mid + 1; } return l;} 注 二分的一般流程如下： 1234567891011121314bool check(int x) { // 该函数作用为返回 mid 是否处于可行域内 return 当 x 作为问题答案时是否可行;}int l = 左端点, r = 右端点;while(搜索未结束) { int mid = (l + r) / 2; // 注意是否需要 +1 或 -1，否则会造成死循环 if(check(mid)) { （用l、r其中一个端点）进一步缩小区间; } else { （用另一个端点）将区间缩小到可行域内; }}输出(答案所在的端点); 应用 二分答案 我们经常需要在一个 离散的单调区间 （该区间内有有限个元素且满足单调性）内枚举问题的答案，例如猜 \\([1, 1e9]\\) 中的某个整数，每次猜测可以得知猜的数字大了还是小了．这是可以从 \\(1\\) 尝试到 \\(1e9\\)．有的时候不能猜这么多次，该怎么办呢？ 可以使用二分答案, 使用二分优化枚举的过程. P1873 砍树 如果枚举\\([1, 1\\times 10^9]\\)会超时, 使用二分答案. 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using LL = long long;const int N = 1e6;using namespace std;int n;LL a[N], m;bool isValid(LL height) { LL got = 0; for(int i = 0; i &lt; n; ++i) { got += max(a[i] - height, 0ll); } return got &gt;= m;}int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i]; } int l = 1, r = 1e9 + 1; //闭合的区间, 1e9需要加一 while(l + 1 &lt; r) { //l, r不能相邻 int mid = l + (r - l &gt;&gt; 1); if(isValid(mid)) { l = mid; } else { r = mid; } } cout &lt;&lt; l &lt;&lt; endl; return 0;}","categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"基础算法","slug":"基础算法","permalink":"https://ret2libc-pwned.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"}]},{"title":"FREE-Figurines","slug":"FREE-Figurines","date":"2021-12-04T14:18:52.000Z","updated":"2022-05-03T11:12:14.168Z","comments":true,"path":"2021/12/04/FREE-Figurines/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/12/04/FREE-Figurines/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;const int N = 1e6;using namespace std;/*两种操作: 接在后面 / 删除最前面.最差情况: \"重组\", 即全部删了再拼起来. 需要2n次操作.优化: 尾巴上的节点不需要操作. 可以统计有多少个这种节点, 减去节点数 * 2即可.*/int src[N], dest[N], len[N], n, ans;bool vis[N];inline void debug() { printf(\"ans = %d\\n\", ans);}int main() { cin &gt;&gt; n; /*预处理, 统计最坏情况ans*/ for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; src[i]; vis[src[i]] = true; if(src[i]) ans++; } for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; dest[i]; vis[dest[i]] = true; if(dest[i]) ans++; } for(int i = 1; i &lt;= n; i++) { if(!vis[i]) { int tmpi = i; while(src[tmpi] * dest[tmpi] &amp;&amp; src[tmpi] == dest[tmpi]) { //不为自由的 &amp;&amp; 相等就是不用断开的链 ans -= 2; tmpi = src[tmpi]; } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"POI","slug":"POI","permalink":"https://ret2libc-pwned.github.io/tags/POI/"}]},{"title":"POI2010 - TESIntelligence Test","slug":"POI2010-TESIntelligence-Test","date":"2021-11-21T13:01:04.000Z","updated":"2022-05-03T11:12:22.116Z","comments":true,"path":"2021/11/21/POI2010-TESIntelligence-Test/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/11/21/POI2010-TESIntelligence-Test/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e6;#define YES puts(\"TAK\")#define NO puts(\"NIE\");int len, tc;vector&lt;int&gt; nxt[N];//思路 开二维vector存一堆指针 nxt[x][y]就是数字x出现的第y次的位置.//vector动态开内存 不会爆空间.//二分去找\"数字k出现第x次的位置\", 实现\"快速跳转\".int bsearch(int num, int expected_pos) { int l = 0, r = nxt[num].size() - 1, res = len + 1; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(nxt[num][mid] &gt; expected_pos) { r = mid - 1; res = mid; } else l = mid + 1; } //return nxt[num][res]; return (res == len + 1 ? res : nxt[num][res]);}int main() { ios_base::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; len; for(int i = 1; i &lt;= len; i++) { int tmp; cin &gt;&gt; tmp; nxt[tmp].push_back(i); } cin &gt;&gt; tc; while(tc--) { int l, a[N]; cin &gt;&gt; l; bool flag = true; int pos = 0; for(int i = 1; i &lt;= l; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= l; i++) { pos = bsearch(a[i], pos); //fprintf(stderr, \"a[%d] = %d,\\tpos = %d\\n\", i, a[i], pos); if(pos &gt; len) { flag = 0; break; } } flag ? YES : NO; } return 0;}","categories":[{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"POI","slug":"POI","permalink":"https://ret2libc-pwned.github.io/tags/POI/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-06T06:53:59.209Z","updated":"2022-05-03T11:05:33.248Z","comments":true,"path":"2021/10/06/hello-world/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/06/hello-world/","excerpt":"","text":"如题, 这是我的第一篇文章.","categories":[{"name":"随记","slug":"随记","permalink":"https://ret2libc-pwned.github.io/categories/%E9%9A%8F%E8%AE%B0/"}],"tags":[]}],"categories":[{"name":"OI笔记","slug":"OI笔记","permalink":"https://ret2libc-pwned.github.io/categories/OI%E7%AC%94%E8%AE%B0/"},{"name":"随记","slug":"随记","permalink":"https://ret2libc-pwned.github.io/categories/%E9%9A%8F%E8%AE%B0/"},{"name":"文化课","slug":"文化课","permalink":"https://ret2libc-pwned.github.io/categories/%E6%96%87%E5%8C%96%E8%AF%BE/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"课内数学","slug":"课内数学","permalink":"https://ret2libc-pwned.github.io/tags/%E8%AF%BE%E5%86%85%E6%95%B0%E5%AD%A6/"},{"name":"平面几何","slug":"平面几何","permalink":"https://ret2libc-pwned.github.io/tags/%E5%B9%B3%E9%9D%A2%E5%87%A0%E4%BD%95/"},{"name":"技巧","slug":"技巧","permalink":"https://ret2libc-pwned.github.io/tags/%E6%8A%80%E5%B7%A7/"},{"name":"搜索","slug":"搜索","permalink":"https://ret2libc-pwned.github.io/tags/%E6%90%9C%E7%B4%A2/"},{"name":"动态规划","slug":"动态规划","permalink":"https://ret2libc-pwned.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"图论","slug":"图论","permalink":"https://ret2libc-pwned.github.io/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://ret2libc-pwned.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"DP优化","slug":"DP优化","permalink":"https://ret2libc-pwned.github.io/tags/DP%E4%BC%98%E5%8C%96/"},{"name":"平衡树","slug":"平衡树","permalink":"https://ret2libc-pwned.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"基础算法","slug":"基础算法","permalink":"https://ret2libc-pwned.github.io/tags/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"},{"name":"POI","slug":"POI","permalink":"https://ret2libc-pwned.github.io/tags/POI/"}]}