{"meta":{"title":"Ret2Libc","subtitle":"真正的勇士敢于直面惨淡的人生，敢于正视淋漓的鲜血。 --鲁迅","description":"","author":"ret2libc","url":"https://ret2libc-pwned.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-10-16T12:54:16.000Z","updated":"2021-10-16T13:10:07.521Z","comments":false,"path":"categories/index.html","permalink":"https://ret2libc-pwned.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-10-16T14:14:36.000Z","updated":"2021-10-17T10:44:28.724Z","comments":false,"path":"about/index.html","permalink":"https://ret2libc-pwned.github.io/about/index.html","excerpt":"","text":"自我介绍 你好, 我是Ret2libc, 正在零基础入门算法! 本网站主要是自己的一点笔记和心得, 如果你恰好找到了这里, 我很希望它们能帮助到你! 联系方式 QQ 2184016258, 欢迎和我交朋友, 或者教教我怎么零基础入门算法! 至于洛谷, poj之类的. 因为我太菜了, 没过几题, 不好意思放. 等我ac的多一点再放吧. 为什么叫Ret2libc? 主要是之前我对安全比较感兴趣(安全这方面也很菜), 尤其是pwn. ret2libc是一个栈溢出利用方法. 取这个名字主要是不想让别人找到我(主要是OIer没几个知道这个词......). 这个网站会留多久? 搭这个网站主要是为了在机房能看到自己的笔记, 所以会留比较久. 值得一提的是如果github pages由于各种原因访问不上, 可以去这个网站的香港腾讯云镜像."},{"title":"tags","date":"2021-10-16T13:18:16.000Z","updated":"2021-10-17T03:36:02.847Z","comments":false,"path":"tags/index.html","permalink":"https://ret2libc-pwned.github.io/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-10-16T12:17:58.000Z","updated":"2021-10-16T13:25:50.508Z","comments":true,"path":"conmment/index.html","permalink":"https://ret2libc-pwned.github.io/conmment/index.html","excerpt":"","text":"有什么想说的? 有什么想问的?"}],"posts":[{"title":"Splay","slug":"Splay","date":"2022-03-12T13:39:05.000Z","updated":"2022-03-19T13:01:04.462Z","comments":true,"path":"2022/03/12/Splay/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/03/12/Splay/","excerpt":"","text":"Splay 定义 Splay是一种BST, 将访问过的结点不断旋转到根结点, 在满足BST性质的同时保证其\"平衡\", 基于时间、空间局部性原理优化查找性能(这样操作使得高频访问的结点在经常根结点附近). 本文的BST每一个结点只维护单个值(而非键值对), 下面说法中v、val、key都指这个值, BST性质的维护它们的大小关系做依据. BST性质 左子树任意结点的key\\(\\lt\\)根结点key\\(\\lt\\)右子树任意结点key, 即中序遍历单调递增. 常见的BST有Treap、Splay、AVL等. 结点结构 开结构体数组记录两个子结点及父结点的数组下标, 类似于一个链表(实际上很多树状数据结构都是数组模拟链表). 结点同时存储维护的信息. 12345678910111213141516const int SIZE = 1e5;struct Node { //两个子结点及父结点数组下标, val int s[2], p, v; //延迟标记及子树大小 int dat, size; //初始化当前结点 void init(int _v, int _p) { v = _v, p = _p; size = 1; }};//AllocateNode tr[SIZE]; 其中规定s[0]为左子结点, s[1]为右子结点, 即: (后续代码均未使用如下define, 只是为了方便理解) 1234#define ls s[0]#define rs s[1]#define son s[k]#define son_bro s[k ^ 1] //son's brother 单旋操作(rotate) 旋转需要保证BST性质; 根结点变量, 即root需要更新; 结点维护的信息(如延迟标记)需要更新. 旋转改变了是树的形态, 本质是改变父子关系. Splay单旋 右旋, 即\\(\\operatorname{Zig}(x)\\)操作 顾名思义就是将\\(x\\)的左子树绕着\\(x\\)的父结点\\(y\\)向右旋转. 需要注意的是\\(x \\lt x_r \\lt y\\), 故\\(x_r\\)应该转到\\(y_r\\)左子树的位置. 这样的操作通过改变\\(y\\)与\\(x_r\\)、\\(\\operatorname{fa}(y)\\)与\\(x\\)、\\(x\\)与\\(y\\)的父子关系达到. 左旋, 即\\(\\operatorname{Zag}(x)\\)操作 同理, \\(x\\)的右子树绕着\\(y\\)向左旋转, \\(x_l\\)接在\\(y\\)右子树位置. 即需要改变\\(y\\)与\\(x_l\\)、\\(\\operatorname{fa}(y)\\)与\\(x\\)、\\(x\\)与\\(y\\)的父子关系. 旋转结点, 即\\(\\operatorname{rotate}(x)\\)操作 上述操作可以使用一个操作\\(\\operatorname{rotate}(x)\\)来完成, 即实现\"自动判定左右\"的单旋操作. \\(x\\)是\\(y\\)的左子树就右旋, 右子树反之. 该操作的精髓就是判定\\(x\\)是\\(y\\)的左结点还是右结点. 前面说过, \"旋转\"的本质是\"改变父子关系\". 每个结点维护了她的左右子树和父结点, 所以该过程需要\"互认\"父子关系, 即需要修改两个结点的信息; 同时因为树的形态被改变, 需要重新统计延迟标记维持的信息(如子树大小). 12345678void Rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = (tr[y].s[1] == x); tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; //tr[x].s[k]的含义是取处于yx直线上的x的儿子, k ^ 1是取她的兄弟 Pushup(y), Pushup(x);} 说人话就是: \\(k\\)的获取: 123456inline int k(int x, int y) { /* *@description 返回x是y的哪个儿子, 左0右1. */ return (tr[y].s[1] == x);} rotate伪代码: 123456/* y是x的爸爸, z是x的爷爷; *//* 以下每一步都需要修改两个结点的值, 即互认关系 */用z取到y, 将x转到y的位置上, 并与z互认; /* 以下两部均需操作结点与其父结点\"互认\"过程, 不再赘述 */x(此时在y的位置上)的兄弟转到原先x(即tr[y].s[k])的位置上;让y转到原先x的兄弟的位置;分别更新y, x子树维护的信息; 双旋操作(splay) 通过一或两次rotate, 可以调整BST的形态, 使其更平衡. 通过过程\\(\\operatorname{splay}(x, goal)\\)将结点\\(x\\)转到\\(goal\\)的子结点. 规定\\(y\\)是\\(x\\)父结点, \\(z\\)是\\(y\\)父结点, splay分六种(3 * 2)情况讨论. 当\\(\\operatorname{fa}(x) = \\operatorname{Root}\\)时, 旋转一次\\(x\\)(右或左), 即Zig或Zag; 当\\(\\operatorname{fa}(x) \\ne \\operatorname{Root}\\)且\\(z, y, x\\)在一条直线上, 旋转一次\\(y\\), 再同方向旋转一次\\(x\\), 即Zig-Zig或Zag-Zag; 当\\(\\operatorname{fa}(x) \\ne \\operatorname{Root}\\)且\\(z, y, x\\)形状是在一条直线的中间折了一下, 分别对\\(x\\)执行两次不同方向的旋转, 即Zig-Zag或Zag-Zig. 画图理解即可. 使用rotate就是: 折线2x 直线yx 需要注意的是该操作是将\\(x\\)转到\\(goal\\)下面, 故当\\(x\\)与\\(goal\\)为具有父子关系的两个结点时 (即第1、2种情况)不需要操作(即不需要交换它们). 123456789101112void Splay(int x, int goal) { //把x转到goal下面 while(tr[x].p != goal) { int y = tr[x].p, z = tr[y].p; if(z != goal) { if((tr[z].s[1] == y) ^ (tr[y].s[1] == x)) Rotate(x); //折线先转x再转x else Rotate(y); //直线先转y } Rotate(x); //统一转x } if(goal == 0) Root = x; //更新根结点(0为根结点下标)} 插入操作(insert) 过程\\(\\operatorname{insert}(val)\\)将\\(val\\)插入BST的相应位置\\(x\\), 将插入的数转到根结点, 即执行\\(\\operatorname{splay}(x, 0)\\). 插入时需要维护BST性质, 将插入的这个数与当前节点比较, \"小插左, 大插右\". 12345678910111213void Insert(int v) { /* * @param v 要插入值的val. */ int u = Root, p = 0; //从根结点开始, u为当前节点数组下标, p为她的爸爸下标 while(u) { p = u, u = tr[u].s[v &gt; tr[u].v]; //小左大右地插下去, 方括号里的是判定左右 } u = ++idx; //结点又多了一个, idx += 1; if(p) tr[p].s[v &gt; tr[p].v] = u; //将p的儿子u插入适当位置 tr[u].init(v, p); //给这个点初始化爸爸下标和自身value, 并将大小设为1 splay(u, 0); //转到根结点} 查询指定数的排名(getRank) 不会😄. 查询第\\(k\\)小的数(getValByRank) \\(\\operatorname{getValByRank}(rank)\\)操作分三种情况讨论: \\[ 结点位于:\\, \\begin{cases} 1. 所求结点位于左子树, 左子树结点个数\\ge rank;\\\\ 2. 所求结点为中序遍历第k个数(即左子树的父结点), 左子树结点个数 = rank - 1;\\\\ 3. 所求结点位于右子树(rank需要减去左子树大小加一的和), 左子树结点个数 \\lt rank - 1 \\end{cases} \\] 12345678910int getValByRank(int rk) { int u = Root; while(true) { Pushdown(u); if(tr[tr[u].s[0]] &gt;= rk) u = tr[u].s[0]; else if(tr[tr[u].s[0]] + 1 == rk) return u; else rk -= (tr[tr[u].s[0]] + 1), u = tr[u].s[1]; } return -1;} 删除操作(delete) 操作\\(\\operatorname{delete}(x)\\)从Splay中删除value为\\(x\\)的结点. 该操作首先将\\(x\\)转到根结点, 再合并\\(x\\)的左右子树. 查询前驱/后继(getPrefix/getSuffix) \\(x\\)的前驱: 小于\\(x\\)的最大数; \\(x\\)的后继: 大于\\(x\\)的最小数. \\(\\operatorname{getPrefix}(x)\\)操作查询\\(x\\)的前驱, 可以通过插入\\(x\\)(插入后位于根结点), 此时\\(x\\)左子树中最右边的结点即为所求, 最后删除结点\\(x\\); \\(\\operatorname{getSuffix}(x)\\)操作反之. 例题 文艺平衡树(Luogu P3391) 翻转一个区间，例如原有序序列是\\(\\{5, 4, 3, 2, 1\\}\\)，翻转区间是\\([2, 4]\\)的话，结果是\\(\\{5, 2, 3, 4, 1\\}\\). 在结点上维护延迟标记\\(flag\\)来判定翻转状态, 避免多次翻转造成性能上的浪费. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125//对零基础即为友好#include &lt;iostream&gt;const int N = 1e6;using namespace std;struct Node { int v, p, s[2], siz; bool flag; void init(int _v, int _p) { v = _v, p = _p; siz = 0; }};Node tr[N];int n, cas, Root, idx;/* * 一些宏定义, 用法简单明了, 跟一大堆杂乱无章的中括号说再见!!! * ex. node(x).init(v, p) //初始化结点x的属性v, p * siz(left(x)) //获取结点x的左子节点size * siz(node(x).ls) //另一种写法 */#define ls s[0]#define rs s[1]#define isRoot(x) (x == 0)#define BST_getPos(fa, val) tr[fa].s[(val) &gt; tr[(fa)].v] //在fa结点下面根据BST性质插入一个值为val的结点, 判定结点位置(即: 要插在哪里)#define node(x) tr[(x)] //可以理解为x号结点的对象, 方便使用ls, rs#define left(x) tr[(x)].s[0]#define right(x) tr[(x)].s[1]#define val(x) tr[(x)].v#define siz(x) tr[(x)].siz#define flag(x) tr[(x)].flag#define pa(x) tr[(x)].p#define son(fa, x) tr[(fa)].s[(x)] //获取结点fa的儿子, 参数x为左右, 左0右1#define LoR(fa, x) (tr[(fa)].s[1] == (x)) //L or R, x是fa的哪个儿子void Pushup(int x) { siz(x) = siz(left(x)) + siz(right(x)) + 1;}void Pushdown(int x) { if(flag(x)) { swap(left(x), right(x)); flag(left(x)) ^= 1; flag(right(x)) ^= 1; flag(x) = 0; }}void Rotate(int x) { int y = pa(x), z = pa(y); int k = LoR(y, x); son(z, LoR(z, y)) = x, pa(x) = z; son(y, k) = son(x, k ^ 1), pa(son(x, k ^ 1)) = y; son(x, k ^ 1) = y, pa(y) = x; Pushup(y), Pushup(x);}void Splay(int x, int goal) { while(pa(x) != goal) { int y = pa(x), z = pa(y); if(z != goal) { if(LoR(z, y) ^ LoR(y, x)) { Rotate(x); } else { Rotate(y); } } Rotate(x); } if(isRoot(goal)) Root = x;}void Insert(int v) { int u = Root, p = 0; while(u) { p = u, u = BST_getPos(u, v); } u = ++idx; if(!isRoot(p)) { BST_getPos(p, v) = u; } node(u).init(v, p); Splay(u, 0);}int getValByRank(int rk) { int u = Root; while(true) { Pushdown(u); if(siz(left(u)) &gt;= rk) u = left(u); else if(siz(left(u)) == rk - 1) return u; else rk -= siz(left(u)) + 1, u = right(u); } return -1;}void Output(int x) { Pushdown(x); if(left(x)) Output(left(x)); if(val(x) &gt;= 1 &amp;&amp; val(x) &lt;= n) cout &lt;&lt; val(x) &lt;&lt; ' '; if(right(x)) Output(right(x)); }int main() { cin &gt;&gt; n &gt;&gt; cas; for(int i = 0; i &lt;= n + 1; ++i) { Insert(i); } while(cas--) { int l, r; cin &gt;&gt; l &gt;&gt; r; l = getValByRank(l), r = getValByRank(r + 2); Splay(l, 0), Splay(r, l); flag(left(r)) ^= 1; } Output(Root); puts(\"\"); return 0;}","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","permalink":"https://ret2libc-pwned.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"BST","slug":"BST","permalink":"https://ret2libc-pwned.github.io/tags/BST/"}]},{"title":"二分","slug":"二分","date":"2022-02-20T12:53:53.000Z","updated":"2022-02-20T12:56:05.619Z","comments":true,"path":"2022/02/20/二分/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/02/20/%E4%BA%8C%E5%88%86/","excerpt":"","text":"二分 二分查找 给定一个序列\\(\\{a\\}\\), 查找指定元素\\(x\\)位置. 代码实现 12345678int bsearch(int* a, int x, int l, int r) { while(l &lt; r) { int mid = l + (r - l &gt;&gt; 1); if(a[mid] &gt;= x) r = mid; else l = mid + 1; } return a[l] == x ? l : -1;} 二分答案 单调区间内高效地查找最优答案, 可以看作\"枚举\"的优化. 常用来解决\"最大值最小化\"问题. Luogu P1873 砍树 如果枚举\\([1, 1\\times 10^9]\\)会超时, 使用二分答案. 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;typedef long long LL;const int N = 1e6;using namespace std;int n;LL a[N], m;bool isValid(LL height) { LL got = 0; for(int i = 0; i &lt; n; ++i) { got += max(a[i] - height, 0ll); } return got &gt;= m;}int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i]; } int l = 1, r = 1e9 + 1; //闭合的区间, 1e9需要加一 while(l + 1 &lt; r) { //l, r不能相邻 int mid = l + (r - l &gt;&gt; 1); if(isValid(mid)) { l = mid; } else { r = mid; } } cout &lt;&lt; l &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"算法","slug":"算法","permalink":"https://ret2libc-pwned.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"FREE-Figurines","slug":"FREE-Figurines","date":"2021-12-04T14:18:52.000Z","updated":"2021-12-04T14:20:43.140Z","comments":true,"path":"2021/12/04/FREE-Figurines/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/12/04/FREE-Figurines/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;const int N = 1e6;using namespace std;/*两种操作: 接在后面 / 删除最前面.最差情况: \"重组\", 即全部删了再拼起来. 需要2n次操作.优化: 尾巴上的节点不需要操作. 可以统计有多少个这种节点, 减去节点数 * 2即可.*/int src[N], dest[N], len[N], n, ans;bool vis[N];inline void debug() { printf(\"ans = %d\\n\", ans);}int main() { cin &gt;&gt; n; /*预处理, 统计最坏情况ans*/ for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; src[i]; vis[src[i]] = true; if(src[i]) ans++; } for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; dest[i]; vis[dest[i]] = true; if(dest[i]) ans++; } for(int i = 1; i &lt;= n; i++) { if(!vis[i]) { int tmpi = i; while(src[tmpi] * dest[tmpi] &amp;&amp; src[tmpi] == dest[tmpi]) { //不为自由的 &amp;&amp; 相等就是不用断开的链 ans -= 2; tmpi = src[tmpi]; } } } cout &lt;&lt; ans &lt;&lt; endl; return 0;}","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"POI2010 - TESIntelligence Test","slug":"POI2010-TESIntelligence-Test","date":"2021-11-21T13:01:04.000Z","updated":"2021-11-21T13:02:47.638Z","comments":true,"path":"2021/11/21/POI2010-TESIntelligence-Test/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/11/21/POI2010-TESIntelligence-Test/","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e6;#define YES puts(\"TAK\")#define NO puts(\"NIE\");int len, tc;vector&lt;int&gt; nxt[N];//思路 开二维vector存一堆指针 nxt[x][y]就是数字x出现的第y次的位置.//vector动态开内存 不会爆空间.//二分去找\"数字k出现第x次的位置\", 实现\"快速跳转\".int bsearch(int num, int expected_pos) { int l = 0, r = nxt[num].size() - 1, res = len + 1; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(nxt[num][mid] &gt; expected_pos) { r = mid - 1; res = mid; } else l = mid + 1; } //return nxt[num][res]; return (res == len + 1 ? res : nxt[num][res]);}int main() { ios_base::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; len; for(int i = 1; i &lt;= len; i++) { int tmp; cin &gt;&gt; tmp; nxt[tmp].push_back(i); } cin &gt;&gt; tc; while(tc--) { int l, a[N]; cin &gt;&gt; l; bool flag = true; int pos = 0; for(int i = 1; i &lt;= l; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= l; i++) { pos = bsearch(a[i], pos); //fprintf(stderr, \"a[%d] = %d,\\tpos = %d\\n\", i, a[i], pos); if(pos &gt; len) { flag = 0; break; } } flag ? YES : NO; } return 0;}","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"启发式合并","slug":"启发式合并","date":"2021-11-13T13:10:18.000Z","updated":"2021-11-13T14:49:27.835Z","comments":true,"path":"2021/11/13/启发式合并/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/11/13/%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/","excerpt":"","text":"梦幻布丁(HNOI-2009) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*启发式合并，时间复杂度分析：考虑用贡献法来分析，每次合并后，队列长度一定大于等于原来短的长度的两倍，这样相当于每次合并都会让短的长度扩大一倍以上，最多扩大 logN 次，所以总复杂度O(NlogN)，每次O(logN)。对于这道题目，我们先求出原序列的答案，对于每一种颜色都用类似链表的数据结构串起来，并记录下尾节点。每次修改，都根据启发式合并的方法来暴力合并，然后处理一下此次合并对答案的影响（显然答案是不增的）。但是如果我们把 1 染成 2 并且 hsh[1]&gt;hsh[2]，那么我们应该把 2 接到 1 的后面。这样会有一个问题：本次修改后这个链的颜色是 1（颜色为 2 的链被删除了），如果接下来修改颜色 2（显然这是合法的），会使得找不到颜色 2 而只能找到颜色 1 了。所以我们需要使用一个 f 数组，表示当我们要寻找颜色 x 时，实际上需要寻找颜色为 color[x] 的链。如果遇到上面这种情况就要交换交换 color[x] 和 color[y]*/ #include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=100005,maxm=1000005;int n,m,c[maxn],hsh[maxm],sta[maxm],color[maxm],pos[maxm],nxt[maxn],ans;int read(){ int ret=0,f=1;char ch=getchar(); while (!isdigit(ch)){if (ch=='-')f=-f;ch=getchar();} while (isdigit(ch)) ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0',ch=getchar(); return ret*f;}void merge(int x,int y) { for (int i=pos[x];i;i=nxt[i]) ans-=(c[i-1]==y)+(c[i+1]==y);//合并时需要注意细节 y x y for (int i=pos[x];i;i=nxt[i]) c[i]=y;//把原有的x统统变成y nxt[sta[x]]=pos[y],pos[y]=pos[x],hsh[y]+=hsh[x];//实质就是再不重新建立关系的同时，依旧利用已有的关联关系。换一个解释就是下次处理颜色y时 pos[x]=sta[x]=hsh[x]=0; //先把原有的x处理掉(刚刚改变成的y的x)，然后再来解决原有的y，等价于把x接到y的屁股后面 //最后把x原有的不需要的关联关系干掉 }int main(){ n=read(),m=read(); for (int i=1;i&lt;=n;i++){ c[i]=read(),color[c[i]]=c[i]; ans+=c[i]!=c[i-1]; //统计段数 if (!pos[c[i]]) sta[c[i]]=i; hsh[c[i]]++,nxt[i]=pos[c[i]],pos[c[i]]=i; } while (m--){ int opt=read(); if (opt==2) printf(\"%d\\n\",ans);else{ int x=read(),y=read(); if (x==y) continue; if (hsh[color[x]]&gt;hsh[color[y]]) swap(color[x],color[y]); if (!hsh[color[x]]) continue; merge(color[x],color[y]); } } return 0;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;const int N = 1e6;using namespace std;int nxt[N], pos[N], raw[N], a[N], last[N], color[N], cnt[N];int n, m, ans;//int marge(int, int);//看std看不懂, 总结出一个小技巧//嵌套的数组一个个模拟太难, 可以用一下OOP的思想方便理解//就比如桶排的时候把cnt[a[i]]理解为a[i].cnt就舒服很多//阅读这个代码时需要经常这样思考. 例如color[raw[i]]可以理解为raw[i].color, 把包在中括号里边的东西看成object就好inline int read() { int x = 0, w = 1; //x是数字, w是符号位 char ch = 0; while (ch &lt; '0' || ch &gt; '9') { //!isdigit(ch) if (ch == '-') w = -1; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { //isdigit(ch) x = x * 10 + (ch - '0'); ch = getchar(); } return x * w;}//Example://int n = read();inline int marge(int x, int y) { //把所有x变成y, 小优化见main函数调用的marge地方 //下面这几行, 链表的遍历, 比较难懂. //注意到答案应该是只减不增的, 因为修改的本质是\"合并\", \"段数\"越合并越少. 这也是这题最难想的地方, 不是一个个修改再统计段数, 是用链表存储后再模拟\"合并\"更新答案. //这个加法用得很好, 因为跟前面的一样意味着少了一段 跟后面的不一样意味着有少了一段 for(int i = pos[x]; i; i = nxt[i]) ans -= (raw[i - 1] == y) + (raw[i + 1] == y); //更新答案 //模拟\"合并\"的操作 for(int i = pos[x]; i; i = nxt[i]) raw[i] = y; //修改x ---&gt; y nxt[last[x]] = pos[y]; //更新尾节点, 即每段最后一个 pos[y] = pos[x]; //更新位置 cnt[y] += cnt[x]; //加上个数 pos[x] = last[x] = cnt[x] = 0; //合并完之后x没了}int main() { //ios_base::sync_with_stdio(false); cin.tie(0); //cin &gt;&gt; n &gt;&gt; m; n = read(); m = read(); for(int i = 1; i &lt;= n; i ++) { //cin &gt;&gt; raw[i]; raw[i] = read(); color[raw[i]] = raw[i]; //color[x]统计第x个颜色 ans += (raw[i] != raw[i - 1]); //预处理一下\"段数\", 这个方法很巧妙, 读入的时候只要跟前面的不一样就表示又有一段 cnt[raw[i]] ++; //cnt就是桶, 即计数数组 if(!pos[i]) last[i] = raw[i]; //每种布丁最后一个的位置 nxt[i] = pos[raw[i]]; pos[raw[i]] = i; } while(m --) { int op1, op2, op3; //cin &gt;&gt; op1; op1 = read(); if(op1 == 1) { //cin &gt;&gt; op2 &gt;&gt; op3; op2 = read(); op3 = read(); if(cnt[color[op1]] &gt; cnt[color[op2]]) swap(color[op1], color[op2]); //小优化, 把x变成y和把y变成x, 之后的答案是不受影响的, 所以改操作次数少的. if(op2 == op3 || !cnt[color[op2]]) continue; //std考虑得很周全, 舍去修改没有的元素和\"修改个寂寞\", 防止被卡. marge(op2, op3); } else { cout &lt;&lt; ans &lt;&lt; endl; } } return 0;}","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"算法","slug":"算法","permalink":"https://ret2libc-pwned.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"CSP-J 2021赛后总结","slug":"CSP-J-2021赛后总结","date":"2021-11-13T10:55:53.000Z","updated":"2021-11-13T13:05:59.535Z","comments":true,"path":"2021/11/13/CSP-J-2021赛后总结/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/11/13/CSP-J-2021%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/","excerpt":"","text":"Solution T1 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;#define INF 0x3f3f3f3f#define int long longint l, r, n;inline int brute(int n ,int l, int r) { //bf: 暴力枚举k \\in [l, r], 90 pts int ans = -INF; for(int i = l; i &lt;= r; i ++) { ans = max(ans, i % n); } return ans;}inline int ac(int n, int l, int r) { //先要明白余数是循环出现的 //L mod n = l, R mod n = r //则余数是{l, l + 1, l + 2, ..., l + n - 1, ..., 0, 1, 2, ..., n - 1, ..., r} int ans; if(l / n == r / n) ans = r % n; //[l, r]区间比n小 --&gt; 数越大 余数越大 因为没有到n - 1的 else ans = n - 1; //l / n == r / n --&gt; [l, r]区间比n大 --&gt; 肯定有能取到n - 1的数, 即最大k. return ans;}signed main() { ios_base::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n &gt;&gt; l &gt;&gt; r; //cout &lt;&lt; brute(n, l, r) &lt;&lt; endl; cout &lt;&lt; ac(n, l, r) &lt;&lt; endl; return 0;} T2 T3 T4","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://ret2libc-pwned.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"OI比赛中的那些玄学优化","slug":"OI比赛中的那些玄学优化","date":"2021-10-22T10:07:36.000Z","updated":"2021-10-22T12:19:51.143Z","comments":true,"path":"2021/10/22/OI比赛中的那些玄学优化/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/22/OI%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E7%8E%84%E5%AD%A6%E4%BC%98%E5%8C%96/","excerpt":"","text":"前言 这是我暑假零基础入门C++的时候整理的小技巧. 现在到了CSP-2021赛前, 我在看笔记的时候发现了这个, 就把它发在我的网站上, 希望能帮到即将参加OI的你, 也希望能借此给自己增加Rp. 这也是我第一次OI比赛, 希望能考好点. 读入优化 fread快读/快写代码来自oi-wiki 关闭同步(推荐) 12ios_base::sync_with_stdio(false);cin.tie(0); 关闭iostream与stdio中输入输出流的同步. 使std::cin与std::cout接近于scanf()与printf()的速度. 注意事项 这个小优化是用得最多的, cin和cout慢的要命, 在IO特别多的题中要用cin/cout一定要加. 注意: 加了第一行之后将无法使用printf(), scanf()等stdio.h中的函数, 如果作死用了会导致IO流混乱! 注意2: cin/cout写入文件不是即时的, 所以一定要endl刷新缓冲区(或者\\n之类的) printf()和scanf()(推荐) 同上, 速度嗖嗖的. 但是不能在关闭同步后使用. 还能格式化字符串, 不香吗?(比如让你保留8位小数, 只需printf(\"%.8lf\", my_variable)即可, cout还需借助iomanip) 快读/快写 很好用, getchar()和putchar()快如闪电. 12345678910111213141516int read() { int x = 0, w = 1; //x是数字, w是符号位 char ch = 0; while (ch &lt; '0' || ch &gt; '9') { //!isdigit(ch) if (ch == '-') w = -1; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { //isdigit(ch) x = x * 10 + (ch - '0'); ch = getchar(); } return x * w;}//Example://int n = read(); 123456789101112inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) putchar(sta[--top] + 48); //(int)'0'}//Example://int a = 5;//write(a); fread(较为玄学) 12345678910111213141516171819202122232425262728293031namespace IO {const int MAXSIZE = 1 &lt;&lt; 20;char buf[MAXSIZE], *p1, *p2;#define gc() \\ (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\ ? EOF \\ : *p1++)inline int rd() { int x = 0, f = 1; char c = gc(); while (!isdigit(c)) { if (c == '-') f = -1; c = gc(); } while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc(); return x * f;}char pbuf[1 &lt;&lt; 20], *pp = pbuf;inline void push(const char &amp;c) { if (pp - pbuf == 1 &lt;&lt; 20) fwrite(pbuf, 1, 1 &lt;&lt; 20, stdout), pp = pbuf; *pp++ = c;}inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0');}} // namespace IO 如上是基于fread实现的快读快写, 本质是利用文件的缓冲区. 实现时需要将getchar()稍微改改, (代码中\\表示显示不下, 写的时候从这一行接着写就行, 无需换行) 注意事项 敲这个板子太费时间了, 还是用上面那个基于putchar()和getchar()的那个性价比最高. 好像这个东西很玄学, 一些情况下会使整个程序变慢(?) 执行优化 ++i(较为推荐) 有研究表明++i比i++快, 说是i++用了一个临时变量. 注: 很多人在网上科普两者的关系, 但是只是看反编译代码, 看到++i比i++用的汇编指令少一两个, 就说++i更快(甚至每一句指令的意思都说一下, 即到底慢在哪了)??? 就算真的是这样这种不懂装懂的态度也不是很好 ++i执行完后的值跟i是一样的, 可以拿来给其它变量赋值. 1int k = ++i; register(已经死了) register, 即直接操作寄存器. 在C++14逐渐被弃用. 在之前的C++版本中都可以放在循环里面提升性能. 1for(register int i = 0; i &lt; n; ++i) inline内联函数(推荐) inline可以在调用处就地展开函数. 12345678910111213141516using namespace std;inline int lowbit(int x) { return x &amp; (-x);}int main() { int x = 114514; int y = lowbit(x); //相当于直接运行函数, 没有调用关系 //inline int lowbit(int x) { // return x &amp; (-x); //} cout &lt;&lt; y &lt;&lt; endl; return 0;} 对于一些需要调用多次的函数, 可以使用inline声明他是内联的. 对于inline函数, 调用时不像普通函数那样, 将地址, 参数等关键信息压入栈(一种内存布局)中, 再执行call指令. 返回时再操作栈, 最后ret. 这样不仅费时间, 还浪费栈空间. inline函数会在预处理阶段像宏(如#define)在调用处原地展开. 注意事项 对递归函数没用(有人说递归程序用inline会爆re, 本人亲测不会, 应该是编译器优化掉了) 节省了栈空间和调用开销, 但是增加了程序编译后的体积. 在比赛中没啥事, 但在实际开发中慎用. 小实验: 探究inline函数的性质(诚意满满, 真的不看看吗?) 反编译工具: IDA Pro 7.5 (32-bit) 测试环境: Windows 10 x64 我们写出如下测试代码: 1234567891011121314//test.cpp#include &lt;iostream&gt;inline int my_inline_func(int x) { //lowbit :) return x &amp; (-x);}int main() { int n = 0; scanf(\"%d\", &amp;n); printf(\"%d\\n\", my_inline_func(n)); return 0;} 使用g++ test.cpp -O -o test.exe命令(-O表示开启优化, 即使用内联函数)生成可执行文件. 反编译之后: 123456789101112131415161718192021222324252627282930313233; main().text:00401421 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401421 public _main.text:00401421 _main proc near ; CODE XREF: sub_4011A0+8E↑p.text:00401421.text:00401421 argc = dword ptr 8.text:00401421 argv = dword ptr 0Ch.text:00401421 envp = dword ptr 10h.text:00401421.text:00401421 ; __unwind {.text:00401421 push ebp.text:00401422 mov ebp, esp.text:00401424 and esp, 0FFFFFFF0h.text:00401427 sub esp, 20h.text:0040142A call ___main.text:0040142F mov dword ptr [esp+1Ch], 0.text:00401437 lea eax, [esp+1Ch].text:0040143B mov [esp+4], eax.text:0040143F mov dword ptr [esp], offset Format ; \"%d\".text:00401446 call _scanf ;这里应该就是inline函数展开后的样子了, 可以看到并没有调用的过程.text:0040144B mov edx, [esp+1Ch].text:0040144F mov eax, edx.text:00401451 neg eax.text:00401453 and eax, edx.text:00401455 mov [esp+4], eax.text:00401459 mov dword ptr [esp], offset aD_0 ; \"%d\\n\".text:00401460 call _printf.text:00401465 mov eax, 0.text:0040146A leave.text:0040146B retn.text:0040146B ; } // starts at 401421.text:0040146B _main endp 可以知道, inline函数只是就地展开, 并没有调用, 这个\"调用的\"过程在地址上是连续的, 没有涉及到地址和参数的push/pop操作. 看得还不够清楚? 让我们点一下F5 借助IDA Pro强大的Hex-rays插件, 可以清楚地看到main函数编译后变成了这个样子. 12345678910int __cdecl main(int argc, const char **argv, const char **envp){ int v4; // [esp+1Ch] [ebp-4h] BYREF __main(); //这个是预处理, 即程序的入口点, 不用管. v4 = 0; scanf(\"%d\", &amp;v4); printf(\"%d\\n\", v4 &amp; -v4); //这就是inline函数的魅力 :) return 0;} 现在, inline函数的作用我们的理解已经很透彻了. 算法优化 相关STL 据说set, map常数比较大. 但是我不会手写. 所以用着吧... 但是std::sort()据说很高级, 快排, 堆排, 插入排序三管齐下, 性能很不错. 基本上只要自己写写归并, 剩下交给sort就好. 不要作死 这是在赛前加的, 意在提醒广大选手不要为了优化而作死, 想一个更好的算法或者打暴力拿个部分分不香吗? 以下内容在NOI系列竞赛中不能用!!! 不包括全部, 只包括选手们可能会作死用到的(我猜的). 还是以官方说明为准, 这里只是提醒一下. pragma(如私自开O2, 或者开栈) 官方明令禁止 开栈的话需要在本机修改, (方法自行百度). CSP不限制栈空间. 内联汇编 官方明令禁止. 内联汇编分两种, 一种是__asm__, 一种是开一个数组把机器码放进去, 再memcpy到可执行的内存区域上 都不要用!!! 尤其是第二种, 你在自己的电脑上玩玩算了, 很可能在这台电脑上能运行, 另一台电脑上就出错. 而且这类程序需要高权限, 可执行的内存区域都不太好往里写数据. 最重要的, 比赛用了会爆零!!!","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"常数优化","slug":"常数优化","permalink":"https://ret2libc-pwned.github.io/tags/%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/"},{"name":"笔记","slug":"笔记","permalink":"https://ret2libc-pwned.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://ret2libc-pwned.github.io/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}]},{"title":"国庆模拟赛后总结","slug":"国庆模拟赛后总结","date":"2021-10-17T03:11:30.000Z","updated":"2021-10-17T13:08:44.569Z","comments":true,"path":"2021/10/17/国庆模拟赛后总结/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/17/%E5%9B%BD%E5%BA%86%E6%A8%A1%E6%8B%9F%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/","excerpt":"","text":"赛后总结 注: 没写完, 因为有的题还没过. 前言 这个文档不一定在写精妙的算法, 有的部分甚至不是在分析满分解法, 更多的是怎么得该得的分以及怎么减少不必要的失分. 即: 目标是在j组复赛中分数最大化. 2021/10/01 T1 在调错上浪费太多时间了, 最后才发现算法没有问题, 是switch语句的问题!!! 教训: 在写代码之前推思路的时候一定要明确它的正确性! 发现运行的结果不一样时不要轻易改代码, 更不要轻易改算法! 调试小技巧: 输出一些东西 or 注释掉大段代码, 这些方法主要是快速定位出错的地方的, 实在不行可以下断点调试(用gdb可以的, 注意加debug symbol). 在怀疑算法出问题的时候在纸上推, 不要动代码!!! 这题的正解是模运算, 可以快速定位到循环运行多次后的指令, 不必一次次模拟了. (考场上写的是直接模拟, 拿指针一个一个走的那种, 拿了60分已经很不错了) 正解: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int dx[4] = {1, 0, -1, 0};const int dy[4] = {0, -1, 0, 1};const char cmd[4] = {'E', 'S', 'W', 'N'};string ops;int t, currx, curry, cnt[4];inline void go(int op) { currx += dx[op]; curry += dy[op];}int main() { cin &gt;&gt; ops &gt;&gt; t; //先运行一遍命令串 int oplen = ops.length(); for(int i = 0; i &lt; oplen; i ++) { char ch = ops[i]; //不知道为什么switch会出问题, 比赛就是在这里卡了半小时 if(ch == 'E') go(0); if(ch == 'S') go(1); if(ch == 'W') go(2); if(ch == 'N') go(3); } int cishu = t / oplen; //每个操作执行cishu遍, 但还可能有多余 int pos = t % oplen; //最后一个操作的位置 //判断条件 if(cishu == 0) goto OUTPUT; //指令数 &gt;= t --&gt; 已经走完了, 直接输出就行 //第二种情况, 即len &lt; t, 要循环多次 currx *= cishu; curry *= cishu; //走一次走到了当前的(x, y), 走cishu次就意味着每个点都走了cishu次, 对结果的影响求积即可 //好现在还剩几步, 走完它 for(int i = 0; i &lt; pos; i ++) { char ch = ops[i]; if(ch == 'E') go(0); if(ch == 'S') go(1); if(ch == 'W') go(2); if(ch == 'N') go(3); }OUTPUT: cout &lt;&lt; currx &lt;&lt; ' ' &lt;&lt; curry &lt;&lt; endl; return 0;} T2 在推模拟分解质因数时浪费太多时间了, 这种考\"板子\"的数学题要在平时多做. 考场上要减少推板子的时间. 另外还好这题没打表, \"只要是数学题就打表\"终究是一种\"骗分\"的心态. 还是要多推式子. 附: 计算一个数素因数个数的代码 1234567891011int fac(int x) { int res = 0; for(int i = 2; i &lt;= x; i ++) { if(x % i == 0) { res ++; x /= i; i --; //这行是尝试再拿这个数除一遍, 因为一个数可能有多个相同的质因子. } } return res;} 还有就是第十个点具体的数据给我们了, 是一个很大的数据, 这个O(N*sqrt(N))的算法显然要算很久(在我电脑上算了一个半小时), 所以只能用特判. 考试的时候可以优先用暴力或正解算着这种数据, 得到特判就行. 注: 这道是我两天模拟赛中唯一觉得做得还不错, 没啥太大遗憾的题. 注2: 我的电脑算了一个半小时, 终于算出最后一个点的特判是564714!!! 但是为什么第八个点还没过??? 最后是90分. T3 模拟题, 字太多考试的时候懒得看了. 之后这种题要多想想! 至少把样例算算, 知道模拟的过程. 现在赛后订正的时候也懒得看 T4 四联通问题, 把上下左右当成相邻的节点用bfs访问 2021/10/03 T1 一定要注意看清数据范围! 就比如这道题说了 \\[ N &lt; 1,000,000 \\] 就一定要开1e6, 宁肯开大一点也不要开小!!! 一位数组不会因为开得跟题中一样大而MLE!!! 教训: 1e5的代码52分, 1e6就ac了. 真的是很可惜的, 明明满分算法想出来了, 思路就是正确的, 甚至代码写得都没问题. 就是因为数组没开大, 失分惨重. 思路再说一下吧, 前缀和. 这种区间询问或操作一位数组问题的算法在我目前的知识范围内大多只会是前缀和, 差分, 树状数组, 线段树了, 更高级的感觉j组考不到, 现在也不是学这种东西的时候. 虽然1000万个数似乎很多, 但是, 如果这些数是8字节的整数, 那么将占用大致80MB. Introduction to Algorithms(3rd edition) T2 12const int N = 1e6;int array[N]; //大约占用4MB空间 这道题因为开了1e8的数组, 用了memset导致全部的点MLE. 数组不要开太大!!! (1e8个int约等于380MB) 本来可以得60分暴力分, 结果这题因为这个爆零了. 本题的正解是离线询问, 并记录操作, 类似于化简到最后一个操作, 就不必模拟了. 赛后还以为是用了几个玄学优化导致的问题. 说到玄学优化, 在这里记录几个好用的玄学优化:(好像扯得有点远了) cin优化 12ios_base::sync_with_stdio(false);cin.tie(0); //cin.tie(nullptr)在C++11及以上可用 (这两行的意思是关闭与stdio的同步, 以提升cin, cout的速度. 在IO比较多的时候很好用. 注意:用了这个优化就不能用stdio内的函数如printf()和scanf(). 当然printf和scanf的速度是更快的, 如果会写快读快写那更快, putchar()和getchar()的速度不是吹的. ) 寄存器操作 1for(register int i = 0; i &lt; n; i ++) 直接操作寄存器, 这样更快. p.s. csp用不了内联汇编, 所以不要作死, 这个用用就行了 行内函数(inline) 1234567891011121314inline int add(int x, int y) { return x + y;}int main() { add(1, 1); //直接就地展开函数, 没有调用关系 /* 相当于 inline int add(int x, int y) { return x + y; } */ return 0;} 适用于代码少, 调用频繁的函数. 函数调用时会将参数, 基址这些东西压栈. 最后call. 运行结束后会压入返回地址等信息(这些东西快忘了, 不对请指正). 这样调用一次无疑浪费了很多时间精力.(有空的话贴一下反汇编代码看得更清楚) 用inline定义会在调用处就地展开, 个人觉得比较像#define(?) 但是这么用会让代码编译后变得更大, 实际开发中要慎用. (算法比赛中没关系) T3 这里发现了两轮游戏中的单调性质, 但是竟然在纠结用哪个数据结构实现!!! 最后时间全浪费了, 暴力都没写完. 以后算法较为简单的题, 一定要先写暴力或者基本思路, 不要先默板子或纠结该默哪个板子!!! T4 这一题要采用类似图论存图的方法存能开哪里的灯, 然后bfs. 题干的意思其实是要找到房间之间的 \"连接\" 关系. 想到这里就能知道要用类似邻接表的方式存图了. 考场上我主要的问题在于只想着打暴力就用dfs, 就能拿分. 但是这个dfs在本机都肉眼可见地慢, 就放弃治疗, 也不想剪枝了. 想到bfs而不是用其它方法个人理解是因为本题要先开相邻的灯, 如果dfs需要走完一个方向才能走另一个方向, 不剪枝极其浪费. 2021/10/05 T1 模拟赛中第一次ac. 老师给的题解: 数组模拟 (可以理解为手写双端队列) 自己的解法: stl大法好(使用std::deque, 即双端队列, 可以理解为可操作两端的std::queue) 可能会出现的问题: 一些stl内的函数可能性能不如手写的, 例如std::string里面的S.find(P)就是暴力匹配的, 性能不如手写KMP. 这是个重大的时刻, 贴个代码纪念一下, 顺便复习一下deque的用法. (另外做这题的时候好像cin忘加了, 导致浪费了亿点时间调错) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;deque&lt;int&gt; q; //需要从前后操作, 双端队列int n, id;inline void clearq() { while(q.size()) { q.pop_front(); }}inline void add(char op, int x) { //op == 'L' 左边入队 //op == 'R' 右边入队 //cout &lt;&lt; \"add()\" &lt;&lt; op &lt;&lt; ' ' &lt;&lt; x; if(op == 'L') { q.push_front(x); } if(op == 'R') { q.push_back(x); }}inline void kill_people(char op, int x) { if(op == 'L') { for(int i = 0; i &lt; x; i ++) q.pop_front(); } if(op == 'R') { for(int i = 0; i &lt; x; i ++) q.pop_back(); }}inline int popq() { int res; res = q.front(); q.pop_front(); return res;}int main() { //clearq(); ios_base::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) { //puts(\"LOOP\"); char op, op1; int k; cin &gt;&gt; op &gt;&gt; op1; //cout &lt;&lt; op &lt;&lt; ' ' &lt;&lt; op1; if(op == 'A') { add(op1, ++ id); //只有入队才会有新的编号, 单独记录 //puts(\"added!!!\") } else { cin &gt;&gt; k; kill_people(op1, k); } } while(q.size()) { cout &lt;&lt; q.front() &lt;&lt; endl; //从队首开始pop q.pop_front(); } return 0;} T2 T3 暴力解法是每个数跟它的左边和上面比较, 统计出符合条件的, 计算最大的面积. 正解是dp. 预处理column[i][j]和can[i][j][k](用can[i][j][k]表示从第 i 行到第 j 行中的第 k 列能否接道第 i 行到第 j 行的 k-1 列中): \\[ column[i][j]={column[i-1][j]+1(a[i][j]&gt;=a[i- 1][j]),column[i][j]=1} \\] 其中 \\[ can[i][j][k]=(can[i][j-1][k])\\and(column[j][k]&gt;=j-i+1)\\and(a[j][k]&gt;=a[j][k- 1])\\and(coulumn[j][k-1]&gt;=j-i+1 \\] 贴一个70分解法(用的不是dp, 也不是我写的) 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;//DP?!不过我不想用正常的方法 那就写点玄学的吧。int n,m,ma[205][205],row[205][205],col[205][205];int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)cin&gt;&gt;ma[i][j]; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j){ row[i][j]=1; for(int k=j+1;k&lt;=m;++k){ if(ma[i][k-1]&lt;=ma[i][k])row[i][j]++; else break; } } for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=n;++j){ col[j][i]=1; for(int k=j+1;k&lt;=n;++k){ if(ma[k-1][i]&lt;=ma[k][i])col[j][i]++; else break; } } //完了完了 玄学方法开始了 int temp=0,ans=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) for(int k=1;k&lt;=row[i][j];++k){//k就是一种长度 int len=*min_element(col[i]+j,col[i]+j+k); temp=k*len; ans=max(temp,ans); } cout&lt;&lt;ans&lt;&lt;endl; return 0;} T4 这题不知道为什么写的算法没问题, 比赛的时候交了是零分(赛后交了一遍完全一样的代码ac了). 就当这次ac了吧, 但是一定要明白为什么会出这种问题, 比赛的时候要是还出就叫天天不灵, 叫地地不应了. 这题想了蛮久的, 主要是证明算法的正确性. 要注意的就是如果这种贪心题最后推出了一个比较简单的式子不要怀疑, 只要每一步都确定是对的式子就没错, 不要在这里过于纠结, 浪费时间. 思路再说一下: 要让ci * t最大, 就要让ci越大的获得更大时间差(这不是废话吗), 即把ci进行从大到小排序, 依次把最大的两个一样的放到最前面和最后面. 难点是模拟这个放在最前和最后的过程. 贴一下考场上的代码, 前面是排序. 123456789101112131415//安排位置 int n1 = 1, n2 = n; //[1, n] //n1: 开始时间偏移量 //n2: 结束时间偏移量 for(int i = 1; i &lt;= k, n1 &lt;= n2; i ++, n1 ++, n2 --) { //两两一对地插入 //if(c[i] == c[i + 1]) //cout &lt;&lt; (c[i] == c[i + 1]) &lt;&lt; ' ' &lt;&lt; c[i] &lt;&lt; ' ' &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; c[i - 1] &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; endl; //把大(c[i])的放在最后 小的(c[i + 1])放在最前 时间差最大 //第一次不得分 求时间差乘以最大的(即c[i])即可 //ans += ((n2 - n1) * c[i] + 0); ans += (n2 - n1) * c[i]; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"模拟赛","slug":"模拟赛","permalink":"https://ret2libc-pwned.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://ret2libc-pwned.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-06T06:53:59.209Z","updated":"2021-10-17T09:07:02.605Z","comments":true,"path":"2021/10/06/hello-world/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/06/hello-world/","excerpt":"","text":"如题, 这是我的第一篇文章.","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"数据结构","slug":"数据结构","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"平衡树","slug":"平衡树","permalink":"https://ret2libc-pwned.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"},{"name":"BST","slug":"BST","permalink":"https://ret2libc-pwned.github.io/tags/BST/"},{"name":"算法","slug":"算法","permalink":"https://ret2libc-pwned.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://ret2libc-pwned.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"},{"name":"常数优化","slug":"常数优化","permalink":"https://ret2libc-pwned.github.io/tags/%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/"},{"name":"笔记","slug":"笔记","permalink":"https://ret2libc-pwned.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://ret2libc-pwned.github.io/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"},{"name":"模拟赛","slug":"模拟赛","permalink":"https://ret2libc-pwned.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"}]}