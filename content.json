{"meta":{"title":"Ret2Libc","subtitle":"真正的勇士敢于直面惨淡的人生，敢于正视淋漓的鲜血。 --鲁迅","description":"","author":"ret2libc","url":"https://ret2libc-pwned.github.io","root":"/"},"pages":[{"title":"tags","date":"2021-10-16T12:54:16.000Z","updated":"2021-10-16T13:10:07.521Z","comments":false,"path":"categories/index.html","permalink":"https://ret2libc-pwned.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于我","date":"2021-10-16T14:14:36.000Z","updated":"2021-10-17T10:44:28.724Z","comments":false,"path":"about/index.html","permalink":"https://ret2libc-pwned.github.io/about/index.html","excerpt":"","text":"自我介绍 你好, 我是Ret2libc, 正在零基础入门算法! 本网站主要是自己的一点笔记和心得, 如果你恰好找到了这里, 我很希望它们能帮助到你! 联系方式 QQ 2184016258, 欢迎和我交朋友, 或者教教我怎么零基础入门算法! 至于洛谷, poj之类的. 因为我太菜了, 没过几题, 不好意思放. 等我ac的多一点再放吧. 为什么叫Ret2libc? 主要是之前我对安全比较感兴趣(安全这方面也很菜), 尤其是pwn. ret2libc是一个栈溢出利用方法. 取这个名字主要是不想让别人找到我(主要是OIer没几个知道这个词......). 这个网站会留多久? 搭这个网站主要是为了在机房能看到自己的笔记, 所以会留比较久. 值得一提的是如果github pages由于各种原因访问不上, 可以去这个网站的香港腾讯云镜像."},{"title":"tags","date":"2021-10-16T13:18:16.000Z","updated":"2021-10-17T03:36:02.847Z","comments":false,"path":"tags/index.html","permalink":"https://ret2libc-pwned.github.io/tags/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-10-16T12:17:58.000Z","updated":"2021-10-16T13:25:50.508Z","comments":true,"path":"conmment/index.html","permalink":"https://ret2libc-pwned.github.io/conmment/index.html","excerpt":"","text":"有什么想说的? 有什么想问的?"}],"posts":[{"title":"OI比赛中的那些玄学优化","slug":"OI比赛中的那些玄学优化","date":"2021-10-22T10:07:36.000Z","updated":"2021-10-22T12:16:27.535Z","comments":true,"path":"2021/10/22/OI比赛中的那些玄学优化/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/22/OI%E6%AF%94%E8%B5%9B%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E7%8E%84%E5%AD%A6%E4%BC%98%E5%8C%96/","excerpt":"","text":"前言 这是我暑假零基础入门C++的时候整理的小技巧. 现在到了CSP-2021赛前, 我在看笔记的时候发现了这个, 就把它发在我的网站上, 希望能帮到即将参加OI的你, 也希望能借此给自己增加Rp. 这也是我第一次OI比赛, 希望能考好点. 读入优化 fread快读/快写代码来自oi-wiki 关闭同步(推荐) 12ios_base::sync_with_stdio(false);cin.tie(0); 关闭iostream与stdio中输入输出流的同步. 使std::cin与std::cout接近于scanf()与printf()的速度. 注意事项 这个小优化是用得最多的, cin和cout慢的要命, 在IO特别多的题中要用cin/cout一定要加. 注意: 加了第一行之后将无法使用printf(), scanf()等stdio.h中的函数, 如果作死用了会导致IO流混乱! 注意2: cin/cout写入文件不是即时的, 所以一定要endl刷新缓冲区(或者\\n之类的) printf()和scanf()(推荐) 同上, 速度嗖嗖的. 但是不能在关闭同步后使用. 还能格式化字符串, 不香吗?(比如让你保留8位小数, 只需printf(\"%.8lf\", my_variable)即可, cout还需借助iomanip) 快读/快写 很好用, getchar()和putchar()快如闪电. 12345678910111213141516int read() { int x = 0, w = 1; //x是数字, w是符号位 char ch = 0; while (ch &lt; '0' || ch &gt; '9') { //!isdigit(ch) if (ch == '-') w = -1; ch = getchar(); } while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { //isdigit(ch) x = x * 10 + (ch - '0'); ch = getchar(); } return x * w;}//Example://int n = read(); 123456789101112inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) putchar(sta[--top] + 48); //(int)'0'}//Example://int a = 5;//write(a); fread(较为玄学) 12345678910111213141516171819202122232425262728293031namespace IO {const int MAXSIZE = 1 &lt;&lt; 20;char buf[MAXSIZE], *p1, *p2;#define gc() \\ (p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin), p1 == p2) \\ ? EOF \\ : *p1++)inline int rd() { int x = 0, f = 1; char c = gc(); while (!isdigit(c)) { if (c == '-') f = -1; c = gc(); } while (isdigit(c)) x = x * 10 + (c ^ 48), c = gc(); return x * f;}char pbuf[1 &lt;&lt; 20], *pp = pbuf;inline void push(const char &amp;c) { if (pp - pbuf == 1 &lt;&lt; 20) fwrite(pbuf, 1, 1 &lt;&lt; 20, stdout), pp = pbuf; *pp++ = c;}inline void write(int x) { static int sta[35]; int top = 0; do { sta[top++] = x % 10, x /= 10; } while (x); while (top) push(sta[--top] + '0');}} // namespace IO 如上是基于fread实现的快读快写, 本质是利用文件的缓冲区. 实现时需要将getchar()稍微改改, (代码中\\表示显示不下, 写的时候从这一行接着写就行, 无需换行) 注意事项 敲这个板子太费时间了, 还是用上面那个基于putchar()和getchar()的那个性价比最高. 好像这个东西很玄学, 一些情况下会使整个程序变慢(?) 执行优化 ++i(较为推荐) 有研究表明++i比i++快, 说是i++用了一个临时变量. 注: 很多人在网上科普两者的关系, 但是只是看反编译代码, 看到++i比i++用的汇编指令少一两个, 就说++i更快(甚至每一句指令的意思都说一下, 即到底慢在哪了)??? 就算真的是这样这种不懂装懂的态度也不是很好 ++i执行完后的值跟i是一样的, 可以拿来给其它变量赋值. 1int k = ++i; register(已经死了) register, 即直接操作寄存器. 在C++14逐渐被弃用. 在之前的C++版本中都可以放在循环里面提升性能. 1for(register int i = 0; i &lt; n; ++i) inline内联函数(推荐) inline可以在调用处就地展开函数. 12345678910111213141516using namespace std;inline int lowbit(int x) { return x &amp; (-x);}int main() { int x = 114514; int y = lowbit(x); //相当于直接运行函数, 没有调用关系 //inline int lowbit(int x) { // return x &amp; (-x); //} cout &lt;&lt; y &lt;&lt; endl; return 0;} 对于一些需要调用多次的函数, 可以使用inline声明他是内联的. 对于inline函数, 调用时不像普通函数那样, 将地址, 参数等关键信息压入栈(一种内存布局)中, 再执行call指令. 返回时再操作栈, 最后ret. 这样不仅费时间, 还浪费栈空间. inline函数会在预处理阶段像宏(如#define)在调用处原地展开. 注意事项 对递归函数没用(有人说递归程序用inline会爆re, 本人亲测不会, 应该是编译器优化掉了) 节省了栈空间和调用开销, 但是增加了程序编译后的体积. 在比赛中没啥事, 但在实际开发中慎用. 小实验: 探究inline函数的性质(诚意满满, 真的不看看吗?) 反编译工具: IDA Pro 7.5 (32-bit) 测试环境: Windows 10 x64 我们写出如下测试代码: 1234567891011121314//test.cpp#include &lt;iostream&gt;inline int my_inline_func(int x) { //lowbit :) return x &amp; (-x);}int main() { int n = 0; scanf(\"%d\", &amp;n); printf(\"%d\\n\", my_inline_func(n)); return 0;} 使用g++ test.cpp -O -o test.exe命令(-O表示开启优化, 即使用内联函数)生成可执行文件. 反编译之后: 123456789101112131415161718192021222324252627282930313233; main().text:00401421 ; int __cdecl main(int argc, const char **argv, const char **envp).text:00401421 public _main.text:00401421 _main proc near ; CODE XREF: sub_4011A0+8E↑p.text:00401421.text:00401421 argc = dword ptr 8.text:00401421 argv = dword ptr 0Ch.text:00401421 envp = dword ptr 10h.text:00401421.text:00401421 ; __unwind {.text:00401421 push ebp.text:00401422 mov ebp, esp.text:00401424 and esp, 0FFFFFFF0h.text:00401427 sub esp, 20h.text:0040142A call ___main.text:0040142F mov dword ptr [esp+1Ch], 0.text:00401437 lea eax, [esp+1Ch].text:0040143B mov [esp+4], eax.text:0040143F mov dword ptr [esp], offset Format ; \"%d\".text:00401446 call _scanf ;这里应该就是inline函数展开后的样子了, 可以看到并没有调用的过程.text:0040144B mov edx, [esp+1Ch].text:0040144F mov eax, edx.text:00401451 neg eax.text:00401453 and eax, edx.text:00401455 mov [esp+4], eax.text:00401459 mov dword ptr [esp], offset aD_0 ; \"%d\\n\".text:00401460 call _printf.text:00401465 mov eax, 0.text:0040146A leave.text:0040146B retn.text:0040146B ; } // starts at 401421.text:0040146B _main endp 可以知道, inline函数只是就地展开, 并没有调用, 这个\"调用的\"过程在地址上是连续的, 没有涉及到地址和参数的push/pop操作. 看得还不够清楚? 让我们点一下F5 借助IDA Pro强大的Hex-rays插件, 可以清楚地看到main函数编译后变成了这个样子. 12345678910int __cdecl main(int argc, const char **argv, const char **envp){ int v4; // [esp+1Ch] [ebp-4h] BYREF __main(); //这个是预处理, 即程序的入口点, 不用管. v4 = 0; scanf(\"%d\", &amp;v4); printf(\"%d\\n\", v4 &amp; -v4); //这就是inline函数的魅力 :) return 0;} 现在, inline函数的作用我们的理解已经很透彻了. 算法优化 相关STL 据说set, map常数比较大. 但是我不会手写. 所以用着吧... 但是std::sort()据说很高级, 快排, 堆排, 插入排序三管齐下, 性能很不错. 基本上只要自己写写归并, 剩下交给sort就好. 不要作死 这是在赛前加的, 意在提醒广大选手不要为了优化而作死, 想一个更好的算法或者打暴力拿个部分分不香吗? 以下内容在NOI系列竞赛中不能用!!! 不包括全部, 只包括选手们可能会作死用到的(我猜的). 还是以官方说明为准, 这里只是提醒一下. 编译命令 / programa(如-O2) 官方明令禁止 内联汇编 官方明令禁止. 内联汇编分两种, 一种是__asm__, 一种是开一个数组把机器码放进去, 再memcpy到可执行的内存区域上 都不要用!!! 尤其是第二种, 你在自己的电脑上玩玩算了, 很可能在这台电脑上能运行, 另一台电脑上就出错. 而且这类程序需要高权限, 可执行的内存区域都不太好往里写数据. 最重要的, 比赛用了会爆零!!!","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"常数优化","slug":"常数优化","permalink":"https://ret2libc-pwned.github.io/tags/%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/"},{"name":"笔记","slug":"笔记","permalink":"https://ret2libc-pwned.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://ret2libc-pwned.github.io/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"}]},{"title":"国庆模拟赛后总结","slug":"国庆模拟赛后总结","date":"2021-10-17T03:11:30.000Z","updated":"2021-10-17T13:08:44.569Z","comments":true,"path":"2021/10/17/国庆模拟赛后总结/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/17/%E5%9B%BD%E5%BA%86%E6%A8%A1%E6%8B%9F%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/","excerpt":"","text":"赛后总结 注: 没写完, 因为有的题还没过. 前言 这个文档不一定在写精妙的算法, 有的部分甚至不是在分析满分解法, 更多的是怎么得该得的分以及怎么减少不必要的失分. 即: 目标是在j组复赛中分数最大化. 2021/10/01 T1 在调错上浪费太多时间了, 最后才发现算法没有问题, 是switch语句的问题!!! 教训: 在写代码之前推思路的时候一定要明确它的正确性! 发现运行的结果不一样时不要轻易改代码, 更不要轻易改算法! 调试小技巧: 输出一些东西 or 注释掉大段代码, 这些方法主要是快速定位出错的地方的, 实在不行可以下断点调试(用gdb可以的, 注意加debug symbol). 在怀疑算法出问题的时候在纸上推, 不要动代码!!! 这题的正解是模运算, 可以快速定位到循环运行多次后的指令, 不必一次次模拟了. (考场上写的是直接模拟, 拿指针一个一个走的那种, 拿了60分已经很不错了) 正解: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int dx[4] = {1, 0, -1, 0};const int dy[4] = {0, -1, 0, 1};const char cmd[4] = {'E', 'S', 'W', 'N'};string ops;int t, currx, curry, cnt[4];inline void go(int op) { currx += dx[op]; curry += dy[op];}int main() { cin &gt;&gt; ops &gt;&gt; t; //先运行一遍命令串 int oplen = ops.length(); for(int i = 0; i &lt; oplen; i ++) { char ch = ops[i]; //不知道为什么switch会出问题, 比赛就是在这里卡了半小时 if(ch == 'E') go(0); if(ch == 'S') go(1); if(ch == 'W') go(2); if(ch == 'N') go(3); } int cishu = t / oplen; //每个操作执行cishu遍, 但还可能有多余 int pos = t % oplen; //最后一个操作的位置 //判断条件 if(cishu == 0) goto OUTPUT; //指令数 &gt;= t --&gt; 已经走完了, 直接输出就行 //第二种情况, 即len &lt; t, 要循环多次 currx *= cishu; curry *= cishu; //走一次走到了当前的(x, y), 走cishu次就意味着每个点都走了cishu次, 对结果的影响求积即可 //好现在还剩几步, 走完它 for(int i = 0; i &lt; pos; i ++) { char ch = ops[i]; if(ch == 'E') go(0); if(ch == 'S') go(1); if(ch == 'W') go(2); if(ch == 'N') go(3); }OUTPUT: cout &lt;&lt; currx &lt;&lt; ' ' &lt;&lt; curry &lt;&lt; endl; return 0;} T2 在推模拟分解质因数时浪费太多时间了, 这种考\"板子\"的数学题要在平时多做. 考场上要减少推板子的时间. 另外还好这题没打表, \"只要是数学题就打表\"终究是一种\"骗分\"的心态. 还是要多推式子. 附: 计算一个数素因数个数的代码 1234567891011int fac(int x) { int res = 0; for(int i = 2; i &lt;= x; i ++) { if(x % i == 0) { res ++; x /= i; i --; //这行是尝试再拿这个数除一遍, 因为一个数可能有多个相同的质因子. } } return res;} 还有就是第十个点具体的数据给我们了, 是一个很大的数据, 这个O(N*sqrt(N))的算法显然要算很久(在我电脑上算了一个半小时), 所以只能用特判. 考试的时候可以优先用暴力或正解算着这种数据, 得到特判就行. 注: 这道是我两天模拟赛中唯一觉得做得还不错, 没啥太大遗憾的题. 注2: 我的电脑算了一个半小时, 终于算出最后一个点的特判是564714!!! 但是为什么第八个点还没过??? 最后是90分. T3 模拟题, 字太多考试的时候懒得看了. 之后这种题要多想想! 至少把样例算算, 知道模拟的过程. 现在赛后订正的时候也懒得看 T4 四联通问题, 把上下左右当成相邻的节点用bfs访问 2021/10/03 T1 一定要注意看清数据范围! 就比如这道题说了 \\[ N &lt; 1,000,000 \\] 就一定要开1e6, 宁肯开大一点也不要开小!!! 一位数组不会因为开得跟题中一样大而MLE!!! 教训: 1e5的代码52分, 1e6就ac了. 真的是很可惜的, 明明满分算法想出来了, 思路就是正确的, 甚至代码写得都没问题. 就是因为数组没开大, 失分惨重. 思路再说一下吧, 前缀和. 这种区间询问或操作一位数组问题的算法在我目前的知识范围内大多只会是前缀和, 差分, 树状数组, 线段树了, 更高级的感觉j组考不到, 现在也不是学这种东西的时候. 虽然1000万个数似乎很多, 但是, 如果这些数是8字节的整数, 那么将占用大致80MB. Introduction to Algorithms(3rd edition) T2 12const int N = 1e6;int array[N]; //大约占用4MB空间 这道题因为开了1e8的数组, 用了memset导致全部的点MLE. 数组不要开太大!!! (1e8个int约等于380MB) 本来可以得60分暴力分, 结果这题因为这个爆零了. 本题的正解是离线询问, 并记录操作, 类似于化简到最后一个操作, 就不必模拟了. 赛后还以为是用了几个玄学优化导致的问题. 说到玄学优化, 在这里记录几个好用的玄学优化:(好像扯得有点远了) cin优化 12ios_base::sync_with_stdio(false);cin.tie(0); //cin.tie(nullptr)在C++11及以上可用 (这两行的意思是关闭与stdio的同步, 以提升cin, cout的速度. 在IO比较多的时候很好用. 注意:用了这个优化就不能用stdio内的函数如printf()和scanf(). 当然printf和scanf的速度是更快的, 如果会写快读快写那更快, putchar()和getchar()的速度不是吹的. ) 寄存器操作 1for(register int i = 0; i &lt; n; i ++) 直接操作寄存器, 这样更快. p.s. csp用不了内联汇编, 所以不要作死, 这个用用就行了 行内函数(inline) 1234567891011121314inline int add(int x, int y) { return x + y;}int main() { add(1, 1); //直接就地展开函数, 没有调用关系 /* 相当于 inline int add(int x, int y) { return x + y; } */ return 0;} 适用于代码少, 调用频繁的函数. 函数调用时会将参数, 基址这些东西压栈. 最后call. 运行结束后会压入返回地址等信息(这些东西快忘了, 不对请指正). 这样调用一次无疑浪费了很多时间精力.(有空的话贴一下反汇编代码看得更清楚) 用inline定义会在调用处就地展开, 个人觉得比较像#define(?) 但是这么用会让代码编译后变得更大, 实际开发中要慎用. (算法比赛中没关系) T3 这里发现了两轮游戏中的单调性质, 但是竟然在纠结用哪个数据结构实现!!! 最后时间全浪费了, 暴力都没写完. 以后算法较为简单的题, 一定要先写暴力或者基本思路, 不要先默板子或纠结该默哪个板子!!! T4 这一题要采用类似图论存图的方法存能开哪里的灯, 然后bfs. 题干的意思其实是要找到房间之间的 \"连接\" 关系. 想到这里就能知道要用类似邻接表的方式存图了. 考场上我主要的问题在于只想着打暴力就用dfs, 就能拿分. 但是这个dfs在本机都肉眼可见地慢, 就放弃治疗, 也不想剪枝了. 想到bfs而不是用其它方法个人理解是因为本题要先开相邻的灯, 如果dfs需要走完一个方向才能走另一个方向, 不剪枝极其浪费. 2021/10/05 T1 模拟赛中第一次ac. 老师给的题解: 数组模拟 (可以理解为手写双端队列) 自己的解法: stl大法好(使用std::deque, 即双端队列, 可以理解为可操作两端的std::queue) 可能会出现的问题: 一些stl内的函数可能性能不如手写的, 例如std::string里面的S.find(P)就是暴力匹配的, 性能不如手写KMP. 这是个重大的时刻, 贴个代码纪念一下, 顺便复习一下deque的用法. (另外做这题的时候好像cin忘加了, 导致浪费了亿点时间调错) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;deque&gt;using namespace std;deque&lt;int&gt; q; //需要从前后操作, 双端队列int n, id;inline void clearq() { while(q.size()) { q.pop_front(); }}inline void add(char op, int x) { //op == 'L' 左边入队 //op == 'R' 右边入队 //cout &lt;&lt; \"add()\" &lt;&lt; op &lt;&lt; ' ' &lt;&lt; x; if(op == 'L') { q.push_front(x); } if(op == 'R') { q.push_back(x); }}inline void kill_people(char op, int x) { if(op == 'L') { for(int i = 0; i &lt; x; i ++) q.pop_front(); } if(op == 'R') { for(int i = 0; i &lt; x; i ++) q.pop_back(); }}inline int popq() { int res; res = q.front(); q.pop_front(); return res;}int main() { //clearq(); ios_base::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; n; for(int i = 1; i &lt;= n; i ++) { //puts(\"LOOP\"); char op, op1; int k; cin &gt;&gt; op &gt;&gt; op1; //cout &lt;&lt; op &lt;&lt; ' ' &lt;&lt; op1; if(op == 'A') { add(op1, ++ id); //只有入队才会有新的编号, 单独记录 //puts(\"added!!!\") } else { cin &gt;&gt; k; kill_people(op1, k); } } while(q.size()) { cout &lt;&lt; q.front() &lt;&lt; endl; //从队首开始pop q.pop_front(); } return 0;} T2 T3 暴力解法是每个数跟它的左边和上面比较, 统计出符合条件的, 计算最大的面积. 正解是dp. 预处理column[i][j]和can[i][j][k](用can[i][j][k]表示从第 i 行到第 j 行中的第 k 列能否接道第 i 行到第 j 行的 k-1 列中): \\[ column[i][j]={column[i-1][j]+1(a[i][j]&gt;=a[i- 1][j]),column[i][j]=1} \\] 其中 \\[ can[i][j][k]=(can[i][j-1][k])\\and(column[j][k]&gt;=j-i+1)\\and(a[j][k]&gt;=a[j][k- 1])\\and(coulumn[j][k-1]&gt;=j-i+1 \\] 贴一个70分解法(用的不是dp, 也不是我写的) 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;//DP?!不过我不想用正常的方法 那就写点玄学的吧。int n,m,ma[205][205],row[205][205],col[205][205];int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j)cin&gt;&gt;ma[i][j]; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j){ row[i][j]=1; for(int k=j+1;k&lt;=m;++k){ if(ma[i][k-1]&lt;=ma[i][k])row[i][j]++; else break; } } for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=n;++j){ col[j][i]=1; for(int k=j+1;k&lt;=n;++k){ if(ma[k-1][i]&lt;=ma[k][i])col[j][i]++; else break; } } //完了完了 玄学方法开始了 int temp=0,ans=0; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) for(int k=1;k&lt;=row[i][j];++k){//k就是一种长度 int len=*min_element(col[i]+j,col[i]+j+k); temp=k*len; ans=max(temp,ans); } cout&lt;&lt;ans&lt;&lt;endl; return 0;} T4 这题不知道为什么写的算法没问题, 比赛的时候交了是零分(赛后交了一遍完全一样的代码ac了). 就当这次ac了吧, 但是一定要明白为什么会出这种问题, 比赛的时候要是还出就叫天天不灵, 叫地地不应了. 这题想了蛮久的, 主要是证明算法的正确性. 要注意的就是如果这种贪心题最后推出了一个比较简单的式子不要怀疑, 只要每一步都确定是对的式子就没错, 不要在这里过于纠结, 浪费时间. 思路再说一下: 要让ci * t最大, 就要让ci越大的获得更大时间差(这不是废话吗), 即把ci进行从大到小排序, 依次把最大的两个一样的放到最前面和最后面. 难点是模拟这个放在最前和最后的过程. 贴一下考场上的代码, 前面是排序. 123456789101112131415//安排位置 int n1 = 1, n2 = n; //[1, n] //n1: 开始时间偏移量 //n2: 结束时间偏移量 for(int i = 1; i &lt;= k, n1 &lt;= n2; i ++, n1 ++, n2 --) { //两两一对地插入 //if(c[i] == c[i + 1]) //cout &lt;&lt; (c[i] == c[i + 1]) &lt;&lt; ' ' &lt;&lt; c[i] &lt;&lt; ' ' &lt;&lt; n1 &lt;&lt; ' ' &lt;&lt; c[i - 1] &lt;&lt; ' ' &lt;&lt; n2 &lt;&lt; endl; //把大(c[i])的放在最后 小的(c[i + 1])放在最前 时间差最大 //第一次不得分 求时间差乘以最大的(即c[i])即可 //ans += ((n2 - n1) * c[i] + 0); ans += (n2 - n1) * c[i]; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"模拟赛","slug":"模拟赛","permalink":"https://ret2libc-pwned.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://ret2libc-pwned.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-06T06:53:59.209Z","updated":"2021-10-17T09:07:02.605Z","comments":true,"path":"2021/10/06/hello-world/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/06/hello-world/","excerpt":"","text":"如题, 这是我的第一篇文章.","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"常数优化","slug":"常数优化","permalink":"https://ret2libc-pwned.github.io/tags/%E5%B8%B8%E6%95%B0%E4%BC%98%E5%8C%96/"},{"name":"笔记","slug":"笔记","permalink":"https://ret2libc-pwned.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"https://ret2libc-pwned.github.io/tags/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/"},{"name":"模拟赛","slug":"模拟赛","permalink":"https://ret2libc-pwned.github.io/tags/%E6%A8%A1%E6%8B%9F%E8%B5%9B/"},{"name":"赛后总结","slug":"赛后总结","permalink":"https://ret2libc-pwned.github.io/tags/%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/"},{"name":"题解","slug":"题解","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]}