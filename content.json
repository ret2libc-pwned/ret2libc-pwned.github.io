{"meta":{"title":"Ret2Libc","subtitle":"Hello, the cruel world.","description":"","author":"ret2libc","url":"https://ret2libc-pwned.github.io","root":"/"},"pages":[{"title":"å…³äºæˆ‘","date":"2021-10-16T14:14:36.000Z","updated":"2022-04-29T12:17:51.170Z","comments":false,"path":"about/index.html","permalink":"https://ret2libc-pwned.github.io/about/index.html","excerpt":"","text":"è‡ªæˆ‘ä»‹ç» ä½ å¥½, æˆ‘æ˜¯Ret2libc, æ­£åœ¨é›¶åŸºç¡€å…¥é—¨ç®—æ³•! æœ¬ç½‘ç«™ä¸»è¦æ˜¯è‡ªå·±çš„ä¸€ç‚¹ç¬”è®°å’Œå¿ƒå¾—, å¦‚æœä½ æ°å¥½æ‰¾åˆ°äº†è¿™é‡Œ, æˆ‘å¾ˆå¸Œæœ›å®ƒä»¬èƒ½å¸®åŠ©åˆ°ä½ ! è”ç³»æ–¹å¼ QQ 2184016258, æ¬¢è¿å’Œæˆ‘äº¤æœ‹å‹, æˆ–è€…æ•™æ•™æˆ‘æ€ä¹ˆé›¶åŸºç¡€å…¥é—¨ç®—æ³•! ä¸ºä»€ä¹ˆå«Ret2libc? ret2libcæ˜¯pwn(äºŒè¿›åˆ¶å®‰å…¨, binary exploitation)é‡Œçš„ä¸€ä¸ªæ ˆæº¢å‡ºåˆ©ç”¨æ–¹æ³•. è¿™ä¸ªç½‘ç«™ä¼šç•™å¤šä¹…? æ­è¿™ä¸ªç½‘ç«™ä¸»è¦æ˜¯ä¸ºäº†åœ¨æœºæˆ¿èƒ½çœ‹åˆ°è‡ªå·±çš„ç¬”è®°, æ‰€ä»¥ä¼šç•™æ¯”è¾ƒä¹…. å€¼å¾—ä¸€æçš„æ˜¯å¦‚æœgithub pagesç”±äºå„ç§åŸå› è®¿é—®ä¸ä¸Š, å¯ä»¥å»è¿™ä¸ªç½‘ç«™çš„é¦™æ¸¯è…¾è®¯äº‘é•œåƒ."},{"title":"tags","date":"2021-10-16T12:54:16.000Z","updated":"2021-10-16T13:10:07.521Z","comments":false,"path":"categories/index.html","permalink":"https://ret2libc-pwned.github.io/categories/index.html","excerpt":"","text":""},{"title":"ç•™è¨€æ¿","date":"2021-10-16T12:17:58.000Z","updated":"2021-10-16T13:25:50.508Z","comments":false,"path":"conmment/index.html","permalink":"https://ret2libc-pwned.github.io/conmment/index.html","excerpt":"","text":"æœ‰ä»€ä¹ˆæƒ³è¯´çš„? æœ‰ä»€ä¹ˆæƒ³é—®çš„?"},{"title":"tags","date":"2021-10-16T13:18:16.000Z","updated":"2021-10-17T03:36:02.847Z","comments":false,"path":"tags/index.html","permalink":"https://ret2libc-pwned.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"å•è°ƒé˜Ÿåˆ—","slug":"å•è°ƒé˜Ÿåˆ—","date":"2022-04-30T11:11:11.000Z","updated":"2022-05-01T12:29:39.121Z","comments":true,"path":"2022/04/30/å•è°ƒé˜Ÿåˆ—/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/04/30/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/","excerpt":"","text":"å®šä¹‰ ç»´æŠ¤ä¸€ç§åºåˆ—, å¯ä»¥ä»å¤´å’Œå°¾å¢åŠ æˆ–åˆ é™¤å…ƒç´ (å³åŒç«¯é˜Ÿåˆ—), ä¸”å…ƒç´ å…·æœ‰å•è°ƒæ€§. å®ç° æœ¬è´¨æ˜¯ç»´æŠ¤å…·æœ‰å•è°ƒæ€§çš„æœ€ä¼˜å†³ç­–é›†åˆ, è¯¥å¦‚ä½•ç»´æŠ¤æœ€ä¼˜ä¸å•è°ƒçš„æ€§è´¨å‘¢? ç»´æŠ¤åºåˆ— è¯¥æ“ä½œçš„æœ¬è´¨æ˜¯å¯¹åŸåºåˆ—\\(A\\)æ‰«æ, å°†å½“å‰çš„å…ƒç´ \\(A_i\\)ä¸å•è°ƒé˜Ÿåˆ—é˜Ÿå°¾æ¯”è¾ƒ, å¦‚æœ\\(A_i\\)æ›´ä¼˜åˆ™å°†é˜Ÿå°¾æ¢æˆ\\(A_i\\). //pseudo code Queue q, Array a[]; int head = 0, tail = 0; for each a[i] in a { while(é˜Ÿåˆ—è¿‡å¤§) ++head; //pop front //æ­¤æ—¶q[head]ä¸ºå½“å‰æœ€ä¼˜ while(head &lt; tail &amp;&amp; q[tail]æ²¡æœ‰a[i]ä¼˜) --tail; //pop back q[++tail] = å½“å‰å€¼; } å®ç°åŒç«¯é˜Ÿåˆ— std::deque å¯ä»¥ä½¿ç”¨dequeå¯¹åºåˆ—è¿›è¡Œæ“ä½œ. using namespace std; deque&lt;int&gt; q; //å…¥é˜Ÿ q.push_front(x); q.push_back(x); //å‡ºé˜Ÿ q.pop_front(); q.pop_back(); //å–å¤´å°¾ q.front(); q.back(); //éå† for(int x: q) { cout &lt;&lt; x &lt;&lt; \" \"; } puts(\"\"); æ•°ç»„æ¨¡æ‹Ÿ å¯ä»¥ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆ\\(head\\), \\(tail\\)æ¨¡æ‹Ÿ. éœ€è¦æ³¨æ„çš„æ˜¯æ•°ç»„ä¸­ä¸‹æ ‡å°çš„å…ƒç´ åœ¨é˜Ÿåˆ—å‰é¢, åŒæ—¶æŒ‡é’ˆ\\(head \\le tail\\). ä¾‹é¢˜ æ»‘åŠ¨çª—å£ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º\\(n\\)çš„åºåˆ—, æ±‚å…¶æ¯ä¸ªé•¿åº¦ä¸º\\(k\\)çš„è¿ç»­å­åºåˆ—ä¸­çš„æœ€å¤§ä¸æœ€å°å€¼. æœ¬é¢˜åªéœ€ç»´æŠ¤ä¸¤ä¸ªå•è°ƒé˜Ÿåˆ—(ä¸€ä¸ªé€’å‡, é˜Ÿå¤´ä¸ºmin; å¦ä¸€ä¸ªåä¹‹)å³å¯. éœ€è¦æ³¨æ„çš„æ˜¯è¦è®©çª—å£å¤§å°ä¸è¶…è¿‡\\(k\\), è¿™é‡Œé‡‡ç”¨åœ¨é˜Ÿåˆ—ä¸­å­˜å‚¨æ•°ç»„ä¸‹æ ‡çš„æ–¹æ³•ç»Ÿè®¡, å³ä¿è¯\\(head\\)ä¸­å­˜å‚¨çš„ä¸‹æ ‡ä¸å½“å‰æ‰«æå…ƒç´ çš„ä¸‹æ ‡ä¹‹å·®å°äº\\(k\\). #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; const int N = 1e6 + 100; int q[N], a[N]; int n, k; void getMin() { //ç»´æŠ¤é€’å‡åºåˆ—, é˜Ÿå¤´å³ä¸ºç­”æ¡ˆ int head = 0, tail = 0; for(int i = 1; i &lt; k; ++i) { //Step 1: [1, k), push while(head &lt;= tail &amp;&amp; a[q[tail]] &gt;= a[i]) --tail; q[++tail] = i; } for(int i = k; i &lt;= n; ++i) { //Step 2: [k, n] //è¿™ä¸ªåŒºé—´çª—å£å¯èƒ½è¶…è¿‡k, éœ€è¦ç‰¹åˆ¤ç»´æŠ¤çª—å£å¤§å° while(head &lt;= tail &amp;&amp; a[q[tail]] &gt;= a[i]) --tail; q[++tail] = i; while(q[head] &lt;= i - k) ++head; cout &lt;&lt; a[q[head]] &lt;&lt; ' '; } } void getMax() { memset(q, 0, sizeof q); int head = 0, tail = 0; for(int i = 1; i &lt; k; ++i) { while(head &lt;= tail &amp;&amp; a[q[tail]] &lt;= a[i]) --tail; q[++tail] = i; } for(int i = k; i &lt;= n; ++i) { while(head &lt;= tail &amp;&amp; a[q[tail]] &lt;= a[i]) --tail; q[++tail] = i; if(q[head] &lt;= i - k) ++head; cout &lt;&lt; a[q[head]] &lt;&lt; ' '; } } int main() { cin &gt;&gt; n &gt;&gt; k; for(int i = 1; i &lt;= n; ++i) { cin &gt;&gt; a[i]; } getMin(); puts(\"\"); getMax(); puts(\"\"); return 0; } æœ€å¤§å­åºå’Œ ç»™å®šä¸€ä¸ªé•¿åº¦ä¸º\\(n\\)çš„åºåˆ—, æ±‚å‡ºä¸€æ®µé•¿åº¦ä¸è¶…è¿‡\\(m\\)çš„è¿ç»­å­åºåˆ—, è¾“å‡ºå­åºå’Œ. ä¸éš¾æƒ³åˆ°å‰ç¼€å’Œæ“ä½œ, åœ¨å‰ç¼€å’Œæ•°ç»„\\(S\\)ä¸­, å¯¹äºå³ç«¯ç‚¹\\(r\\), éœ€è¦æ‰¾åˆ°å·¦ç«¯ç‚¹\\(l\\)æ»¡è¶³å¦‚ä¸‹æ¡ä»¶: \\[ \\begin {cases} l \\in [1, r - 1]&amp;&amp;&amp;(1)\\\\ \\min(S_l)&amp;&amp;&amp;(2)\\\\ r - m \\le l&amp;&amp;&amp;(3) \\end {cases} \\] å…¶ä¸­, 3å¼çš„æ„æ€æ˜¯è®©å­åºåˆ—çš„å¤§å°ä¸è¶…è¿‡\\(m\\). #include &lt;iostream&gt; const int N = 1e6; using namespace std; int m, n; int a[N], s[N]; int q[N]; int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= n; ++i) { cin &gt;&gt; a[i]; s[i] = s[i - 1] + a[i]; } int head = 0, tail = 0, ans = -0x3f; for(int i = 1; i &lt;= n; ++i) { while(head &lt;= tail &amp;&amp; i - m &gt; q[head]) ++head; ans = max(ans, s[i] - s[q[head]]); while(head &lt;= tail &amp;&amp; s[q[tail]] &gt;= s[i]) --tail; q[++tail] = i; } cout &lt;&lt; ans &lt;&lt; endl; return 0; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"å­—å…¸æ ‘","slug":"trie","date":"2022-04-18T13:21:23.987Z","updated":"2022-04-29T12:25:00.999Z","comments":true,"path":"2022/04/18/trie/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/04/18/trie/","excerpt":"","text":"å­—å…¸æ ‘ å®šä¹‰ åº”ç”¨ åƒæŸ¥å­—å…¸ä¸€æ ·\"æ£€ç´¢\"å­—ç¬¦ä¸² #include &lt;iostream&gt; #include &lt;string&gt; const int N = 1e6; using namespace std; struct Trie { int nxt[N][26], tot = 0; bool ed[N]; void insert(string s) { int p = 0; for(char ch: s) { int key = ch - 'a'; if(nxt[p][key] == 0) { nxt[p][key] = ++tot; } p = nxt[p][key]; } ed[p] = true; } bool isExist(string s) { int p = 0; for(char ch: s) { int key = ch - 'a'; if(nxt[p][key] == 0) { return false; } p = nxt[p][key]; } return ed[p]; } }; Trie tr; //Allocate int main() { int cas; cin &gt;&gt; cas; while(cas--) { string s; cin &gt;&gt; s; tr.insert(s); } puts(\"Inserted!!!!!!\\n\\nAsk Me!!!!!!!\"); cin &gt;&gt; cas; while(cas--) { string s; cin &gt;&gt; s; puts(tr.isExist(s) ? \"Exist.\" : \"Not Exist.\"); } return 0; } å¼‚æˆ–æå€¼é—®é¢˜","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"","slug":"æ ‘å½¢dp","date":"2022-03-25T11:36:01.065Z","updated":"2022-03-27T11:58:20.437Z","comments":true,"path":"2022/03/25/æ ‘å½¢dp/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/03/25/%E6%A0%91%E5%BD%A2dp/","excerpt":"","text":"æ ‘å½¢dp ä¾‹é¢˜ æ²¡æœ‰ä¸Šå¸çš„èˆä¼š ä½¿ç”¨\\(dp(u, 0/1)\\)è¡¨ç¤ºä»¥\\(u\\)æ¥æˆ–ä¸æ¥æ—¶\\(u\\)ä¸ºæ ¹ç»“ç‚¹å­æ ‘çš„å¿«ä¹æŒ‡æ•°æ€»å’Œ. åˆ™: \\[ dp(u, 0) = \\sum \\max_{v \\in u.\\mathrm{son}} \\{dp(v, 0), dp(v, 1)\\}\\\\ dp(u, 1) = dp(v, 0) \\] #include &lt;iostream&gt; #include &lt;cstring&gt; const int N = 1e6 + 10; using namespace std; int head[N], to[N], nxt[N], tot, n, r[N], Root = 1, dp[N][2]; bool haveFa[N]; inline void initGraph() { memset(head, -1, sizeof head); tot = -1; } void addEdge(int u, int v) { nxt[++tot] = head[u], head[u] = tot, to[tot] = v; } void calc(int u) { for(int i = head[u]; ~i; i = nxt[i]) { int v = to[i]; calc(v); dp[u][0] += max(dp[v][0], dp[v][1]); dp[u][1] += dp[v][0]; } } int main() { initGraph(); cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) { cin &gt;&gt; dp[i][1]; } for(int i = 1; i &lt; n; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(v, u); haveFa[u] = true; } while(haveFa[Root]) { Root++; } calc(Root); cout &lt;&lt; max(dp[Root][0], dp[Root][1]) &lt;&lt; endl; return 0; } æˆ˜ç•¥æ¸¸æˆ #include &lt;iostream&gt; #include &lt;cstring&gt; const int N = 1e6 + 10; using namespace std; int head[N], to[N], nxt[N], tot, dp[N][2], n, Root; inline void initGraph() { memset(head, -1, sizeof head); tot = -1; } void addEdge(int u, int v) { nxt[++tot] = head[u], head[u] = tot, to[tot] = v; } void calc(int u) { dp[u][1] = 1, dp[u][0] = 0; for(int i = head[u]; ~i; i = nxt[i]) { int v = to[i]; calc(v); dp[u][0] += dp[v][1]; dp[u][1] += min(dp[v][0], dp[v][1]); } } int main() { initGraph(); cin &gt;&gt; n; for(int i = 1; i &lt;= n; ++i) { int u, k; cin &gt;&gt; u &gt;&gt; k; for(int j = 1; j &lt;= k; ++j) { int v; cin &gt;&gt; v; addEdge(u, v); } } calc(0); cout &lt;&lt; min(dp[0][0], dp[0][1]) &lt;&lt; endl; return 0; } DPæ±‚æ ‘çš„ç›´å¾„ #include &lt;iostream&gt; #include &lt;cstring&gt; #include &lt;queue&gt; const int N = 1e6 + 10, INF = 0x3f3f3f3f; using namespace std; int n; int head[N], to[N], nxt[N], tot, Root, d1[N], d2[N]; bool vis[N]; inline void initGraph() { memset(head, -1, sizeof head); tot = -1; } void addEdge(int u, int v) { nxt[++tot] = head[u], head[u] = tot, to[tot] = v; } int getDiam(int u) { int ret = -INF; d1[u] = d2[u] = 0; for(int i = head[u]; ~i; i = nxt[i]) { int v = to[i]; getDiam(v); int t = d1[v] + 1; if(t &gt; d1[u]) { d2[u] = d1[u], d1[u] = t; } else if(t &gt; d2[u]) { d2[u] = t; } } ret = max(ret, d1[u] + d2[u]); return ret; } int main() { initGraph(); cin &gt;&gt; n; for(int i = 0; i &lt; n - 1; ++i) { int u, v; cin &gt;&gt; u &gt;&gt; v; addEdge(u, v); } int ans = getDiam(1); cout &lt;&lt; ans &lt;&lt; endl; return 0; } æ¶ˆé˜²å±€çš„è®¾ç«‹","categories":[],"tags":[]},{"title":"Splay","slug":"Splay","date":"2022-03-12T13:39:05.000Z","updated":"2022-04-30T02:45:43.529Z","comments":true,"path":"2022/03/12/Splay/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/03/12/Splay/","excerpt":"","text":"Splay å®šä¹‰ Splayæ˜¯ä¸€ç§BST, å°†è®¿é—®è¿‡çš„ç»“ç‚¹ä¸æ–­æ—‹è½¬åˆ°æ ¹ç»“ç‚¹, åœ¨æ»¡è¶³BSTæ€§è´¨çš„åŒæ—¶ä¿è¯å…¶\"å¹³è¡¡\", åŸºäºæ—¶é—´ã€ç©ºé—´å±€éƒ¨æ€§åŸç†ä¼˜åŒ–æŸ¥æ‰¾æ€§èƒ½(è¿™æ ·æ“ä½œä½¿å¾—é«˜é¢‘è®¿é—®çš„ç»“ç‚¹åœ¨ç»å¸¸æ ¹ç»“ç‚¹é™„è¿‘). æœ¬æ–‡çš„BSTæ¯ä¸€ä¸ªç»“ç‚¹åªç»´æŠ¤å•ä¸ªå€¼(è€Œéé”®å€¼å¯¹), ä¸‹é¢è¯´æ³•ä¸­vã€valã€keyéƒ½æŒ‡è¿™ä¸ªå€¼, BSTæ€§è´¨çš„ç»´æŠ¤å®ƒä»¬çš„å¤§å°å…³ç³»åšä¾æ®. BSTæ€§è´¨ å·¦å­æ ‘ä»»æ„ç»“ç‚¹çš„key\\(\\lt\\)æ ¹ç»“ç‚¹key\\(\\lt\\)å³å­æ ‘ä»»æ„ç»“ç‚¹key, å³ä¸­åºéå†å•è°ƒé€’å¢. å¸¸è§çš„BSTæœ‰Treapã€Splayã€AVLç­‰. ç»“ç‚¹ç»“æ„ å¼€ç»“æ„ä½“æ•°ç»„è®°å½•ä¸¤ä¸ªå­ç»“ç‚¹åŠçˆ¶ç»“ç‚¹çš„æ•°ç»„ä¸‹æ ‡, ç±»ä¼¼äºä¸€ä¸ªé“¾è¡¨(å®é™…ä¸Šå¾ˆå¤šæ ‘çŠ¶æ•°æ®ç»“æ„éƒ½æ˜¯æ•°ç»„æ¨¡æ‹Ÿé“¾è¡¨). ç»“ç‚¹åŒæ—¶å­˜å‚¨ç»´æŠ¤çš„ä¿¡æ¯. const int SIZE = 1e5; struct Node { //ä¸¤ä¸ªå­ç»“ç‚¹åŠçˆ¶ç»“ç‚¹æ•°ç»„ä¸‹æ ‡, val int s[2], p, v; //å»¶è¿Ÿæ ‡è®°åŠå­æ ‘å¤§å° int dat, size; //åˆå§‹åŒ–å½“å‰ç»“ç‚¹ void init(int _v, int _p) { v = _v, p = _p; size = 1; } }; //Allocate Node tr[SIZE]; ``` å…¶ä¸­è§„å®š`s[0]`ä¸ºå·¦å­ç»“ç‚¹, `s[1]`ä¸ºå³å­ç»“ç‚¹, å³: (åç»­ä»£ç å‡æœªä½¿ç”¨å¦‚ä¸‹define, åªæ˜¯ä¸ºäº†æ–¹ä¾¿ç†è§£) ``` cpp #define ls s[0] #define rs s[1] #define son s[k] #define son_bro s[k ^ 1] //son's brother å•æ—‹æ“ä½œ(rotate) æ—‹è½¬éœ€è¦ä¿è¯BSTæ€§è´¨; æ ¹ç»“ç‚¹å˜é‡, å³rootéœ€è¦æ›´æ–°; ç»“ç‚¹ç»´æŠ¤çš„ä¿¡æ¯(å¦‚å»¶è¿Ÿæ ‡è®°)éœ€è¦æ›´æ–°. æ—‹è½¬æ”¹å˜äº†æ˜¯æ ‘çš„å½¢æ€, æœ¬è´¨æ˜¯æ”¹å˜çˆ¶å­å…³ç³». Splayå•æ—‹ å³æ—‹, å³\\(\\operatorname{Zig}(x)\\)æ“ä½œ é¡¾åæ€ä¹‰å°±æ˜¯å°†\\(x\\)çš„å·¦å­æ ‘ç»•ç€\\(x\\)çš„çˆ¶ç»“ç‚¹\\(y\\)å‘å³æ—‹è½¬. éœ€è¦æ³¨æ„çš„æ˜¯\\(x \\lt x_r \\lt y\\), æ•…\\(x_r\\)åº”è¯¥è½¬åˆ°\\(y_r\\)å·¦å­æ ‘çš„ä½ç½®. è¿™æ ·çš„æ“ä½œé€šè¿‡æ”¹å˜\\(y\\)ä¸\\(x_r\\)ã€\\(\\operatorname{fa}(y)\\)ä¸\\(x\\)ã€\\(x\\)ä¸\\(y\\)çš„çˆ¶å­å…³ç³»è¾¾åˆ°. å·¦æ—‹, å³\\(\\operatorname{Zag}(x)\\)æ“ä½œ åŒç†, \\(x\\)çš„å³å­æ ‘ç»•ç€\\(y\\)å‘å·¦æ—‹è½¬, \\(x_l\\)æ¥åœ¨\\(y\\)å³å­æ ‘ä½ç½®. å³éœ€è¦æ”¹å˜\\(y\\)ä¸\\(x_l\\)ã€\\(\\operatorname{fa}(y)\\)ä¸\\(x\\)ã€\\(x\\)ä¸\\(y\\)çš„çˆ¶å­å…³ç³». æ—‹è½¬ç»“ç‚¹, å³\\(\\operatorname{rotate}(x)\\)æ“ä½œ ä¸Šè¿°æ“ä½œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ“ä½œ\\(\\operatorname{rotate}(x)\\)æ¥å®Œæˆ, å³å®ç°\"è‡ªåŠ¨åˆ¤å®šå·¦å³\"çš„å•æ—‹æ“ä½œ. \\(x\\)æ˜¯\\(y\\)çš„å·¦å­æ ‘å°±å³æ—‹, å³å­æ ‘åä¹‹. è¯¥æ“ä½œçš„ç²¾é«“å°±æ˜¯åˆ¤å®š\\(x\\)æ˜¯\\(y\\)çš„å·¦ç»“ç‚¹è¿˜æ˜¯å³ç»“ç‚¹. å‰é¢è¯´è¿‡, \"æ—‹è½¬\"çš„æœ¬è´¨æ˜¯\"æ”¹å˜çˆ¶å­å…³ç³»\". æ¯ä¸ªç»“ç‚¹ç»´æŠ¤äº†å¥¹çš„å·¦å³å­æ ‘å’Œçˆ¶ç»“ç‚¹, æ‰€ä»¥è¯¥è¿‡ç¨‹éœ€è¦\"äº’è®¤\"çˆ¶å­å…³ç³», å³éœ€è¦ä¿®æ”¹ä¸¤ä¸ªç»“ç‚¹çš„ä¿¡æ¯; åŒæ—¶å› ä¸ºæ ‘çš„å½¢æ€è¢«æ”¹å˜, éœ€è¦é‡æ–°ç»Ÿè®¡å»¶è¿Ÿæ ‡è®°ç»´æŒçš„ä¿¡æ¯(å¦‚å­æ ‘å¤§å°). void Rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = (tr[y].s[1] == x); tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; //tr[x].s[k]çš„å«ä¹‰æ˜¯å–å¤„äºyxç›´çº¿ä¸Šçš„xçš„å„¿å­, k ^ 1æ˜¯å–å¥¹çš„å…„å¼Ÿ Pushup(y), Pushup(x); } è¯´äººè¯å°±æ˜¯: \\(k\\)çš„è·å–: inline int k(int x, int y) { /* *@description è¿”å›xæ˜¯yçš„å“ªä¸ªå„¿å­, å·¦0å³1. */ return (tr[y].s[1] == x); } rotateä¼ªä»£ç : /* yæ˜¯xçš„çˆ¸çˆ¸, zæ˜¯xçš„çˆ·çˆ·; */ /* ä»¥ä¸‹æ¯ä¸€æ­¥éƒ½éœ€è¦ä¿®æ”¹ä¸¤ä¸ªç»“ç‚¹çš„å€¼, å³äº’è®¤å…³ç³» */ ç”¨zå–åˆ°y, å°†xè½¬åˆ°yçš„ä½ç½®ä¸Š, å¹¶ä¸zäº’è®¤; /* ä»¥ä¸‹ä¸¤éƒ¨å‡éœ€æ“ä½œç»“ç‚¹ä¸å…¶çˆ¶ç»“ç‚¹\"äº’è®¤\"è¿‡ç¨‹, ä¸å†èµ˜è¿° */ x(æ­¤æ—¶åœ¨yçš„ä½ç½®ä¸Š)çš„å…„å¼Ÿè½¬åˆ°åŸå…ˆx(å³tr[y].s[k])çš„ä½ç½®ä¸Š; è®©yè½¬åˆ°åŸå…ˆxçš„å…„å¼Ÿçš„ä½ç½®; åˆ†åˆ«æ›´æ–°y, xå­æ ‘ç»´æŠ¤çš„ä¿¡æ¯; åŒæ—‹æ“ä½œ(splay) é€šè¿‡ä¸€æˆ–ä¸¤æ¬¡rotate, å¯ä»¥è°ƒæ•´BSTçš„å½¢æ€, ä½¿å…¶æ›´å¹³è¡¡. é€šè¿‡è¿‡ç¨‹\\(\\operatorname{splay}(x, goal)\\)å°†ç»“ç‚¹\\(x\\)è½¬åˆ°\\(goal\\)çš„å­ç»“ç‚¹. è§„å®š\\(y\\)æ˜¯\\(x\\)çˆ¶ç»“ç‚¹, \\(z\\)æ˜¯\\(y\\)çˆ¶ç»“ç‚¹, splayåˆ†å…­ç§(3 * 2)æƒ…å†µè®¨è®º. å½“\\(\\operatorname{fa}(x) = \\operatorname{Root}\\)æ—¶, æ—‹è½¬ä¸€æ¬¡\\(x\\)(å³æˆ–å·¦), å³Zigæˆ–Zag; å½“\\(\\operatorname{fa}(x) \\ne \\operatorname{Root}\\)ä¸”\\(z, y, x\\)åœ¨ä¸€æ¡ç›´çº¿ä¸Š, æ—‹è½¬ä¸€æ¬¡\\(y\\), å†åŒæ–¹å‘æ—‹è½¬ä¸€æ¬¡\\(x\\), å³Zig-Zigæˆ–Zag-Zag; å½“\\(\\operatorname{fa}(x) \\ne \\operatorname{Root}\\)ä¸”\\(z, y, x\\)å½¢çŠ¶æ˜¯åœ¨ä¸€æ¡ç›´çº¿çš„ä¸­é—´æŠ˜äº†ä¸€ä¸‹, åˆ†åˆ«å¯¹\\(x\\)æ‰§è¡Œä¸¤æ¬¡ä¸åŒæ–¹å‘çš„æ—‹è½¬, å³Zig-Zagæˆ–Zag-Zig. ç”»å›¾ç†è§£å³å¯. ä½¿ç”¨rotateå°±æ˜¯: æŠ˜çº¿2x ç›´çº¿yx éœ€è¦æ³¨æ„çš„æ˜¯è¯¥æ“ä½œæ˜¯å°†\\(x\\)è½¬åˆ°\\(goal\\)ä¸‹é¢, æ•…å½“\\(x\\)ä¸\\(goal\\)ä¸ºå…·æœ‰çˆ¶å­å…³ç³»çš„ä¸¤ä¸ªç»“ç‚¹æ—¶ (å³ç¬¬1ã€2ç§æƒ…å†µ)ä¸éœ€è¦æ“ä½œ(å³ä¸éœ€è¦äº¤æ¢å®ƒä»¬). void Splay(int x, int goal) { //æŠŠxè½¬åˆ°goalä¸‹é¢ while(tr[x].p != goal) { int y = tr[x].p, z = tr[y].p; if(z != goal) { if((tr[z].s[1] == y) ^ (tr[y].s[1] == x)) Rotate(x); //æŠ˜çº¿å…ˆè½¬xå†è½¬x else Rotate(y); //ç›´çº¿å…ˆè½¬y } Rotate(x); //ç»Ÿä¸€è½¬x } if(goal == 0) Root = x; //æ›´æ–°æ ¹ç»“ç‚¹(0ä¸ºæ ¹ç»“ç‚¹ä¸‹æ ‡) } æ’å…¥æ“ä½œ(insert) è¿‡ç¨‹\\(\\operatorname{insert}(val)\\)å°†\\(val\\)æ’å…¥BSTçš„ç›¸åº”ä½ç½®\\(x\\), å°†æ’å…¥çš„æ•°è½¬åˆ°æ ¹ç»“ç‚¹, å³æ‰§è¡Œ\\(\\operatorname{splay}(x, 0)\\). æ’å…¥æ—¶éœ€è¦ç»´æŠ¤BSTæ€§è´¨, å°†æ’å…¥çš„è¿™ä¸ªæ•°ä¸å½“å‰èŠ‚ç‚¹æ¯”è¾ƒ, \"å°æ’å·¦, å¤§æ’å³\". void Insert(int v) { /* * @param v è¦æ’å…¥å€¼çš„val. */ int u = Root, p = 0; //ä»æ ¹ç»“ç‚¹å¼€å§‹, uä¸ºå½“å‰èŠ‚ç‚¹æ•°ç»„ä¸‹æ ‡, pä¸ºå¥¹çš„çˆ¸çˆ¸ä¸‹æ ‡ while(u) { p = u, u = tr[u].s[v &gt; tr[u].v]; //å°å·¦å¤§å³åœ°æ’ä¸‹å», æ–¹æ‹¬å·é‡Œçš„æ˜¯åˆ¤å®šå·¦å³ } u = ++idx; //ç»“ç‚¹åˆå¤šäº†ä¸€ä¸ª, idx += 1; if(p) tr[p].s[v &gt; tr[p].v] = u; //å°†pçš„å„¿å­uæ’å…¥é€‚å½“ä½ç½® tr[u].init(v, p); //ç»™è¿™ä¸ªç‚¹åˆå§‹åŒ–çˆ¸çˆ¸ä¸‹æ ‡å’Œè‡ªèº«value, å¹¶å°†å¤§å°è®¾ä¸º1 splay(u, 0); //è½¬åˆ°æ ¹ç»“ç‚¹ } æŸ¥è¯¢æŒ‡å®šæ•°çš„æ’å(getRank) ä¸ä¼šğŸ˜„. æŸ¥è¯¢ç¬¬\\(k\\)å°çš„æ•°(getValByRank) \\(\\operatorname{getValByRank}(rank)\\)æ“ä½œåˆ†ä¸‰ç§æƒ…å†µè®¨è®º: \\[ ç»“ç‚¹ä½äº:\\, \\begin{cases} 1. æ‰€æ±‚ç»“ç‚¹ä½äºå·¦å­æ ‘, å·¦å­æ ‘ç»“ç‚¹ä¸ªæ•°\\ge rank;\\\\ 2. æ‰€æ±‚ç»“ç‚¹ä¸ºä¸­åºéå†ç¬¬kä¸ªæ•°(å³å·¦å­æ ‘çš„çˆ¶ç»“ç‚¹), å·¦å­æ ‘ç»“ç‚¹ä¸ªæ•° = rank - 1;\\\\ 3. æ‰€æ±‚ç»“ç‚¹ä½äºå³å­æ ‘(rankéœ€è¦å‡å»å·¦å­æ ‘å¤§å°åŠ ä¸€çš„å’Œ), å·¦å­æ ‘ç»“ç‚¹ä¸ªæ•° \\lt rank - 1 \\end{cases} \\] int getValByRank(int rk) { int u = Root; while(true) { Pushdown(u); if(tr[tr[u].s[0]] &gt;= rk) u = tr[u].s[0]; else if(tr[tr[u].s[0]] + 1 == rk) return u; else rk -= (tr[tr[u].s[0]] + 1), u = tr[u].s[1]; } return -1; } åˆ é™¤æ“ä½œ(delete) æ“ä½œ\\(\\operatorname{delete}(x)\\)ä»Splayä¸­åˆ é™¤valueä¸º\\(x\\)çš„ç»“ç‚¹. è¯¥æ“ä½œé¦–å…ˆå°†\\(x\\)è½¬åˆ°æ ¹ç»“ç‚¹, å†åˆå¹¶\\(x\\)çš„å·¦å³å­æ ‘. æŸ¥è¯¢å‰é©±/åç»§(getPrefix/getSuffix) \\(x\\)çš„å‰é©±: å°äº\\(x\\)çš„æœ€å¤§æ•°; \\(x\\)çš„åç»§: å¤§äº\\(x\\)çš„æœ€å°æ•°. \\(\\operatorname{getPrefix}(x)\\)æ“ä½œæŸ¥è¯¢\\(x\\)çš„å‰é©±, å¯ä»¥é€šè¿‡æ’å…¥\\(x\\)(æ’å…¥åä½äºæ ¹ç»“ç‚¹), æ­¤æ—¶\\(x\\)å·¦å­æ ‘ä¸­æœ€å³è¾¹çš„ç»“ç‚¹å³ä¸ºæ‰€æ±‚, æœ€ååˆ é™¤ç»“ç‚¹\\(x\\); \\(\\operatorname{getSuffix}(x)\\)æ“ä½œåä¹‹. ä¾‹é¢˜ æ–‡è‰ºå¹³è¡¡æ ‘(Luogu P3391) ç¿»è½¬ä¸€ä¸ªåŒºé—´ï¼Œä¾‹å¦‚åŸæœ‰åºåºåˆ—æ˜¯\\(\\{5, 4, 3, 2, 1\\}\\)ï¼Œç¿»è½¬åŒºé—´æ˜¯\\([2, 4]\\)çš„è¯ï¼Œç»“æœæ˜¯\\(\\{5, 2, 3, 4, 1\\}\\). åœ¨ç»“ç‚¹ä¸Šç»´æŠ¤å»¶è¿Ÿæ ‡è®°\\(flag\\)æ¥åˆ¤å®šç¿»è½¬çŠ¶æ€, é¿å…å¤šæ¬¡ç¿»è½¬é€ æˆæ€§èƒ½ä¸Šçš„æµªè´¹. #include &lt;iostream&gt; const int N = 1e5; using namespace std; struct Node { int s[2], p, v, siz; int flag; //flag == 1åˆ™éœ€è¦ç¿»è½¬ void init(int _v, int _p) { v = _v, p = _p; siz = 1; } }; Node tr[N]; int idx, Root; int cas, n; void Pushup(int x) { tr[x].siz = tr[tr[x].s[0]].siz + tr[tr[x].s[1]].siz + 1; } void Pushdown(int x) { if(tr[x].flag) { swap(tr[x].s[0], tr[x].s[1]); tr[tr[x].s[0]].flag ^= 1; tr[tr[x].s[1]].flag ^= 1; tr[x].flag = 0; } } void Rotate(int x) { int y = tr[x].p, z = tr[y].p; int k = (tr[y].s[1] == x); tr[z].s[tr[z].s[1] == y] = x, tr[x].p = z; tr[y].s[k] = tr[x].s[k ^ 1], tr[tr[x].s[k ^ 1]].p = y; tr[x].s[k ^ 1] = y, tr[y].p = x; Pushup(y), Pushup(x); } void Splay(int x, int goal) { while(tr[x].p != goal) { int y = tr[x].p, z = tr[y].p; if(z != goal) { if((tr[z].s[1] == y) ^ (tr[y].s[1] == x)) Rotate(x); else Rotate(y); } Rotate(x); } if(goal == 0) Root = x; } void Insert(int v) { int u = Root, p = 0; while(u) { p = u, u = tr[u].s[v &gt; tr[u].v]; } u = ++idx; if(p) { tr[p].s[v &gt; tr[p].v] = u; } tr[u].init(v, p); Splay(u, 0); } int getValByRank(int rk) { int u = Root; while(true) { Pushdown(u); if(tr[tr[u].s[0]].siz &gt;= rk) u = tr[u].s[0]; else if(tr[tr[u].s[0]].siz == rk - 1) return u; else rk -= (tr[tr[u].s[0]].siz + 1), u = tr[u].s[1]; } return -1; } void Output(int u) { //è¿™ä¸€æ­¥æ˜¯ç¿»è½¬ Pushdown(u); //ä»uå¼€å§‹ä¸­åºéå† //å·¦ if(tr[u].s[0]) Output(tr[u].s[0]); //åˆ¤å®šå“¨å…µ, è¾“å‡ºå½“å‰ç»“ç‚¹ if(tr[u].v &gt;= 1 &amp;&amp; tr[u].v &lt;= n) cout &lt;&lt; tr[u].v &lt;&lt; ' '; //å³ if(tr[u].s[1]) Output(tr[u].s[1]); } int main() { cin &gt;&gt; n &gt;&gt; cas; for(int i = 0; i &lt;= n + 1; ++i) { //æ’å…¥å“¨å…µé˜²æ­¢è¶Šç•Œ Insert(i); } while(cas--) { int l, r; cin &gt;&gt; l &gt;&gt; r; l = getValByRank(l), r = getValByRank(r + 2); Splay(l, 0), Splay(r, l); tr[tr[r].s[0]].flag ^= 1; } Output(Root); return 0; } //å¯¹é›¶åŸºç¡€å³ä¸ºå‹å¥½ #include &lt;iostream&gt; const int N = 1e6; using namespace std; struct Node { int v, p, s[2], siz; bool flag; void init(int _v, int _p) { v = _v, p = _p; siz = 0; } }; Node tr[N]; int n, cas, Root, idx; /* * ä¸€äº›å®å®šä¹‰, ç”¨æ³•ç®€å•æ˜äº†, è·Ÿä¸€å¤§å †æ‚ä¹±æ— ç« çš„ä¸­æ‹¬å·è¯´å†è§!!! * ex. node(x).init(v, p) //åˆå§‹åŒ–ç»“ç‚¹xçš„å±æ€§v, p * siz(left(x)) //è·å–ç»“ç‚¹xçš„å·¦å­èŠ‚ç‚¹size * siz(node(x).ls) //å¦ä¸€ç§å†™æ³• */ #define ls s[0] #define rs s[1] #define isRoot(x) (x == 0) #define BST_getPos(fa, val) tr[fa].s[(val) &gt; tr[(fa)].v] //åœ¨faç»“ç‚¹ä¸‹é¢æ ¹æ®BSTæ€§è´¨æ’å…¥ä¸€ä¸ªå€¼ä¸ºvalçš„ç»“ç‚¹, åˆ¤å®šç»“ç‚¹ä½ç½®(å³: è¦æ’åœ¨å“ªé‡Œ) #define node(x) tr[(x)] //å¯ä»¥ç†è§£ä¸ºxå·ç»“ç‚¹çš„å¯¹è±¡, æ–¹ä¾¿ä½¿ç”¨ls, rs #define left(x) tr[(x)].s[0] #define right(x) tr[(x)].s[1] #define val(x) tr[(x)].v #define siz(x) tr[(x)].siz #define flag(x) tr[(x)].flag #define pa(x) tr[(x)].p #define son(fa, x) tr[(fa)].s[(x)] //è·å–ç»“ç‚¹façš„å„¿å­, å‚æ•°xä¸ºå·¦å³, å·¦0å³1 #define LoR(fa, x) (tr[(fa)].s[1] == (x)) //L or R, xæ˜¯façš„å“ªä¸ªå„¿å­ void Pushup(int x) { siz(x) = siz(left(x)) + siz(right(x)) + 1; } void Pushdown(int x) { if(flag(x)) { swap(left(x), right(x)); flag(left(x)) ^= 1; flag(right(x)) ^= 1; flag(x) = 0; } } void Rotate(int x) { int y = pa(x), z = pa(y); int k = LoR(y, x); son(z, LoR(z, y)) = x, pa(x) = z; son(y, k) = son(x, k ^ 1), pa(son(x, k ^ 1)) = y; son(x, k ^ 1) = y, pa(y) = x; Pushup(y), Pushup(x); } void Splay(int x, int goal) { while(pa(x) != goal) { int y = pa(x), z = pa(y); if(z != goal) { if(LoR(z, y) ^ LoR(y, x)) { Rotate(x); } else { Rotate(y); } } Rotate(x); } if(isRoot(goal)) Root = x; } void Insert(int v) { int u = Root, p = 0; while(u) { p = u, u = BST_getPos(u, v); } u = ++idx; if(!isRoot(p)) { BST_getPos(p, v) = u; } node(u).init(v, p); Splay(u, 0); } int getValByRank(int rk) { int u = Root; while(true) { Pushdown(u); if(siz(left(u)) &gt;= rk) u = left(u); else if(siz(left(u)) == rk - 1) return u; else rk -= siz(left(u)) + 1, u = right(u); } return -1; } void Output(int x) { Pushdown(x); if(left(x)) Output(left(x)); if(val(x) &gt;= 1 &amp;&amp; val(x) &lt;= n) cout &lt;&lt; val(x) &lt;&lt; ' '; if(right(x)) Output(right(x)); } int main() { cin &gt;&gt; n &gt;&gt; cas; for(int i = 0; i &lt;= n + 1; ++i) { Insert(i); } while(cas--) { int l, r; cin &gt;&gt; l &gt;&gt; r; l = getValByRank(l), r = getValByRank(r + 2); Splay(l, 0), Splay(r, l); flag(left(r)) ^= 1; } Output(Root); puts(\"\"); return 0; } æ™®é€šå¹³è¡¡æ ‘(Luogu P3369) å®ç°å¢, åˆ , æŸ¥è¯¢æ’åä¸åæŸ¥, æŸ¥è¯¢å‰é©±ä¸åç»§åŠŸèƒ½. Solution1: std::vector #include &lt;vector&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; vector&lt;int&gt; v; int cas; int main() { cin &gt;&gt; cas; while(cas--) { int op, x; cin &gt;&gt; op &gt;&gt; x; switch(op) { case 1: //insert(x) v.insert(lower_bound(v.begin(), v.end(), x), x); break; case 2: //delete(x) v.erase(lower_bound(v.begin(), v.end(), x)); break; case 3: //getRank(x) cout &lt;&lt; lower_bound(v.begin(), v.end(), x) - v.begin() + 1 &lt;&lt; endl; break; case 4: //getValueByRank(x) cout &lt;&lt; v[x - 1] &lt;&lt; endl; break; case 5: //getPre(x) cout &lt;&lt; *--lower_bound(v.begin(), v.end(), x) &lt;&lt; endl; break; case 6: //getNxt(x) cout &lt;&lt; *lower_bound(v.begin(), v.end(), x + 1) &lt;&lt; endl; break; } } return 0; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"äºŒåˆ†","slug":"äºŒåˆ†","date":"2022-02-20T12:53:53.000Z","updated":"2022-02-20T12:56:05.619Z","comments":true,"path":"2022/02/20/äºŒåˆ†/","link":"","permalink":"https://ret2libc-pwned.github.io/2022/02/20/%E4%BA%8C%E5%88%86/","excerpt":"","text":"äºŒåˆ† äºŒåˆ†æŸ¥æ‰¾ ç»™å®šä¸€ä¸ªåºåˆ—\\(\\{a\\}\\), æŸ¥æ‰¾æŒ‡å®šå…ƒç´ \\(x\\)ä½ç½®. ä»£ç å®ç° int bsearch(int* a, int x, int l, int r) { while(l &lt; r) { int mid = l + (r - l &gt;&gt; 1); if(a[mid] &gt;= x) r = mid; else l = mid + 1; } return a[l] == x ? l : -1; } äºŒåˆ†ç­”æ¡ˆ å•è°ƒåŒºé—´å†…é«˜æ•ˆåœ°æŸ¥æ‰¾æœ€ä¼˜ç­”æ¡ˆ, å¯ä»¥çœ‹ä½œ\"æšä¸¾\"çš„ä¼˜åŒ–. å¸¸ç”¨æ¥è§£å†³\"æœ€å¤§å€¼æœ€å°åŒ–\"é—®é¢˜. Luogu P1873 ç æ ‘ å¦‚æœæšä¸¾\\([1, 1\\times 10^9]\\)ä¼šè¶…æ—¶, ä½¿ç”¨äºŒåˆ†ç­”æ¡ˆ. #include &lt;iostream&gt; typedef long long LL; const int N = 1e6; using namespace std; int n; LL a[N], m; bool isValid(LL height) { LL got = 0; for(int i = 0; i &lt; n; ++i) { got += max(a[i] - height, 0ll); } return got &gt;= m; } int main() { cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; ++i) { cin &gt;&gt; a[i]; } int l = 1, r = 1e9 + 1; //é—­åˆçš„åŒºé—´, 1e9éœ€è¦åŠ ä¸€ while(l + 1 &lt; r) { //l, rä¸èƒ½ç›¸é‚» int mid = l + (r - l &gt;&gt; 1); if(isValid(mid)) { l = mid; } else { r = mid; } } cout &lt;&lt; l &lt;&lt; endl; return 0; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"https://ret2libc-pwned.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"FREE-Figurines","slug":"FREE-Figurines","date":"2021-12-04T14:18:52.000Z","updated":"2021-12-04T14:20:43.140Z","comments":true,"path":"2021/12/04/FREE-Figurines/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/12/04/FREE-Figurines/","excerpt":"","text":"#include &lt;iostream&gt; const int N = 1e6; using namespace std; /* ä¸¤ç§æ“ä½œ: æ¥åœ¨åé¢ / åˆ é™¤æœ€å‰é¢. æœ€å·®æƒ…å†µ: \"é‡ç»„\", å³å…¨éƒ¨åˆ äº†å†æ‹¼èµ·æ¥. éœ€è¦2næ¬¡æ“ä½œ. ä¼˜åŒ–: å°¾å·´ä¸Šçš„èŠ‚ç‚¹ä¸éœ€è¦æ“ä½œ. å¯ä»¥ç»Ÿè®¡æœ‰å¤šå°‘ä¸ªè¿™ç§èŠ‚ç‚¹, å‡å»èŠ‚ç‚¹æ•° * 2å³å¯. */ int src[N], dest[N], len[N], n, ans; bool vis[N]; inline void debug() { printf(\"ans = %d\\n\", ans); } int main() { cin &gt;&gt; n; /*é¢„å¤„ç†, ç»Ÿè®¡æœ€åæƒ…å†µans*/ for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; src[i]; vis[src[i]] = true; if(src[i]) ans++; } for(int i = 1; i &lt;= n; i++) { cin &gt;&gt; dest[i]; vis[dest[i]] = true; if(dest[i]) ans++; } for(int i = 1; i &lt;= n; i++) { if(!vis[i]) { int tmpi = i; while(src[tmpi] * dest[tmpi] &amp;&amp; src[tmpi] == dest[tmpi]) { //ä¸ä¸ºè‡ªç”±çš„ &amp;&amp; ç›¸ç­‰å°±æ˜¯ä¸ç”¨æ–­å¼€çš„é“¾ ans -= 2; tmpi = src[tmpi]; } } } cout &lt;&lt; ans &lt;&lt; endl; return 0; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"POI2010 - TESIntelligence Test","slug":"POI2010-TESIntelligence-Test","date":"2021-11-21T13:01:04.000Z","updated":"2021-11-21T13:02:47.638Z","comments":true,"path":"2021/11/21/POI2010-TESIntelligence-Test/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/11/21/POI2010-TESIntelligence-Test/","excerpt":"","text":"#include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; const int N = 1e6; #define YES puts(\"TAK\") #define NO puts(\"NIE\"); int len, tc; vector&lt;int&gt; nxt[N]; //æ€è·¯ å¼€äºŒç»´vectorå­˜ä¸€å †æŒ‡é’ˆ nxt[x][y]å°±æ˜¯æ•°å­—xå‡ºç°çš„ç¬¬yæ¬¡çš„ä½ç½®. //vectoråŠ¨æ€å¼€å†…å­˜ ä¸ä¼šçˆ†ç©ºé—´. //äºŒåˆ†å»æ‰¾\"æ•°å­—kå‡ºç°ç¬¬xæ¬¡çš„ä½ç½®\", å®ç°\"å¿«é€Ÿè·³è½¬\". int bsearch(int num, int expected_pos) { int l = 0, r = nxt[num].size() - 1, res = len + 1; while(l &lt;= r) { int mid = (l + r) &gt;&gt; 1; if(nxt[num][mid] &gt; expected_pos) { r = mid - 1; res = mid; } else l = mid + 1; } //return nxt[num][res]; return (res == len + 1 ? res : nxt[num][res]); } int main() { ios_base::sync_with_stdio(false); cin.tie(0); cin &gt;&gt; len; for(int i = 1; i &lt;= len; i++) { int tmp; cin &gt;&gt; tmp; nxt[tmp].push_back(i); } cin &gt;&gt; tc; while(tc--) { int l, a[N]; cin &gt;&gt; l; bool flag = true; int pos = 0; for(int i = 1; i &lt;= l; i++) cin &gt;&gt; a[i]; for(int i = 1; i &lt;= l; i++) { pos = bsearch(a[i], pos); //fprintf(stderr, \"a[%d] = %d,\\tpos = %d\\n\", i, a[i], pos); if(pos &gt; len) { flag = 0; break; } } flag ? YES : NO; } return 0; }","categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-10-06T06:53:59.209Z","updated":"2021-10-17T09:07:02.605Z","comments":true,"path":"2021/10/06/hello-world/","link":"","permalink":"https://ret2libc-pwned.github.io/2021/10/06/hello-world/","excerpt":"","text":"å¦‚é¢˜, è¿™æ˜¯æˆ‘çš„ç¬¬ä¸€ç¯‡æ–‡ç« .","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"OI","slug":"OI","permalink":"https://ret2libc-pwned.github.io/tags/OI/"},{"name":"æ•°æ®ç»“æ„","slug":"æ•°æ®ç»“æ„","permalink":"https://ret2libc-pwned.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","permalink":"https://ret2libc-pwned.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"é¢˜è§£","slug":"é¢˜è§£","permalink":"https://ret2libc-pwned.github.io/tags/%E9%A2%98%E8%A7%A3/"}]}