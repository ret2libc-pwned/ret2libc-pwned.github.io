<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>OI中的数学知识</title>
    <link href="/2022/10/15/OI%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/10/15/OI%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这也是暑假没填的坑……</p><h1 id="数学复习">数学复习</h1><h2 id="运算优化">运算优化</h2><h3 id="快速幂">快速幂</h3><p>整数可以表达为若干个 2 的整数次幂之和, 即<strong>可以"二进制拆分"</strong>. (该性质应用广泛, 例如树状数组).同样的道理, 我们也能拆分指数, 实现快速幂. 形式化地说:<code>$a^b=\sum _{i=0} ^{k-1} a^{{c_i}\cdot 2i}\ \ \  (k =  \lceil\log (b + 1)\rceil)</code>.(Hexo渲染不了，请自行复制到可以渲染 <span class="math inline">\(\LaTeX\)</span> 的地方查看) 实现过程为从低到高取<span class="math inline">\(b\)</span> 二进制中的每一位 <span class="math inline">\(c_i\)</span> , 若当前位是 <span class="math inline">\(1\)</span> 则将最终答案乘上 <span class="math inline">\(a\)</span> (可以理解为把落单的 <span class="math inline">\(a\)</span> 乘上去), 然后将 <span class="math inline">\(a\)</span> 平方.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> k)</span> </span>{<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">1</span> % mod;<br>    <span class="hljs-keyword">for</span>(; k; x = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)x * x % mod, k &gt;&gt;= <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) res = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)res * x;<br>    }<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h3 id="快速乘">快速乘</h3><p>类比快速幂的二进制拆分思想, 把累"乘"变成累加即可. 注意它们的区别!!!例如 <code>res</code> 应初始为 <span class="math inline">\(0\)</span>等.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function">LL <span class="hljs-title">mul</span><span class="hljs-params">(LL a, LL b, LL p)</span> </span>{<br>    <span class="hljs-comment">// a*b mod p</span><br>    LL res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(; b; a = (a &lt;&lt; <span class="hljs-number">1</span>) % p, b &gt;&gt;= <span class="hljs-number">1</span>) {<br>        <span class="hljs-keyword">if</span>(b &amp; <span class="hljs-number">1</span>) res = ((LL)res + a) % p;<br>    }<br>    <span class="hljs-keyword">return</span> res;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h2 id="数论">数论</h2><p>Todo.</p><h2 id="线性代数">线性代数</h2><p>对于矩阵 <span class="math inline">\(A\)</span>,<strong>主对角线</strong> 指的是 <span class="math inline">\(A_{i,i}\)</span> 的元素.</p><p>主对角线为 <span class="math inline">\(1\)</span>, 其他元素为 <span class="math inline">\(0\)</span> 的矩阵称为 <strong>单位矩阵</strong>.任何一个矩阵乘以单位矩阵的结果是自己本身, 类似于数字乘法中 <span class="math inline">\(1\)</span> 的作用.</p><h4 id="矩阵运算">矩阵运算</h4><h5 id="加法">加法</h5><p>设矩阵 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(M\)</span> 行 <span class="math inline">\(N\)</span> 列的矩阵, <span class="math inline">\(B\)</span> 是 <span class="math inline">\(M\)</span> 行 <span class="math inline">\(N\)</span> 列的矩阵, <span class="math inline">\(C= A + B\)</span>. (<span class="math inline">\(C\)</span> 有 <span class="math inline">\(M\)</span> 行 <span class="math inline">\(N\)</span> 列) 则: <span class="math display">\[C_{i,j} = A_{i, j} + B_{i, j}\]</span></p><h5 id="乘法">乘法</h5><p>设矩阵 <span class="math inline">\(A\)</span> 是 <span class="math inline">\(M\)</span> 行 <span class="math inline">\(N\)</span> 列的矩阵, <span class="math inline">\(B\)</span> 是 <span class="math inline">\(N\)</span> 行 <span class="math inline">\(Q\)</span> 列的矩阵, <span class="math inline">\(C= A \cdot B\)</span>. (<span class="math inline">\(C\)</span> 有 <span class="math inline">\(M\)</span> 行 <span class="math inline">\(Q\)</span> 列) 则: <span class="math display">\[C_{i,j} = \sum_{k=1}^{N} A_{i, k} \cdot B_{k, j}\]</span> 例如: <span class="math display">\[\begin{bmatrix}2 &amp; 1 &amp; 4\\0 &amp; 1 &amp; 1\\end{bmatrix} \cdot\begin{bmatrix}6 &amp; 3 &amp; -1 &amp; 0\\1 &amp; 1 &amp; 0 &amp; 4\\-2 &amp; 5 &amp; 0 &amp; 2\end{bmatrix}=\begin{bmatrix}5 &amp; 27 &amp; -2 &amp; 12 \\-1 &amp; 6 &amp; 0 &amp; 6\end{bmatrix}\]</span> 矩阵乘法满足结合律, <strong>不满足交换律</strong>.(因为要保证第一个矩阵的行数等于第二个矩阵的列数).</p><h4 id="模板代码">模板代码</h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SIZ = <span class="hljs-number">18</span>, MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Matrix</span> {</span><br><span class="hljs-keyword">int</span> a[SIZ][SIZ];<br><span class="hljs-built_in">Matrix</span>() {<br><span class="hljs-built_in">memset</span>(a, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> a);<br>}<br>Matrix <span class="hljs-keyword">operator</span> +(<span class="hljs-keyword">const</span> Matrix&amp; B) {<br>Matrix res;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= SIZ; ++i) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j = SIZ; ++j) {<br>res.a[i][j] = (a[i][j] + B.a[i][j]) % MOD;<br>}<br>}<br><span class="hljs-keyword">return</span> res;<br>}<br>Matrix <span class="hljs-keyword">operator</span> -(<span class="hljs-keyword">const</span> Matrix&amp; B) {<br>Matrix res;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= SIZ; ++i) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j = SIZ; ++j) {<br>res.a[i][j] = (a[i][j] - B.a[i][j]) % MOD;<br>}<br>}<br><span class="hljs-keyword">return</span> res;<br>}<br>Matrix <span class="hljs-keyword">operator</span> *(<span class="hljs-keyword">const</span> Matrix&amp; B) {<br>Matrix res;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= SIZ; ++i) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= SIZ; ++j) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= SIZ; ++k) {<br>res.a[i][j] += (LL)(a[i][k] * B.a[k][j]);<br>res.a[i][j] %= MOD;<br>}<br>}<br>}<br><span class="hljs-keyword">return</span> res;<br>}<br>};<br><span class="hljs-function">Matrix <span class="hljs-title">pow</span><span class="hljs-params">(Matrix x, <span class="hljs-keyword">int</span> k)</span> </span>{<br>Matrix res;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= SIZ; ++i) res.a[i][i] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= SIZ; ++i) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= SIZ; ++j) {<br>x.a[i][j] %= MOD;<br>}<br>} <br><span class="hljs-keyword">for</span>(; k; k &gt;&gt;= <span class="hljs-number">1</span>) {<br><span class="hljs-keyword">if</span>(k &amp; <span class="hljs-number">1</span>) res = res * x;<br>x = x * x;<br>}<br><span class="hljs-keyword">return</span> res;<br>}<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">// a * b</span><br>Matrix a, b;<br><span class="hljs-keyword">int</span> n, m, q;<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) {<br>cin &gt;&gt; a.a[i][j];<br>}<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= q; ++j) {<br>cin &gt;&gt; b.a[i][j];<br>}<br>}<br>Matrix c = a * b;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= q; ++j) {<br>cout &lt;&lt; c.a[i][j] &lt;&lt; <span class="hljs-string">' '</span>;<br>}<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h4 id="矩阵加速递推">矩阵加速递推</h4><h4 id="矩阵变换">矩阵变换</h4><h5 id="初等行变换">初等行变换</h5><p>初等行变换包含:</p><ul><li>互换某两行;</li><li>将某一行向量乘上非零实数 <span class="math inline">\(\lambda\)</span> ;</li><li>将某一行向量与另一行向量相加.</li></ul><h4 id="高斯消元">高斯消元</h4><h5 id="求解线性方程组">求解线性方程组</h5><h5 id="求解异或方程组">求解异或方程组</h5>]]></content>
    
    
    <categories>
      
      <category>OI笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假OI十日训练记录</title>
    <link href="/2022/10/15/%E6%9A%91%E5%81%87OI%E5%8D%81%E6%97%A5%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/10/15/%E6%9A%91%E5%81%87OI%E5%8D%81%E6%97%A5%E8%AE%AD%E7%BB%83%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>暑假里曾经心血来潮想练 OI ,计划着每天花一下午练习然后在这个文档里打卡记录, 记了十天然后发现 Typora太卡了, 自己效率还很低, 就没坚持下去. 这个文档还有很多题目没补完!</p><p>我现在 OI 还什么都不会, 就是因为三分钟热度, 学得太少、练得太少,还走了很多弯路. 今天把这个文档从旧电脑里翻出来放在 Cheatsheet上面提醒一下自己, 不能再这样了!!!</p><p>下面是文档原文, 计划里的东西都没怎么完成, 到最后完全放弃了......这一定是一个教训!</p><h2 id="计划">计划</h2><p>周一到周五下午: <strong>做题</strong>.</p><ol type="1"><li><a href="https://www.acwing.com/activity/content/6/">《算法竞赛进阶指南》</a>完成并打卡;</li><li><a href="https://oi-wiki.org/">OI Wiki</a>相关例题;</li><li>Luogu 相关题单.</li></ol><p>周末下午: <strong>CF VP(2 ~ 2.5h)</strong>. 打完后 <strong>订正 +题解</strong>.</p><p>一周保证 20+ 小时的有效做题 / 比赛时间 (指能写代码的时间,不含上课等).</p><h2 id="记录">记录</h2><p>此处应包含 <strong>日期、练习内容、简单题解、备注</strong>等记录.</p><p>以下是一个示例:</p><figure class="highlight markdown"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section">### 1970-01-01</span><br><br><span class="hljs-section">#### 练习内容</span><br><br><span class="hljs-bullet">1.</span> P1001 A + B<br><br><span class="hljs-section">#### 简单题解</span><br><br>这是一道模拟题, 读入两个整数 $a、b$ , 输出它们的和即可.<br><br><span class="hljs-section">#### 备注</span><br><br>可以使用 <span class="hljs-code">`(a &amp; b) + (a | b)`</span> 高性能地实现.<br></code></pre></div></td></tr></tbody></table></figure><h3 id="section">2022-06-30</h3><h4 id="练习内容">练习内容</h4><ol type="1"><li>acw171 送礼物 <span class="math inline">\(88 \to 100\)</span>.</li></ol><h4 id="简单题解">简单题解</h4><ol type="1"><li>类似0/1背包, 但是DP做法空间开销太大, 考虑用双向DFS进行子集和枚举.即: 将 <code>g[]</code> 一分为二 (经试验, 分为 <span class="math inline">\([1, n / 2 + 2]\)</span> 与 <span class="math inline">\([n/2 + 3, n]\)</span> 最快), 分别搜索. 写两个<code>dfs</code> 函数,一个搜索前半部分选取若干礼物能凑出重量的所有可能值, 存入数组<code>pre[]</code>. 另一个在后半部分二分搜等于或小于<code>w - pre[i]</code> 的最大值(即前驱). 可以在执行第一个<code>dfs</code> 前降序排序 <code>g[]</code>, 保证大的重量先被选到,这是一个剪枝.</li></ol><h4 id="备注">备注</h4><ol type="1"><li>双向搜索时, 选取合适的 <strong>折半点</strong> 有时是一个优化方法;在二分时, 可以使用 <code>algorithm</code> 库中的<code>*std::lower_bound(a.begin(), a.end(), val)</code> 查询<code>val</code> 前驱,<code>*--std::lower_bound(a.begin(), a.end(), val)</code> 查询后继.</li></ol><h3 id="正式开始">2022-07-01 (正式开始!!!)</h3><h4 id="练习内容-1">练习内容</h4><ol type="1"><li>蓝书<ul><li>acw89 a^b</li><li>acw90 64位整数乘法</li><li>acw91 最短Hamilton路径</li><li>Todo acw998 起床困难综合症</li></ul></li></ol><h4 id="简单题解-1">简单题解</h4><h5 id="ab快速幂">a^b(快速幂)</h5><p>整数可以表达为若干个 2 的整数次幂之和, 即<strong>可以"二进制拆分"</strong>. (该性质应用广泛, 例如树状数组).同样的道理, 我们也能拆分指数, 实现快速幂.形式化地说:<code>$a^b=\sum _{i=0} ^{k-1} a^{{c_i}\cdot 2i}$   $(k =  \lceil\log (b + 1)\rceil)$</code>（Hexo不能渲染，请自行复制到能渲染 <span class="math inline">\(\LaTeX\)</span> 的编辑器（如 Typora、MathType等）查看） . 实现过程为从低到高取 <span class="math inline">\(b\)</span>二进制中的每一位 <span class="math inline">\(c_i\)</span> , 若当前位是<span class="math inline">\(1\)</span> 则将最终答案乘上 <span class="math inline">\(a\)</span> (可以理解为把落单的 <span class="math inline">\(a\)</span> 乘上去), 然后将 <span class="math inline">\(a\)</span> 平方.</p><h5 id="位整数乘法">64位整数乘法</h5><p>类比快速幂的二进制拆分思想, 把累"乘"变成累加即可. 注意它们的区别!!!例如 <code>res</code> 应初始为 <span class="math inline">\(0\)</span>等.</p><h5 id="最短hamilton路径">最短Hamilton路径</h5><p>这一题的 BF 解法: 枚举点的全排列取最短, 状态数量 <span class="math inline">\(\mathcal O(n!\cdot n)\)</span> . <span class="math inline">\(n = 20\)</span>, 时限 5s, 过不了.</p><p>考虑状态定义, 需要记录:</p><ol type="1"><li>走过哪些点;</li><li>当前处于哪一个点.</li></ol><p>考虑状压 DP . 即将 0/1 状态压缩到一个整数中,使得可以通过状态调用子问题答案.</p><p>设 <span class="math inline">\(f_{st, u}\)</span> 为当前走到 <span class="math inline">\(u\)</span> 号点, 走过与否的局面为 0/1 集合 <span class="math inline">\(\{st\}\)</span> .</p><p>则: <span class="math display">\[f_{st, u} = \min _{0 \le v \le n - 1} \{f_{st_v, v} + dis_{u, v}\}\\\]</span> 其中 <span class="math inline">\(st_v\)</span> 为 <span class="math inline">\(st\)</span> 除去 <span class="math inline">\(u\)</span> 得到的状态集合. 可以使用位运算<code>st ^ (1 &lt;&lt; u)</code> 得到.</p><p>现在枚举 <span class="math inline">\(st\)</span>(<code>[0, 1 &lt;&lt; n - 1]</code>, 即全 <span class="math inline">\(0\)</span> 到全 <span class="math inline">\(1\)</span>)、点<span class="math inline">\(u,v\)</span>, 即可. 注意状态是否合法(代码中 <code>if</code> 语句).时间复杂度 <span class="math inline">\(\mathcal O(n^2 \cdot2^n)\)</span> .</p><h4 id="备注-1">备注</h4><p>效率还要再高一点.</p><h3 id="section-1">2022-07-02</h3><h4 id="练习内容-2">练习内容</h4><ol type="1"><li>CF1698 VP (200 pts)</li><li>acw几道水题<ul><li>递归实现指数 / 排列 / 组合型枚举</li></ul></li></ol><h4 id="简单题解-2">简单题解</h4><h5 id="a.-xor-mixup">A. XOR Mixup</h5><p>枚举即可. 比赛时一开始不知道本题有 SPJ,所以看到输出与样例不一样就卡了好久.</p><h5 id="b.-rising-sand">B. Rising Sand</h5><p>对于任意一个区间, 选取多个数 <span class="math inline">\(+1\)</span>对原答案无贡献(因为不能将一个数从"不高"到"高"). 但是有一种特例:选取单个数 <span class="math inline">\(+1\)</span> .因为可以有多次操作(刚开始没看到!), 所以当 <span class="math inline">\(k= 1\)</span> 时, 答案必为"被夹在中间的元素数量", 即 <span class="math inline">\(\dfrac{n-1}{2}\)</span> .</p><h5 id="c.-3sum-closure">C. 3SUM Closure</h5><p>题看错了! 题意为: <strong>任意</strong> 三元组的和都能在原序列中找到,不是找到一个就行了.</p><h5 id="dfs实现枚举">DFS实现枚举</h5><p>将状态抽象成一棵搜索树即可, 想想自顶向下遍历时需要传递什么信息?回溯上来时需要改变什么为后续搜索做准备? 以及其它类似问题.</p><h4 id="备注-2">备注</h4><p>第一次打 CF, 不太熟悉.</p><p>主要问题如下:</p><ol type="1"><li>没注意题目的细节. 在 A、B、C 中都有这个问题, 导致了浪费时间;</li><li>认为只要修改代码就能碰运气输出正确答案,导致不重视思考甚至题目的理解;</li><li>下次看到"输出正确的一个就算对"这类字眼就要知道这题大概率用了SPJ.</li></ol><h3 id="section-2">2022-07-03</h3><h4 id="练习内容-3">练习内容</h4><ol type="1"><li>CF1700 VP;</li></ol><h4 id="简单题解-3">简单题解</h4><h5 id="a.-optimal-path">A. Optimal Path</h5><p><strong>(贪心)</strong> 横着走的代价是 <span class="math inline">\(1\)</span> , 竖着走的代价是 <span class="math inline">\(m\)</span>. 所以先从 <span class="math inline">\((1, 1)\)</span> 走到 <span class="math inline">\((1, m)\)</span>, 再往下走到 <span class="math inline">\((n, m)\)</span>.</p><p><span class="math inline">\(\mathcal O(1)\)</span> 计算, 答案即为:<span class="math display">\[\dfrac{(1 + m)m}{2} + \dfrac{m(2 + n)(n -1)}{2} \]</span> .</p><h5 id="b.-palindromic-numbers">B. Palindromic Numbers</h5><p><strong>(构造) </strong>对于首位非 <span class="math inline">\(9\)</span> 的情况, 构造 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(9\)</span> 组成的数即可; 对于首位是 <span class="math inline">\(9\)</span> 的情况, 构造 <span class="math inline">\((n + 1)\)</span> 个 <span class="math inline">\(1\)</span> 即可.</p><p>注意 <span class="math inline">\(n \le 10^5\)</span>,需要高精减法.</p><h5 id="c.-helping-the-nature">C. Helping the Nature</h5><p><strong>(差分)</strong> 求出序列的差分数组 <span class="math inline">\(b\)</span> ,</p><h5 id="d.">D.</h5><p>可以发现, 最优构造一定是把所有水管放在最前面的连续一段.否则后面的水都溢出来了前面的还没满.</p><p><strong>(Solution 1: 二分)</strong> ==Todo==</p><p><strong>(Solution 2: 数学)</strong> 记 <span class="math inline">\(\sum _{j = 1} ^{i} v_i = s_i\)</span> ,按照上述的构造方法, 开前 <span class="math inline">\(i\)</span>个水管把前 <span class="math inline">\(i\)</span> 个容器灌满的时间为<span class="math inline">\(t_i = \lceil \dfrac{s_i}{i} \rceil\)</span>. 我们可以求出 <span class="math inline">\(\max\{t_i\}\)</span> 即为<span class="math inline">\(t\)</span> 的下界. 如果询问中的 <span class="math inline">\(t\)</span> 小于这个下界即可判定无解, 否则答案为<span class="math inline">\(\lceil \dfrac{s_n}{t} \rceil\)</span> .</p><h5 id="e.-serega-the-pirate">E. Serega the Pirate</h5><h4 id="备注-3">备注</h4><ol type="1"><li>在计算 <code>ceil(p / q)</code> 时, 可以这样:<code>(p + q - 1) / q</code>.</li></ol><h3 id="section-3">2022-07-04</h3><h4 id="练习内容-4">练习内容</h4><ol type="1"><li>订正两场CF, 补充简单题解.</li></ol><h4 id="简单题解-4">简单题解</h4><p>主要是后面几道题, 已经补充.</p><h4 id="备注-4">备注</h4><p>无.</p><h3 id="section-4">2022-07-05</h3><h4 id="练习内容-5">练习内容</h4><ol type="1"><li>继续订正;</li><li>acw164 可达性统计.</li></ol><h4 id="简单题解-5">简单题解</h4><p>订正题解已补.</p><h5 id="可达性统计">可达性统计</h5><p>图 <span class="math inline">\(G = (V, E)\)</span> 中, 顶点 <span class="math inline">\(u\)</span> 可达顶点的集合为: <span class="math display">\[f(u) = \{u\} \cup \{\bigcup_{(u, v) \in E} f(v)\}\]</span> 其中, 集合 <span class="math inline">\(f(u)\)</span> 可以用<span class="math inline">\(n\)</span> 个 0/1状态表示对于各个顶点是否可达. 尝试状态压缩, 取并运算即为按位或.最后每个结点的集合 <span class="math inline">\(f\)</span> 中 1的个数即为所求.</p><p>我们可以发现上式的递推性质, 即需要通过 <span class="math inline">\(u\)</span> 的相邻结点更新 <span class="math inline">\(f(u)\)</span> . 如何做到<strong>通过先访问的结点更新后访问的结点的状态</strong> 呢? 答案是<strong>拓扑排序</strong>. 预处理拓扑序列, 倒序访问序列中每一个结点,并向前递推更新即可.</p><h4 id="备注-5">备注</h4><ol type="1"><li>状压时要看清楚数据范围, 合理选择用(32位? 64位? (Linux下)128位?)整数压还是用bitset压, 这一题 <span class="math inline">\(n、m \le30000\)</span>, 考虑使用 bitset.</li></ol><h3 id="section-5">2022-07-06</h3><h4 id="练习内容-6">练习内容</h4><ol type="1"><li><p>acw165 小猫爬山</p></li><li><p>Luogu P1605 迷宫</p></li><li><p>Luogu P1219 八皇后</p></li></ol><h4 id="简单题解-6">简单题解</h4><h5 id="小猫爬山">小猫爬山</h5><p>考虑使用 DFS . 用 <code>cab[]</code> 记录每辆缆车的重量. 使用<code>dfs(idx, cnt)</code> 求解第 <span class="math inline">\(idx\)</span> 只猫用了 <span class="math inline">\(cnt\)</span> 辆车的情况. 加两个剪枝:</p><ol type="1"><li><code>c[]</code> 从大到小排序, 使得重的猫 (较难装的)先被装进去;</li><li>当 <span class="math inline">\(cnt \gt ans\)</span> 时结束搜索.</li></ol><p>答案 <span class="math inline">\(ans\)</span> 初值设为最坏情况 <span class="math inline">\(n\)</span> , 即每只猫给一辆车的情况.</p><h5 id="迷宫回溯法模板">迷宫(回溯法模板)</h5><p><strong>回溯法简述:</strong> 在搜索时,我们有时需要给状态打上标记(如是否访问某个结点或当前状态的某个权值).这个标记可能会影响到后续搜索.例如这一题中在一条路径中被搜过的点在另一条路径还能走.这时就需要在回溯时清除或修改这个标记. 因为 DFS 的回溯是自底向上的,所以能够方便地清除搜索树中自根结点至叶结点路径上的标记.</p><p>参考实现如下:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(PII now)</span> </span>{<br>    <span class="hljs-keyword">if</span>(now == ed) {<br>        ++ans;<br>        <span class="hljs-keyword">return</span>;<br>    }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) {<br>        PII nxt = <span class="hljs-built_in">make_pair</span>(now.x + dx[i], now.y + dy[i]);<br>        <span class="hljs-keyword">if</span>(obs[nxt.x][nxt.y] || vis[nxt.x][nxt.y] || nxt.x &lt; <span class="hljs-number">1</span> || nxt.x &gt; n || nxt.y &lt; <span class="hljs-number">1</span> || nxt.y &gt; m) <span class="hljs-keyword">continue</span>;<br>        vis[nxt.x][nxt.y] = <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">dfs</span>(nxt);<br>        vis[nxt.x][nxt.y] = <span class="hljs-number">0</span>;<br>    }<br>}<br></code></pre></div></td></tr></tbody></table></figure><h5 id="八皇后">八皇后</h5><p>该题也是回溯法的一道例题. 难点在于如何判定对角线与平行线是否摆了棋子.设列为 <span class="math inline">\(x\)</span> , 行为 <span class="math inline">\(y\)</span> . 则对角线和平行线的方程为: <span class="math display">\[\begin{cases}\ell_1: y=-x+b_1,\\\ell_2: y=x+b_2\\\end{cases}\Rightarrow \begin{cases}b_1 = x + y,\\ b_2 = y - x\end{cases}\]</span> 可以使用截距 <span class="math inline">\(b_{1,2}\)</span>为关键字访问 <code>vis[]</code> 数组中对角线上的情况. 注意 <span class="math inline">\(b_2\)</span> 可能为负,所以在数组中统一加上大于等于 <span class="math inline">\(x,y\)</span> 的<span class="math inline">\(n\)</span> .</p><h4 id="备注-6">备注</h4><h3 id="section-6">2022-07-07</h3><h4 id="练习内容-7">练习内容</h4><ol type="1"><li>上课.</li></ol><h3 id="section-7">2020-07-08</h3><h4 id="练习内容-8">练习内容</h4><ol type="1"><li>搜索补题.</li></ol><h3 id="section-8">2020-07-09</h3><h4 id="练习内容-9">练习内容</h4><ol type="1"><li>CF 1699 vp</li></ol><h4 id="简单题解-7">简单题解</h4><h5 id="a.-the-third-three-number-problem">A. The Third Three NumberProblem</h5><p><strong>(构造)</strong> 可以发现异或运算的性质: <span class="math inline">\(x \oplus x = 0, 0 \oplus x = x\)</span>.可以构造出 <span class="math inline">\(\{\dfrac n 2, 0, 0\}\)</span>或者是 <span class="math inline">\(\{\dfrac n 2, \dfrac n 2,0\}\)</span>.</p><h5 id="b.-almost-ternary-matrix">B. Almost Ternary Matrix</h5><p><strong>(构造)</strong> 答案是如下的矩阵 <strong>旋转</strong>而成的:</p><figure class="highlight basic"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><br></code></pre></div></td></tr></tbody></table></figure><p>所以可以构造出下图的矩阵来:</p><p><img src="https://codeforces.com/predownloaded/75/c4/75c46e19cc3cf6f890139b0e74774c3a6fc387db.png" alt="img" style="zoom:50%;"></p><p>注：赛时想到的如下：</p><figure class="highlight apache"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-attribute">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-attribute">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span><br><span class="hljs-attribute">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br></code></pre></div></td></tr></tbody></table></figure><h5 id="c.-the-third-problem">C. The Third Problem</h5><p>根据定义, 有: <span class="math inline">\(\operatorname{MEX}(P) =\min\{\complement_{\mathbb N^*} P\}\)</span>.</p><h4 id="备注-7">备注</h4>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>初三一模数学练习一</title>
    <link href="/2022/10/01/%E5%88%9D%E4%B8%89%E4%B8%80%E6%A8%A1%E6%95%B0%E5%AD%A6%E7%BB%83%E4%B9%A0%E4%B8%80/"/>
    <url>/2022/10/01/%E5%88%9D%E4%B8%89%E4%B8%80%E6%A8%A1%E6%95%B0%E5%AD%A6%E7%BB%83%E4%B9%A0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数学一模练习一">数学一模练习一</h2><p>一模将至，博主提供练习。</p><p>试卷共 10 题，100 分，题目均是原题。</p><p><a href="paper.pdf">进入试卷</a></p>]]></content>
    
    
    <categories>
      
      <category>文化课</category>
      
    </categories>
    
    
    <tags>
      
      <tag>课内数学</tag>
      
      <tag>平面几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>电脑换新</title>
    <link href="/2022/10/01/%E7%94%B5%E8%84%91%E6%8D%A2%E6%96%B0/"/>
    <url>/2022/10/01/%E7%94%B5%E8%84%91%E6%8D%A2%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于换新电脑了，hexo博客迁移成功！</p>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OI总结</title>
    <link href="/2022/07/30/OI%E6%80%BB%E7%BB%93/"/>
    <url>/2022/07/30/OI%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c73efd8f5c6c95674c7b18b0c8916f836d221fac936d5063eb7bc1552d225ffd">e76fef1e3e2566cdd2afcbcc304761f7aac844b4d722cb03a2bea36c1f02d90a031930cfee0c40e8706bb25f6481219f2ac0fd951ff7eaf83bd484a1b1db334d3c128e3f132ccf1c0c01c5419107b7ee9d7ee1a36e6204c59ee04990d0a3f660de6237e61eb52460851954eace068577a3e96d54066bd2d2886fcf993fd66015d7915bdcd22d29e2a6c37aab25f6de09c6a251eb2bf8c27e2e40a3829049b0ebce6731b85d2ca0ab36f6fc127075dd572620811eae19b043a326952a84636324c347c94b6825bd02f3daf2da07e8bf4fb2fb94e3c557e0a4eebb975426ba3a277d796d5ceacb8cb0f7d2aefd1941acb01ad040fe6cb63e76dfe4958ccfc6302ae6198e0ea7f922b6700ad8c2fdfcd4ab29ca998e52f3a2aa1806666ff93ba750dec71f7d2033f7698fb1bc73a6a1accd991b178b3682ca4d5f417acc4b42f1af8c5405e10c9fd3791e147aa8c0e359a65dc649d9bb4bbc5c5b9a4720d6edd42f92b31f2dee208a71c789b589ef0965384450f91ab8427e7834e76868ba4e9545acb750d56065f80777233ee51898e10d44a0b126e9f30130226385e6f5563694e10f91de285fed7f2355bf1e88867e51b44d5bbe9e5a13eef1fca93caec4f7e00d6c3b614801b498009809627d535a5df23430a77c915e11fa5fe7aa3e675451722695c9cc38a8f61ad1ed80755650ed8dbcff34a0d4dd31f9f85f478ca88fd73ea98dd59ff3d5aeb034ab9cd0567b0f0585ebf6e44eff56655329ef555d3ad8cc63b9047b01c660359f4c45194ac0469951ef01f021f74b1d0b27d089732d4c6ae5c5b881cf0a3d2de1308ecdfba7fae5a377f69a16670a132b662bafff70c9070bcefd260b35ffbbb1edc039b74f3c536358445d2c90780f2454beb22333860440e156902ee29ba9fa625bdf261940f24f354111c66c638844e159626fd25594af97916abfb9c51f2abd012a09650b50e675ff4ee735911f752b7dea4f0872bcaf7aa585450ea230ee2f9081142abc2421275a59b0fdcbf814b267b966156488d51012551a6c6069248fb76909bb455fb5b6a1a6376045e29536a81c0d04b2992101a5e710e54907de8e3bfb637f12219fb03dfb7a8999865db0c5c8080d812c5d2c9e82a33c4e609599ebafbd5534e533d01fbc9afe9fcf835c2944ff51168a615aec40b3479dcb2f29843813325443f8626e96f01182ed81144abd4a0b95272daefdc51cda860ed019d8341f99dedcca07d23a5830a14dcd640ab62b9eb4ccd4f80b7dd70a774382f2d2a879f80676a666280b09ee1921290dfd1795266f224a8386ca2690e091238f69c1d4532805212d8dbbefc9c8400b7bda2beca74dca00746ec4e2bc8f476709d468fc02634462d5f0ff476fe9a5679d8e698750380c5d70d6750b9fe8e2c7e0e497a77d363cb70a0fbf4354c11ece2929c4cffdc32f447c1db318ffa35c7fbb197a97cbf26204e07a19bca41345f5b8af98f76aae56bba9022080395f2467d814cb799d12b3ce17b7157511066fa90a2c2b7d4786f00223f1c413f3da9e72e1808269247e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">该文章已被加密</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结反思</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态压缩技巧</title>
    <link href="/2022/07/29/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/07/29/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="状态压缩">状态压缩</h2><p>状态压缩, 是将 0/1 状态构成的集合用空间占用较小的载体 (如整数、<code>bitset</code>) 表示的技巧. 例如在数组 <code>[1, 8, 7, 2, 5, 3]</code> 中, 一个状态表示选取子序列 <code>[1, 7, 5]</code> , 它就可以表示为 <code>0b10100</code> .</p><h2 id="注意事项">注意事项</h2><h3 id="选择合适的载体进行压缩">选择合适的载体进行压缩</h3><p>对于上文所说的状态集合, 为什么不开一个<code>bool</code> 类型的数组存储呢? 如果是那样多方便! 答案是: <strong>费空间</strong> .</p><p>注意到, 一个 <code>bool</code> 类型的变量占用 1 字节 (8 bit) 的空间, 而不是 1 bit. 这是因为需要方便计算机寻址. (在较早的 C 语言标准中甚至没有引入 <code>bool</code> 类型, 需要程序员根据习惯使用 <code>unsigned short</code> 或者 <code>char</code> 等进行宏定义).</p><p>状态集合可能会很大, 所以, 直接用 <code>bool</code> 数组存储这个集合不太合适. 同时, <code>bool</code> 数组不方便进行数学与位运算. 故需要将这些状态压缩到更合适的载体中存储.</p><h4 id="整数状态压缩">整数状态压缩</h4><p>将 0/1 状态集合压缩到二进制整数中.</p><h5 id="优势">优势</h5><ul><li>可作为数组下标访问数组元素(需要在 <code>size_t</code> 范围内). 例如在状压 DP 时将 0/1 状态集合压缩成的整数作为访问答案的其中一个关键字, 能通过当前局面进行递推计算答案.</li><li>可以进行数学运算.</li></ul><h5 id="缺陷">缺陷</h5><ul><li>集合的大小有限制( <span class="math inline">\(2^{状态数量}\)</span> 不能超过当前类型数据范围).</li><li>操作较为繁琐; 过多使用位运算会使代码可读性较差.</li></ul><h4 id="stdbitset"><code>std::bitset</code></h4><h5 id="优势-1">优势</h5><ul><li>支持位运算.</li><li>像一个数组一样, 操作较为简便.</li><li>长度不受限制.</li></ul><h5 id="缺陷-1">缺陷</h5><ul><li>不支持数学运算.</li><li>不能访问数组元素.</li></ul><h2 id="应用">应用</h2><h3 id="子集枚举">子集枚举</h3><h3 id="例题">例题</h3><h4 id="section"></h4><h3 id="动态规划中-表示状态">(动态规划中) 表示状态</h3>]]></content>
    
    
    <categories>
      
      <category>OI笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搜索算法入门</title>
    <link href="/2022/06/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <url>/2022/06/24/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="深度优先搜索-dfs">深度优先搜索 (DFS)</h2><p>本质是将状态的集合表达为一棵搜索树, 自顶向下地递归求解子问题 (抽象为图就是: 每一层为一个阶段, 每一个结点表示一个决策. 深度优先遍历每一棵子树).</p><div class="note note-warning">            <p>该方法可能会多次重复递归求解相同子问题 (表现为 <code>dfs</code> 函数多次在调用时传入相同参数) , 效率较低. 此时可以使用 <strong>记忆化搜索</strong> (自顶向下、带备忘录的方法) 或 <strong>动态规划</strong> (自底向上方法).</p>          </div><h3 id="几个简单例子">几个简单例子</h3><h4 id="数的分解">数的分解</h4><blockquote><p>将 <span class="math inline">\(n\)</span> 分解成不多于 <span class="math inline">\(k\)</span> 的数相加的形式.</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n, k, ans[N];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> lst, <span class="hljs-keyword">int</span> left)</span> </span>{<br><span class="hljs-comment">// 填入第 idx 项, 上一个数为 lst, 还剩下的总和为 lst</span><br><span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; idx == k + <span class="hljs-number">1</span>) {<br><span class="hljs-comment">// Output;</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= idx - <span class="hljs-number">1</span>; ++i) cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">' '</span>;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = lst; i &lt;= left; ++i) {<br>ans[idx] = i;<br><span class="hljs-built_in">dfs</span>(idx + <span class="hljs-number">1</span>, i, left - i);<br>}<br>}<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>cin &gt;&gt; n &gt;&gt; k;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h4 id="输出全排列方案">输出全排列方案</h4><blockquote><p>输出编号为 <span class="math inline">\(1\cdots n\)</span> 元素的全排列.</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n, ans[<span class="hljs-number">21</span>];<br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">21</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx)</span> </span>{<br><span class="hljs-keyword">if</span>(idx == n + <span class="hljs-number">1</span>) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= idx - <span class="hljs-number">1</span>; ++i) {<br>cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">5</span>) &lt;&lt; ans[i]; <br>}<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br><span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br><span class="hljs-keyword">if</span>(vis[i]) <span class="hljs-keyword">continue</span>;<br>ans[idx] = i; vis[i] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(idx + <span class="hljs-number">1</span>);<br>vis[i] = <span class="hljs-number">0</span>;<span class="hljs-comment">// 回溯</span><br>}<br>}<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>cin &gt;&gt; n;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h4 id="输出组合方案">输出组合方案</h4><blockquote><p>输出编号为 <span class="math inline">\(1\cdots n\)</span> 元素中取 <span class="math inline">\(k\)</span> 个元素的组合方案.</p></blockquote><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">33</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n, k, ans[<span class="hljs-number">23</span>];<br><span class="hljs-keyword">bool</span> vis[<span class="hljs-number">23</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> idx, <span class="hljs-keyword">int</span> lst)</span> </span>{<br><span class="hljs-keyword">if</span>(idx == k + <span class="hljs-number">1</span>) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= idx - <span class="hljs-number">1</span>; ++i) cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">3</span>) &lt;&lt; ans[i];<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br><span class="hljs-keyword">return</span>;<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br><span class="hljs-keyword">if</span>(vis[i] || i &lt;= lst) <span class="hljs-keyword">continue</span>;<br>ans[idx] = i, vis[i] = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">dfs</span>(idx + <span class="hljs-number">1</span>, i);<br>vis[i] = <span class="hljs-number">0</span>;<br>}<br>}<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>cin &gt;&gt; n &gt;&gt; k;<br><span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树形DP</title>
    <link href="/2022/06/22/%E6%A0%91%E5%BD%A2DP/"/>
    <url>/2022/06/22/%E6%A0%91%E5%BD%A2DP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="树形dp">树形DP</h1><h2 id="例题">例题</h2><h3 id="没有上司的舞会"><a href="https://www.luogu.com.cn/problem/P1352">没有上司的舞会</a></h3><p>使用<span class="math inline">\(dp(u, 0/1)\)</span>表示以<span class="math inline">\(u\)</span>来或不来时<span class="math inline">\(u\)</span>为根结点子树的快乐指数总和.</p><p>则: <span class="math display">\[dp(u, 0) = \sum \max_{v \in u.\mathrm{son}} \{dp(v, 0), dp(v, 1)\}\\dp(u, 1) = dp(v, 0)\]</span></p><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> head[N], to[N], nxt[N], tot, n, r[N], Root = <span class="hljs-number">1</span>, dp[N][<span class="hljs-number">2</span>];<br><span class="hljs-keyword">bool</span> haveFa[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initGraph</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> head);<br>tot = <span class="hljs-number">-1</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>{<br>nxt[++tot] = head[u], head[u] = tot, to[tot] = v;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; ~i; i = nxt[i]) {<br><span class="hljs-keyword">int</span> v = to[i];<br><span class="hljs-built_in">calc</span>(v);<br>dp[u][<span class="hljs-number">0</span>] += <span class="hljs-built_in">max</span>(dp[v][<span class="hljs-number">0</span>], dp[v][<span class="hljs-number">1</span>]);<br>dp[u][<span class="hljs-number">1</span>] += dp[v][<span class="hljs-number">0</span>];<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">initGraph</span>();<br><br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br>cin &gt;&gt; dp[i][<span class="hljs-number">1</span>];<br>}<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) {<br><span class="hljs-keyword">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; v;<br><span class="hljs-built_in">addEdge</span>(v, u);<br>haveFa[u] = <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-keyword">while</span>(haveFa[Root]) {<br>Root++;<br>}<br><br><span class="hljs-built_in">calc</span>(Root);<br><br>cout &lt;&lt; <span class="hljs-built_in">max</span>(dp[Root][<span class="hljs-number">0</span>], dp[Root][<span class="hljs-number">1</span>]) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h3 id="战略游戏"><a href="https://www.luogu.com.cn/problem/P2016">战略游戏</a></h3><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> head[N], to[N], nxt[N], tot, dp[N][<span class="hljs-number">2</span>], n, Root;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initGraph</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> head);<br>tot = <span class="hljs-number">-1</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>{<br>nxt[++tot] = head[u], head[u] = tot, to[tot] = v;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{<br>dp[u][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, dp[u][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; ~i; i = nxt[i]) {<br><span class="hljs-keyword">int</span> v = to[i];<br><span class="hljs-built_in">calc</span>(v);<br>dp[u][<span class="hljs-number">0</span>] += dp[v][<span class="hljs-number">1</span>];<br>dp[u][<span class="hljs-number">1</span>] += <span class="hljs-built_in">min</span>(dp[v][<span class="hljs-number">0</span>], dp[v][<span class="hljs-number">1</span>]);<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">initGraph</span>();<br><br>cin &gt;&gt; n;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br><span class="hljs-keyword">int</span> u, k;<br>cin &gt;&gt; u &gt;&gt; k;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= k; ++j) {<br><span class="hljs-keyword">int</span> v;<br>cin &gt;&gt; v;<br><span class="hljs-built_in">addEdge</span>(u, v);<br>}<br>}<br><br><span class="hljs-built_in">calc</span>(<span class="hljs-number">0</span>);<br><br>cout &lt;&lt; <span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]) &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h3 id="dp求树的直径"><a href="https://www.luogu.com.cn/problem/SP1437">DP求树的直径</a></h3><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">int</span> head[N], to[N], nxt[N], tot, Root, d1[N], d2[N];<br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initGraph</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">memset</span>(head, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> head);<br>tot = <span class="hljs-number">-1</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v)</span> </span>{<br>nxt[++tot] = head[u], head[u] = tot, to[tot] = v;<br>}<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getDiam</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{<br><span class="hljs-keyword">int</span> ret = -INF;<br>d1[u] = d2[u] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = head[u]; ~i; i = nxt[i]) {<br><span class="hljs-keyword">int</span> v = to[i];<br><span class="hljs-built_in">getDiam</span>(v);<br><span class="hljs-keyword">int</span> t = d1[v] + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span>(t &gt; d1[u]) {<br>d2[u] = d1[u], d1[u] = t;<br>} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t &gt; d2[u]) {<br>d2[u] = t;<br>}<br>}<br>ret = <span class="hljs-built_in">max</span>(ret, d1[u] + d2[u]);<br><span class="hljs-keyword">return</span> ret;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">initGraph</span>();<br><br>cin &gt;&gt; n;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) {<br><span class="hljs-keyword">int</span> u, v;<br>cin &gt;&gt; u &gt;&gt; v;<br><span class="hljs-built_in">addEdge</span>(u, v);<br>}<br><br><span class="hljs-keyword">int</span> ans = <span class="hljs-built_in">getDiam</span>(<span class="hljs-number">1</span>);<br><br>cout &lt;&lt; ans&lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h3 id="消防局的设立"><a href="https://www.luogu.com.cn/problem/P2279">消防局的设立</a></h3>]]></content>
    
    
    <categories>
      
      <category>OI笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>图论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最短路算法</title>
    <link href="/2022/06/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/"/>
    <url>/2022/06/04/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介">简介</h2><h2 id="模板代码">模板代码</h2><p>这样"三合一"过不了. 需要哪个直接用哪个即可.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">// 最短路模板三合一</span><br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> SPFA</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;ctime&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdlib&gt;</span></span><br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Algo</span> {</span> DIJKSTRA = <span class="hljs-number">0</span>, FLOYD = <span class="hljs-number">1</span>, BELLMAN_FORD = <span class="hljs-number">2</span> };<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> h[N], e[N], to[N], ne[N], tot = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">int</span> n, m, s;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u, <span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w)</span> </span>{<br>ne[++tot] = h[u], h[u] = tot, e[tot] = w, to[tot] = v;<br>}<br><span class="hljs-keyword">namespace</span> Dijkstra {<br><span class="hljs-keyword">int</span> dis[N], head, tail;<br><span class="hljs-keyword">bool</span> vis[N];<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> {</span><br><span class="hljs-keyword">int</span> u, dis;<br><span class="hljs-keyword">inline</span> <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &gt;(<span class="hljs-keyword">const</span> Node&amp; b) <span class="hljs-keyword">const</span> {<br><span class="hljs-keyword">return</span> dis &gt; b.dis;<br>}<br>};<br>priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt; &gt; q;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> s)</span> </span>{<br><span class="hljs-built_in">memset</span>(dis, INF, <span class="hljs-keyword">sizeof</span> dis); dis[s] = <span class="hljs-number">0</span>;<br>q.<span class="hljs-built_in">push</span>({s, n});<br><span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>()) {<br><span class="hljs-keyword">int</span> u = q.<span class="hljs-built_in">top</span>().u; q.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<br>vis[u] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = h[u]; ~i; i = ne[i]) {<br><span class="hljs-keyword">int</span> v = to[i], w = e[i];<br><span class="hljs-keyword">if</span>(dis[v] &gt; dis[u] + w) {<br>dis[v] = dis[u] + w; q.<span class="hljs-built_in">push</span>({v, dis[v]});<br>}<br>}<br>}<br>}<br>} <span class="hljs-comment">// namespace Dijkstra</span><br><span class="hljs-keyword">namespace</span> Floyd {<br><span class="hljs-keyword">int</span> dis[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>], n, m;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pre</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _n, <span class="hljs-keyword">int</span> _m)</span> </span>{<br>n = _n, m = _m;<br><span class="hljs-built_in">memset</span>(dis, INF, <span class="hljs-keyword">sizeof</span> dis);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) dis[i][i] = <span class="hljs-number">0</span>;<br>}<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) {<br><span class="hljs-keyword">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>dis[u][v] = <span class="hljs-built_in">min</span>(dis[u][v], w);<br>}<br>}<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">1</span>; k &lt;= n; ++k) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) {<br>dis[i][j] = <span class="hljs-built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);<br>}<br>}<br>}<br>}<br>} <span class="hljs-comment">// namespace Floyd</span><br><span class="hljs-keyword">namespace</span> Bellman_Ford {<br><span class="hljs-keyword">int</span> dis[N];<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">work</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> s)</span> </span>{<span class="hljs-comment">// 判定s为源点路径是否有负环</span><br><span class="hljs-built_in">memset</span>(dis, INF, <span class="hljs-keyword">sizeof</span> dis);<br>dis[s] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> fl;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)  {<br>fl = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> u = <span class="hljs-number">1</span>; u &lt;= n; ++u) {<br><span class="hljs-keyword">if</span>(dis[u] == INF) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = h[u]; ~j; j = ne[j]) {<br><span class="hljs-keyword">int</span> v = to[j], w = e[j];<br><span class="hljs-keyword">if</span>(dis[v] &gt; dis[u] + w) {<br>dis[v] = dis[u] + w; fl = <span class="hljs-literal">true</span>;<br>}<br>}<br>}<br><span class="hljs-keyword">if</span>(!fl) <span class="hljs-keyword">break</span>;<br>}<br><span class="hljs-keyword">return</span> fl;<br>}<br>} <span class="hljs-comment">// namespace Bellman_Ford</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>)<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>)); <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;<br><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Algo</span> <span class="hljs-title">magic</span> =</span> (<span class="hljs-keyword">enum</span> Algo)(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>);<br><span class="hljs-comment">// printf("Magic = %d\n", magic);</span><br><span class="hljs-keyword">if</span>(magic == FLOYD) {<br>Floyd::<span class="hljs-built_in">pre</span>(n, m); Floyd::<span class="hljs-built_in">read</span>(); Floyd::<span class="hljs-built_in">work</span>();<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cout &lt;&lt; Floyd::dis[s][i] &lt;&lt; <span class="hljs-string">" "</span>;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) {<br><span class="hljs-keyword">int</span> u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; <br><span class="hljs-built_in">add</span>(u, v, w);<br>}<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(magic) {<br><span class="hljs-keyword">case</span> DIJKSTRA:<br>Dijkstra::<span class="hljs-built_in">work</span>(n, s);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br>cout &lt;&lt; Dijkstra::dis[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>}<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> BELLMAN_FORD:<br><span class="hljs-keyword">bool</span> neg_ring = Bellman_Ford::<span class="hljs-built_in">work</span>(n, s);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br>cout &lt;&lt; Bellman_Ford::dis[i] &lt;&lt; <span class="hljs-string">" "</span>;<br>}<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br><span class="hljs-keyword">break</span>;<br>}<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>最短路</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DP斜率优化</title>
    <link href="/2022/05/28/DP%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/"/>
    <url>/2022/05/28/DP%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介">简介</h2><p>刷完题再写</p><h2 id="例题">例题</h2><h3 id="hnoi2008玩具装箱">[HNOI2008]玩具装箱</h3><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> f[N], q[N], head = <span class="hljs-number">1</span>, tail = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> n, L, sc[N];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pow2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a)</span> </span>{ <span class="hljs-keyword">return</span> a * a; }<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">S</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{ <span class="hljs-keyword">return</span> sc[i] + i; }<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Y</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j)</span> </span>{ <span class="hljs-keyword">return</span> f[j] + <span class="hljs-built_in">pow2</span>(<span class="hljs-built_in">S</span>(j)); }<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">X</span><span class="hljs-params">(<span class="hljs-keyword">int</span> j)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-built_in">S</span>(j); }<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> L_ (L + 1)</span><br><span class="hljs-function"><span class="hljs-keyword">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>cin &gt;&gt; n &gt;&gt; L;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br><span class="hljs-keyword">int</span> cc; cin &gt;&gt; cc;<br>sc[i] = sc[i - <span class="hljs-number">1</span>] + cc;<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br><span class="hljs-keyword">int</span> k = <span class="hljs-number">2</span> * (<span class="hljs-built_in">S</span>(i) - L_);<br><span class="hljs-keyword">while</span>(head &lt; tail &amp;&amp; (<span class="hljs-built_in">Y</span>(q[head + <span class="hljs-number">1</span>]) - <span class="hljs-built_in">Y</span>(q[head])) &lt;= k * (<span class="hljs-built_in">X</span>(q[head + <span class="hljs-number">1</span>]) - <span class="hljs-built_in">X</span>(q[head]))) ++head;<br>f[i] = f[q[head]] + <span class="hljs-built_in">pow2</span>(<span class="hljs-built_in">S</span>(i) - <span class="hljs-built_in">S</span>(q[head]) - L_);<br><span class="hljs-keyword">while</span>(head &lt; tail &amp;&amp; (<span class="hljs-built_in">Y</span>(i) - <span class="hljs-built_in">Y</span>(q[tail])) * (<span class="hljs-built_in">X</span>(q[tail]) - <span class="hljs-built_in">X</span>(q[tail - <span class="hljs-number">1</span>])) &lt;= \<br>(<span class="hljs-built_in">Y</span>(q[tail]) - <span class="hljs-built_in">Y</span>(q[tail - <span class="hljs-number">1</span>])) * (<span class="hljs-built_in">X</span>(i) - <span class="hljs-built_in">X</span>(q[tail]))) --tail;<br>q[++tail] = i;<br>}<br>cout &lt;&lt; f[n] &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调队列优化DP</title>
    <link href="/2022/05/01/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP/"/>
    <url>/2022/05/01/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96DP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简介">简介</h2><p>不会.</p><h2 id="例题">例题</h2><h3 id="fance">Fance</h3><blockquote><p>有<span class="math inline">\(n\)</span>块木板从左到右排成一行，有<span class="math inline">\(m\)</span>个工匠对这些木板进行粉刷，每块木板至多被粉刷一次。</p><p>第<span class="math inline">\(i\)</span>个木匠要么不粉刷，要么粉刷包含木板<span class="math inline">\(S_i\)</span>的，长度不超过<span class="math inline">\(L_i\)</span>的连续的一段木板，每粉刷一块可以得到<span class="math inline">\(P_i\)</span>的报酬。</p><p>不同工匠的<span class="math inline">\(S_i\)</span>不同。</p><p>请问如何安排能使工匠们获得的总报酬最多。</p></blockquote><p>先按照<span class="math inline">\(S\)</span>排序, 去除后效性. DP, 设<span class="math inline">\(F_{i, j}\)</span>为前<span class="math inline">\(i\)</span>人刷前<span class="math inline">\(j\)</span>块板获得的最大报酬.</p><p>则有:</p><ol type="1"><li>第<span class="math inline">\(i\)</span>人不干了;</li><li>第<span class="math inline">\(j\)</span>块板空着不刷;</li><li>第<span class="math inline">\(i\)</span>人刷了<span class="math inline">\([k + 1, j]\)</span>的连续一段.</li></ol><p><span class="math display">\[\begin{array}{c}F_{i, j} = F_{i - 1, j}\\F_{i, j} = F_{i, j - 1}\\F_{i, j} = \max_{k\in [j - L_i, S_i)} \{F_{i - 1, j} + P_i \cdot (j - k)\}\end{array}\]</span></p><p>注意观察三式, 如果枚举<span class="math inline">\(i, j, k\)</span>肯定超时. 该怎么优化呢?</p><p>观察等号左侧, 这是一个关于<span class="math inline">\(i, j\)</span>的式子, 所以肯定要嵌套循环枚举它们. 此时可以通过防止不优的<span class="math inline">\(k\)</span>做dp来优化.</p><p>先看看式子, 尝试先把不含<span class="math inline">\(k\)</span>项提出来(下式加号左边): <span class="math display">\[F_{i, j} = P_i \cdot j + \max _{k \in [j - L_i, S_i)} \{F_{i - 1, k} - P_i \cdot k\}\]</span> 注意观察加号右边: 当<span class="math inline">\(j\)</span>从小到大地枚举时, 下界增大, 上界不变. 设<span class="math inline">\(k_1 \lt k_2 \le S_i\)</span>. 不难发现随着<span class="math inline">\(j\)</span>增加, <span class="math inline">\(k_1\)</span>先离开这个区间. 此时如果<span class="math inline">\(k_1\)</span>带来的价值不比<span class="math inline">\(k_2\)</span>多(<span class="math inline">\(\le\)</span>), 最后的答案就必然不是最优! 此时可以果断踢掉<span class="math inline">\(k_1\)</span>.</p><p>可以使用单调队列优化<span class="math inline">\(k\)</span>, 具体操作为:</p><p>for循环枚举<span class="math inline">\(k\)</span>:</p><ol type="1"><li>踢掉小于下界的队头;</li><li>此时队头为最优, 可以拿来做DP;</li><li>将当前枚举的<span class="math inline">\(k\)</span>与队尾作比较, 如果队尾获得的价值不大于<span class="math inline">\(k\)</span>获得的价值, 就踢队尾, <span class="math inline">\(k\)</span>入队.</li></ol><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Person</span> {</span><br><span class="hljs-keyword">int</span> l, p, s;<br><br><span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt;(<span class="hljs-keyword">const</span> Person &amp;p2) {<br><span class="hljs-keyword">return</span> s &lt; p2.s;<br>}<br>};<br><br>Person a[N];<br><span class="hljs-keyword">int</span> n, m;<br><span class="hljs-keyword">int</span> q[N], f[<span class="hljs-number">200</span>][<span class="hljs-number">20000</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) {<br><span class="hljs-keyword">int</span> l, p, s;<br>cin &gt;&gt; l &gt;&gt; p &gt;&gt; s;<br>a[i] = (Person){l, p, s};<br>}<br><br><span class="hljs-built_in">sort</span>(a + <span class="hljs-number">1</span>, a + <span class="hljs-number">1</span> + m);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) {<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> money(_i, _k) (f[(_i) - 1][(_k)] - a[(_i)].p * (_k))</span><br>        <br><span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, a[i].s - a[i].l); k &lt; a[i].s; ++k) {<br><span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; <span class="hljs-built_in">money</span>(i, q[tail]) &lt;= <span class="hljs-built_in">money</span>(i, k)) --tail;<br>q[++tail] = k;<br>}<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) {<br><span class="hljs-comment">//1, 2</span><br>f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br><br><span class="hljs-comment">//3</span><br><span class="hljs-keyword">if</span>(j &lt; a[i].s) <span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; q[head] &lt; j - a[i].l) ++head;<br><span class="hljs-keyword">if</span>(head &lt;= tail) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], j * a[i].p + <span class="hljs-built_in">money</span>(i, q[head]));<br>}<br>}<br><br>cout &lt;&lt; f[m][n] &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h3 id="cf372c-watching-fireworks-is-fun">CF372C Watching Fireworks is Fun</h3><blockquote><p>一个城镇有<span class="math inline">\(n\)</span>个区域,从左到右从1编号为<span class="math inline">\(n\)</span>,每个区域之间距离1个单位距离。 节日中有<span class="math inline">\(m\)</span>个烟火要放，给定放的地点<span class="math inline">\(a_i\)</span>,时间<span class="math inline">\(t_i\)</span>,如果你当时在区域<span class="math inline">\(x\)</span>,那么你可以获得<span class="math inline">\(b_i - \vert a_i - x\vert\)</span>的开心值。 你每个单位时间可以移动不超过<span class="math inline">\(d\)</span>个单位距离。 你的初始位置是任意的(初始时刻为1),求你通过移动能获取到的最大的开心值。</p><p><span class="math inline">\(1 \le n \le 150000, 1 \le m \le 300, 1 \le d \le n\)</span>.</p></blockquote><p>单调队列优化dp, 滚动数组优化空间.</p><p>设<span class="math inline">\(F_{i, j}\)</span>为在第<span class="math inline">\(i\)</span>个单位时间, 位于<span class="math inline">\(j\)</span>的最大开心值; 设<span class="math inline">\(\Delta s = (t_i - t_{i - 1}) \cdot d\)</span>, 则有</p><p>则有: <span class="math display">\[\begin{array}{d}F_{i, j} = \max _{j - \Delta s \le k\le j + \Delta s}\{F_{i - 1, k} + b_i - |a_i - j|\}\\\Rightarrow F_{i, j} =b_i - |a_i - j| + \max _{j - \Delta s \le k\le j + \Delta s}\{F_{i - 1, k}\}\end{array}\]</span> 观察数据范围, 开不下这么大的数组; 观察右式, 发现<span class="math inline">\(F_{i, j}\)</span>只跟<span class="math inline">\(F_{i - 1, j}\)</span>有关. 考虑使用滚动数组优化掉第一维.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1.5e6</span> + <span class="hljs-number">10</span>, M = <span class="hljs-number">310</span>, INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> LL;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">P</span> {</span><br>LL a, b, t;<br>};<br><br>P a[M];<br>LL f[<span class="hljs-number">2</span>][N], q[N];<br><span class="hljs-keyword">int</span> n, m, d;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> LL <span class="hljs-title">delta_s</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{<br><span class="hljs-keyword">return</span> d * (a[i].t - a[i - <span class="hljs-number">1</span>].t); <br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <br>cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) {<br><span class="hljs-keyword">int</span> aa, bb, tt;<br>cin &gt;&gt; aa &gt;&gt; bb &gt;&gt; tt;<br>a[i] = (P){aa, bb, tt};<br>}<br><br><br>    <span class="hljs-comment">//dp</span><br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i) {<br><span class="hljs-keyword">int</span> head = <span class="hljs-number">1</span>, tail = <span class="hljs-number">0</span>, k = <span class="hljs-number">1</span>;<span class="hljs-comment">//<span class="hljs-doctag">TODO:</span> k在for循环里定义第7个点会TLE???</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) {<br><span class="hljs-keyword">for</span>(; k &lt;= <span class="hljs-built_in">min</span>(<span class="hljs-number">1ll</span> * n, j + <span class="hljs-built_in">delta_s</span>(i)); ++k) {<br><span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; f[flag ^ <span class="hljs-number">1</span>][q[tail]] &lt;= f[flag ^ <span class="hljs-number">1</span>][k]) --tail;<br>q[++tail] = k;<br>}<br><br><span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; q[head] &lt; <span class="hljs-built_in">max</span>(<span class="hljs-number">1ll</span>, j - <span class="hljs-built_in">delta_s</span>(i))) ++head;<br>f[flag][j] = f[flag ^ <span class="hljs-number">1</span>][q[head]] - <span class="hljs-built_in">abs</span>(a[i].a - j) + a[i].b;<br>}<br>flag ^= <span class="hljs-number">1</span>;<br>}<br><br>LL ans = -INF;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; ++j) {<br>ans = <span class="hljs-built_in">max</span>(ans, f[flag ^ <span class="hljs-number">1</span>][j]);<br>}<br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h3 id="pta-little-bird">PTA-Little Bird</h3><blockquote><p>有<span class="math inline">\(n\)</span>棵树，第<span class="math inline">\(i\)</span>棵树的高度是<span class="math inline">\(d_i\)</span>。 要去第<span class="math inline">\(n\)</span>棵树。 第<span class="math inline">\(i\)</span>棵树可以跳到第<span class="math inline">\(i+1,i+2,\cdots,i+k\)</span>棵树。 如果跳到一棵不矮于当前树的树，那么劳累值会<span class="math inline">\(+1\)</span>；否则不会。 求到达第<span class="math inline">\(n\)</span>棵树的最小劳累值。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>OI笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
      <tag>数据结构</tag>
      
      <tag>DP优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单调队列</title>
    <link href="/2022/04/30/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2022/04/30/%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="定义">定义</h2><p>维护一种序列, 可以从头和尾增加或删除元素(即双端队列), 且元素具有单调性.</p><h2 id="实现">实现</h2><p>本质是维护具有单调性的<strong>最优决策集合</strong>, 该如何维护最优与单调的性质呢?</p><h3 id="维护序列">维护序列</h3><p>该操作的本质是<strong>对原序列<span class="math inline">\(A\)</span>扫描, 将当前的元素<span class="math inline">\(A_i\)</span>与单调队列队尾比较, 如果<span class="math inline">\(A_i\)</span>更优则将队尾换成<span class="math inline">\(A_i\)</span></strong>.</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pseudocode">//pseudo code<br>Queue q, Array a[];<br>int head = 0, tail = 0;<br>for each a[i] in a {<br>while(队列过大) ++head;//pop front<br>//此时q[head]为当前最优<br>    while(head &lt;= tail &amp;&amp; q[tail]没有a[i]优) --tail;//pop back<br>    q[++tail] = 当前值;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h3 id="实现双端队列">实现双端队列</h3><h4 id="stddeque"><code>std::deque</code></h4><p>可以使用deque对序列进行操作.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>deque&lt;<span class="hljs-keyword">int</span>&gt; q;<br><br><span class="hljs-comment">//入队</span><br>q.<span class="hljs-built_in">push_front</span>(x);<br>q.<span class="hljs-built_in">push_back</span>(x);<br><br><span class="hljs-comment">//出队</span><br>q.<span class="hljs-built_in">pop_front</span>();<br>q.<span class="hljs-built_in">pop_back</span>();<br><br><span class="hljs-comment">//取头尾</span><br>q.<span class="hljs-built_in">front</span>();<br>q.<span class="hljs-built_in">back</span>();<br><br><span class="hljs-comment">//遍历</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x: q) {<br>    cout &lt;&lt; x &lt;&lt; <span class="hljs-string">" "</span>;<br>}<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br></code></pre></div></td></tr></tbody></table></figure><h4 id="数组模拟">数组模拟</h4><p>可以使用两个指针<span class="math inline">\(head\)</span>, <span class="math inline">\(tail\)</span>模拟.</p><p><strong>需要注意的是数组中下标小的元素在队列前面, 同时指针<span class="math inline">\(head \le tail\)</span>.</strong></p><h2 id="例题">例题</h2><h3 id="滑动窗口">滑动窗口</h3><blockquote><p>给定一个长度为<span class="math inline">\(n\)</span>的序列, 求其每个长度为<span class="math inline">\(k\)</span>的连续子序列中的最大与最小值.</p></blockquote><p>本题只需维护两个单调队列(一个递减, 队头为min; 另一个反之)即可.</p><p>需要注意的是要让窗口大小不超过<span class="math inline">\(k\)</span>, 这里采用在队列中存储数组下标的方法统计, 即保证<span class="math inline">\(head\)</span>中存储的下标与当前扫描元素的下标之差小于<span class="math inline">\(k\)</span>.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span> + <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">int</span> q[N], a[N];<br><span class="hljs-keyword">int</span> n, k;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-comment">//维护递减序列, 队头即为答案</span><br><span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; k; ++i) {<br><span class="hljs-comment">//Step 1: [1, k), push</span><br><span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; a[q[tail]] &gt;= a[i]) --tail;<br>q[++tail] = i;<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt;= n; ++i) {<br><span class="hljs-comment">//Step 2: [k, n]</span><br><span class="hljs-comment">//这个区间窗口可能超过k, 需要特判维护窗口大小</span><br><span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; a[q[tail]] &gt;= a[i]) --tail;<br>q[++tail] = i;<br><span class="hljs-keyword">while</span>(q[head] &lt;= i - k) ++head;<br>cout &lt;&lt; a[q[head]] &lt;&lt; <span class="hljs-string">' '</span>;<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getMax</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-built_in">memset</span>(q, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> q);<br><span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; k; ++i) {<br><span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; a[q[tail]] &lt;= a[i]) --tail;<br>q[++tail] = i;<br>}<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = k; i &lt;= n; ++i) {<br><span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; a[q[tail]] &lt;= a[i]) --tail;<br>q[++tail] = i;<br><span class="hljs-keyword">if</span>(q[head] &lt;= i - k) ++head;<br>cout &lt;&lt; a[q[head]] &lt;&lt; <span class="hljs-string">' '</span>;<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>cin &gt;&gt; n &gt;&gt; k;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br>cin &gt;&gt; a[i];<br>}<br><span class="hljs-built_in">getMin</span>();<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br><span class="hljs-built_in">getMax</span>();<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h3 id="最大子序和">最大子序和</h3><blockquote><p>给定一个长度为<span class="math inline">\(n\)</span>的序列, 求出一段长度不超过<span class="math inline">\(m\)</span>的连续子序列, 输出子序和.</p></blockquote><p>不难想到前缀和操作, 在前缀和数组<span class="math inline">\(S\)</span>中, 对于右端点<span class="math inline">\(r\)</span>, 需要找到左端点<span class="math inline">\(l\)</span>满足如下条件: <span class="math display">\[\begin {cases}l \in [1, r - 1]&amp;&amp;&amp;(1)\\\min(S_l)&amp;&amp;&amp;(2)\\r - m \le l&amp;&amp;&amp;(3)\end {cases}\]</span> 其中, 3式的意思是让子序列的大小不超过<span class="math inline">\(m\)</span>.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">int</span> m, n;<br><span class="hljs-keyword">int</span> a[N], s[N];<br><br><span class="hljs-keyword">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br>cin &gt;&gt; a[i];<br>s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br>}<br><br><span class="hljs-keyword">int</span> head = <span class="hljs-number">0</span>, tail = <span class="hljs-number">0</span>, ans = <span class="hljs-number">-0x3f</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) {<br>    <span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; i - m &gt; q[head]) ++head;<br>    ans = <span class="hljs-built_in">max</span>(ans, s[i] - s[q[head]]);<br><span class="hljs-keyword">while</span>(head &lt;= tail &amp;&amp; s[q[tail]] &gt;= s[i]) --tail;<br>q[++tail] = i;<br>}<br>    <br>cout &lt;&lt; ans &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典树</title>
    <link href="/2022/04/18/trie/"/>
    <url>/2022/04/18/trie/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="字典树">字典树</h1><h2 id="定义">定义</h2><h2 id="应用">应用</h2><h3 id="像查字典一样检索字符串">像查字典一样"检索"字符串</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Trie</span> {</span><br><span class="hljs-keyword">int</span> nxt[N][<span class="hljs-number">26</span>], tot = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">bool</span> ed[N];<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(string s)</span> </span>{<br><span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch: s) {<br><span class="hljs-keyword">int</span> key = ch - <span class="hljs-string">'a'</span>;<br><span class="hljs-keyword">if</span>(nxt[p][key] == <span class="hljs-number">0</span>) {<br>nxt[p][key] = ++tot;<br>}<br>p = nxt[p][key];<br>}<br>ed[p] = <span class="hljs-literal">true</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isExist</span><span class="hljs-params">(string s)</span> </span>{<br><span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> ch: s) {<br><span class="hljs-keyword">int</span> key = ch - <span class="hljs-string">'a'</span>;<br><span class="hljs-keyword">if</span>(nxt[p][key] == <span class="hljs-number">0</span>) {<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>}<br>p = nxt[p][key];<br>}<br><span class="hljs-keyword">return</span> ed[p];<br>}<br><br>};<br><br>Trie tr;<span class="hljs-comment">//Allocate</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br><span class="hljs-keyword">int</span> cas;<br>cin &gt;&gt; cas;<br><span class="hljs-keyword">while</span>(cas--) {<br>    string s;<br>    cin &gt;&gt; s;<br>    tr.<span class="hljs-built_in">insert</span>(s);<br>}<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Inserted!!!!!!\n\nAsk Me!!!!!!!"</span>);<br>cin &gt;&gt; cas;<br><span class="hljs-keyword">while</span>(cas--) {<br>string s;<br>cin &gt;&gt; s;<br><span class="hljs-built_in">puts</span>(tr.<span class="hljs-built_in">isExist</span>(s) ? <span class="hljs-string">"Exist."</span> : <span class="hljs-string">"Not Exist."</span>);<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h3 id="异或极值问题">异或极值问题</h3>]]></content>
    
    
    <categories>
      
      <category>OI笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Splay</title>
    <link href="/2022/03/12/Splay/"/>
    <url>/2022/03/12/Splay/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="splay">Splay</h1><h2 id="定义">定义</h2><p>Splay是一种平衡树, 将访问过的结点不断旋转到根结点, 在满足BST性质的同时保证其"平衡", <strong>基于时间、空间局部性原理优化查找性能(这样操作使得高频访问的结点在经常根结点附近)</strong>.</p><p><strong>本文的BST每一个结点只维护单个值(而非键值对), 下面说法中v、val、key都指这个值, BST性质的维护它们的大小关系做依据.</strong></p><h3 id="bst性质">BST性质</h3><p>左子树任意结点的key<span class="math inline">\(\lt\)</span>根结点key<span class="math inline">\(\lt\)</span>右子树任意结点key, 即<strong>中序遍历单调递增</strong>.</p><p>常见的BST有Treap、Splay、AVL等.</p><h2 id="结点结构">结点结构</h2><p>开结构体数组记录两个子结点及父结点的数组下标, 类似于一个<strong>链表</strong>(实际上很多树状数据结构都是数组模拟链表). 结点同时存储维护的信息.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">1e5</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> {</span><br>    <span class="hljs-comment">//两个子结点及父结点数组下标, val</span><br>    <span class="hljs-keyword">int</span> s[<span class="hljs-number">2</span>], p, v;<br>    <span class="hljs-comment">//延迟标记及子树大小</span><br>    <span class="hljs-keyword">int</span> dat, size;<br>    <span class="hljs-comment">//初始化当前结点</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _v, <span class="hljs-keyword">int</span> _p)</span> </span>{<br>        v = _v, p = _p;<br>        size = <span class="hljs-number">1</span>;<br>    }<br>};<br><br><span class="hljs-comment">//Allocate</span><br>Node tr[SIZE];<br></code></pre></div></td></tr></tbody></table></figure><p>其中规定<code>s[0]</code>为左子结点, <code>s[1]</code>为右子结点, 即: (后续代码均未使用如下define, 只是为了方便理解)</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls s[0]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs s[1]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> son s[k]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> son_bro s[k ^ 1]<span class="hljs-comment">//son's brother</span></span><br></code></pre></div></td></tr></tbody></table></figure><h2 id="单旋操作rotate">单旋操作(rotate)</h2><p>旋转需要保证BST性质; 根结点变量, 即<code>root</code>需要更新; 结点维护的信息(如延迟标记)需要更新.</p><p>旋转改变了是树的形态, 本质是<strong>改变父子关系</strong>.</p><figure><img src="https://s2.loli.net/2022/02/27/51Z6t4FNpChvJbi.jpg" alt="Splay单旋"><figcaption aria-hidden="true">Splay单旋</figcaption></figure><h4 id="右旋-即operatornamezigx操作">右旋, 即<span class="math inline">\(\operatorname{Zig}(x)\)</span>操作</h4><p>顾名思义就是将<span class="math inline">\(x\)</span>的左子树绕着<span class="math inline">\(x\)</span>的父结点<span class="math inline">\(y\)</span>向右旋转.</p><p>需要注意的是<span class="math inline">\(x \lt x_r \lt y\)</span>, 故<span class="math inline">\(x_r\)</span>应该转到<span class="math inline">\(y_r\)</span>左子树的位置.</p><p>这样的操作通过改变<span class="math inline">\(y\)</span>与<span class="math inline">\(x_r\)</span>、<span class="math inline">\(\operatorname{fa}(y)\)</span>与<span class="math inline">\(x\)</span>、<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>的父子关系达到.</p><h4 id="左旋-即operatornamezagx操作">左旋, 即<span class="math inline">\(\operatorname{Zag}(x)\)</span>操作</h4><p>同理, <span class="math inline">\(x\)</span>的右子树绕着<span class="math inline">\(y\)</span>向左旋转, <span class="math inline">\(x_l\)</span>接在<span class="math inline">\(y\)</span>右子树位置.</p><p>即需要改变<span class="math inline">\(y\)</span>与<span class="math inline">\(x_l\)</span>、<span class="math inline">\(\operatorname{fa}(y)\)</span>与<span class="math inline">\(x\)</span>、<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>的父子关系.</p><h4 id="旋转结点-即operatornamerotatex操作">旋转结点, 即<span class="math inline">\(\operatorname{rotate}(x)\)</span>操作</h4><p>上述操作可以使用一个操作<span class="math inline">\(\operatorname{rotate}(x)\)</span>来完成, 即实现<strong>"自动判定左右"的单旋操作</strong>. <span class="math inline">\(x\)</span>是<span class="math inline">\(y\)</span>的左子树就右旋, 右子树反之.</p><p>该操作的精髓就是判定<span class="math inline">\(x\)</span>是<span class="math inline">\(y\)</span>的左结点还是右结点.</p><p>前面说过, "旋转"的本质是"改变父子关系". 每个结点维护了她的左右子树和父结点, 所以该过程需要"互认"父子关系, 即需要修改两个结点的信息; 同时因为树的形态被改变, 需要重新统计延迟标记维持的信息(如子树大小).</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{<br><span class="hljs-keyword">int</span> y = tr[x].p, z = tr[y].p;<br>    <span class="hljs-keyword">int</span> k = (tr[y].s[<span class="hljs-number">1</span>] == x);<br>    tr[z].s[tr[z].s[<span class="hljs-number">1</span>] == y] = x, tr[x].p = z;<br>    tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br>    tr[x].s[k ^ <span class="hljs-number">1</span>] = y, tr[y].p = x;<span class="hljs-comment">//tr[x].s[k]的含义是取处于yx直线上的x的儿子, k ^ 1是取她的兄弟</span><br>    <span class="hljs-built_in">Pushup</span>(y), <span class="hljs-built_in">Pushup</span>(x);<br>}<br></code></pre></div></td></tr></tbody></table></figure><p>说人话就是:</p><p><span class="math inline">\(k\)</span>的获取:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">k</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>{<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     *@description 返回x是y的哪个儿子, 左0右1.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">return</span> (tr[y].s[<span class="hljs-number">1</span>] == x);<br>}<br></code></pre></div></td></tr></tbody></table></figure><p>rotate伪代码:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pseudocode">/* y是x的爸爸, z是x的爷爷; */<br>/* 以下每一步都需要修改两个结点的值, 即互认关系 */<br>用z取到y, 将x转到y的位置上, 并与z互认; /* 以下两部均需操作结点与其父结点"互认"过程, 不再赘述 */<br>x(此时在y的位置上)的兄弟转到原先x(即tr[y].s[k])的位置上;<br>让y转到原先x的兄弟的位置;<br>分别更新y, x子树维护的信息;<br></code></pre></div></td></tr></tbody></table></figure><h2 id="双旋操作splay">双旋操作(splay)</h2><p>通过一或两次rotate, 可以调整BST的形态, 使其更平衡.</p><p>通过过程<span class="math inline">\(\operatorname{splay}(x, goal)\)</span>将结点<span class="math inline">\(x\)</span>转到<span class="math inline">\(goal\)</span>的子结点.</p><p>规定<span class="math inline">\(y\)</span>是<span class="math inline">\(x\)</span>父结点, <span class="math inline">\(z\)</span>是<span class="math inline">\(y\)</span>父结点, splay分六种(3 * 2)情况讨论.</p><ol type="1"><li>当<span class="math inline">\(\operatorname{fa}(x) = \operatorname{Root}\)</span>时, 旋转一次<span class="math inline">\(x\)</span>(右或左), 即Zig或Zag;</li><li>当<span class="math inline">\(\operatorname{fa}(x) \ne \operatorname{Root}\)</span>且<span class="math inline">\(z, y, x\)</span>在一条直线上, 旋转一次<span class="math inline">\(y\)</span>, 再同方向旋转一次<span class="math inline">\(x\)</span>, 即Zig-Zig或Zag-Zag;</li><li>当<span class="math inline">\(\operatorname{fa}(x) \ne \operatorname{Root}\)</span>且<span class="math inline">\(z, y, x\)</span>形状是在一条直线的中间折了一下, 分别对<span class="math inline">\(x\)</span>执行两次不同方向的旋转, 即Zig-Zag或Zag-Zig.</li></ol><p>画图理解即可.</p><p>使用rotate就是:</p><ul><li>折线2x</li><li>直线yx</li></ul><p><strong>需要注意的是该操作是将<span class="math inline">\(x\)</span>转到<span class="math inline">\(goal\)</span>下面, 故当<span class="math inline">\(x\)</span>与<span class="math inline">\(goal\)</span>为具有父子关系的两个结点时 (即第1、2种情况)不需要操作(即不需要交换它们).</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Splay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> goal)</span> </span>{<br>    <span class="hljs-comment">//把x转到goal下面</span><br>    <span class="hljs-keyword">while</span>(tr[x].p != goal) {<br>        <span class="hljs-keyword">int</span> y = tr[x].p, z = tr[y].p;<br>        <span class="hljs-keyword">if</span>(z != goal) {<br>            <span class="hljs-keyword">if</span>((tr[z].s[<span class="hljs-number">1</span>] == y) ^ (tr[y].s[<span class="hljs-number">1</span>] == x)) <span class="hljs-built_in">Rotate</span>(x);    <span class="hljs-comment">//折线先转x再转x</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">Rotate</span>(y);                                         <span class="hljs-comment">//直线先转y</span><br>        }<br>        <span class="hljs-built_in">Rotate</span>(x);                                                  <span class="hljs-comment">//统一转x</span><br>    }<br>    <span class="hljs-keyword">if</span>(goal == <span class="hljs-number">0</span>) Root = x;                                         <span class="hljs-comment">//更新根结点(0为根结点下标)</span><br>}<br></code></pre></div></td></tr></tbody></table></figure><hr><h2 id="插入操作insert">插入操作(insert)</h2><p>过程<span class="math inline">\(\operatorname{insert}(val)\)</span>将<span class="math inline">\(val\)</span>插入BST的相应位置<span class="math inline">\(x\)</span>, 将插入的数转到根结点, 即执行<span class="math inline">\(\operatorname{splay}(x, 0)\)</span>.</p><p>插入时需要维护BST性质, 将插入的这个数与当前节点比较, <strong>"小插左, 大插右"</strong>.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>{<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * @param v 要插入值的val.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">int</span> u = Root, p = <span class="hljs-number">0</span>;<span class="hljs-comment">//从根结点开始, u为当前节点数组下标, p为她的爸爸下标</span><br>    <span class="hljs-keyword">while</span>(u) {<br>        p = u, u = tr[u].s[v &gt; tr[u].v];<span class="hljs-comment">//小左大右地插下去, 方括号里的是判定左右</span><br>    }<br>    u = ++idx;<span class="hljs-comment">//结点又多了一个, idx += 1;</span><br>    <span class="hljs-keyword">if</span>(p) tr[p].s[v &gt; tr[p].v] = u;<span class="hljs-comment">//将p的儿子u插入适当位置</span><br>    tr[u].<span class="hljs-built_in">init</span>(v, p);<span class="hljs-comment">//给这个点初始化爸爸下标和自身value, 并将大小设为1</span><br>    <span class="hljs-built_in">splay</span>(u, <span class="hljs-number">0</span>);<span class="hljs-comment">//转到根结点</span><br>}<br></code></pre></div></td></tr></tbody></table></figure><h2 id="查询指定数的排名getrank">查询指定数的排名(getRank)</h2><p>不会<span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>.</p><h2 id="查询第k小的数getvalbyrank">查询第<span class="math inline">\(k\)</span>小的数(getValByRank)</h2><p><span class="math inline">\(\operatorname{getValByRank}(rank)\)</span>操作分三种情况讨论: <span class="math display">\[结点位于:\,\begin{cases}1. 所求结点位于左子树, 左子树结点个数\ge rank;\\2. 所求结点为中序遍历第k个数(即左子树的父结点), 左子树结点个数 = rank - 1;\\3. 所求结点位于右子树(rank需要减去左子树大小加一的和), 左子树结点个数 \lt rank - 1\end{cases}\]</span></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getValByRank</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rk)</span> </span>{<br>    <span class="hljs-keyword">int</span> u = Root;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {<br>        <span class="hljs-built_in">Pushdown</span>(u);<br>        <span class="hljs-keyword">if</span>(tr[tr[u].s[<span class="hljs-number">0</span>]] &gt;= rk) u = tr[u].s[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tr[tr[u].s[<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span> == rk) <span class="hljs-keyword">return</span> u;<br>        <span class="hljs-keyword">else</span> rk -= (tr[tr[u].s[<span class="hljs-number">0</span>]] + <span class="hljs-number">1</span>), u = tr[u].s[<span class="hljs-number">1</span>];<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h2 id="删除操作delete">删除操作(delete)</h2><p>操作<span class="math inline">\(\operatorname{delete}(x)\)</span>从Splay中删除value为<span class="math inline">\(x\)</span>的结点.</p><p>该操作首先将<span class="math inline">\(x\)</span>转到根结点, 再合并<span class="math inline">\(x\)</span>的左右子树.</p><h2 id="查询前驱后继getprefixgetsuffix">查询前驱/后继(getPrefix/getSuffix)</h2><p><span class="math inline">\(x\)</span>的前驱: 小于<span class="math inline">\(x\)</span>的最大数;</p><p><span class="math inline">\(x\)</span>的后继: 大于<span class="math inline">\(x\)</span>的最小数.</p><p><span class="math inline">\(\operatorname{getPrefix}(x)\)</span>操作查询<span class="math inline">\(x\)</span>的前驱, 可以通过插入<span class="math inline">\(x\)</span>(插入后位于根结点), 此时<span class="math inline">\(x\)</span>左子树中最右边的结点即为所求, 最后删除结点<span class="math inline">\(x\)</span>;</p><p><span class="math inline">\(\operatorname{getSuffix}(x)\)</span>操作反之.</p><hr><h2 id="例题">例题</h2><h3 id="文艺平衡树luogu-p3391">文艺平衡树(<a href="https://www.luogu.com.cn/problem/P3391">Luogu P3391</a>)</h3><blockquote><p>翻转一个区间，例如原有序序列是<span class="math inline">\(\{5, 4, 3, 2, 1\}\)</span>，翻转区间是<span class="math inline">\([2, 4]\)</span>的话，结果是<span class="math inline">\(\{5, 2, 3, 4, 1\}\)</span>.</p></blockquote><p>在结点上维护延迟标记<span class="math inline">\(flag\)</span>来判定翻转状态, 避免多次翻转造成性能上的浪费.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e5</span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> {</span><br>    <span class="hljs-keyword">int</span> s[<span class="hljs-number">2</span>], p, v, siz;<br>    <span class="hljs-keyword">int</span> flag;                  <span class="hljs-comment">//flag == 1则需要翻转</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _v, <span class="hljs-keyword">int</span> _p)</span> </span>{<br>        v = _v, p = _p;<br>        siz = <span class="hljs-number">1</span>;<br>    }<br>};<br><br>Node tr[N];<br><span class="hljs-keyword">int</span> idx, Root;<br><span class="hljs-keyword">int</span> cas, n;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{<br>    tr[x].siz = tr[tr[x].s[<span class="hljs-number">0</span>]].siz + tr[tr[x].s[<span class="hljs-number">1</span>]].siz + <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{<br>    <span class="hljs-keyword">if</span>(tr[x].flag) {<br>        <span class="hljs-built_in">swap</span>(tr[x].s[<span class="hljs-number">0</span>], tr[x].s[<span class="hljs-number">1</span>]);<br>        tr[tr[x].s[<span class="hljs-number">0</span>]].flag ^= <span class="hljs-number">1</span>;<br>        tr[tr[x].s[<span class="hljs-number">1</span>]].flag ^= <span class="hljs-number">1</span>;<br>        tr[x].flag = <span class="hljs-number">0</span>;<br>    }<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{<br>    <span class="hljs-keyword">int</span> y = tr[x].p, z = tr[y].p;<br>    <span class="hljs-keyword">int</span> k = (tr[y].s[<span class="hljs-number">1</span>] == x);<br>    tr[z].s[tr[z].s[<span class="hljs-number">1</span>] == y] = x, tr[x].p = z;<br>    tr[y].s[k] = tr[x].s[k ^ <span class="hljs-number">1</span>], tr[tr[x].s[k ^ <span class="hljs-number">1</span>]].p = y;<br>    tr[x].s[k ^ <span class="hljs-number">1</span>] = y, tr[y].p = x;<br>    <span class="hljs-built_in">Pushup</span>(y), <span class="hljs-built_in">Pushup</span>(x);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Splay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> goal)</span> </span>{<br>    <span class="hljs-keyword">while</span>(tr[x].p != goal) {<br>        <span class="hljs-keyword">int</span> y = tr[x].p, z = tr[y].p;<br>        <span class="hljs-keyword">if</span>(z != goal) {<br>            <span class="hljs-keyword">if</span>((tr[z].s[<span class="hljs-number">1</span>] == y) ^ (tr[y].s[<span class="hljs-number">1</span>] == x)) <span class="hljs-built_in">Rotate</span>(x);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">Rotate</span>(y);<br>        }<br>        <span class="hljs-built_in">Rotate</span>(x);<br>    }<br>    <span class="hljs-keyword">if</span>(goal == <span class="hljs-number">0</span>) Root = x;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>{<br>    <span class="hljs-keyword">int</span> u = Root, p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(u) {<br>        p = u, u = tr[u].s[v &gt; tr[u].v];<br>    }<br>    u = ++idx;<br>    <span class="hljs-keyword">if</span>(p) {<br>        tr[p].s[v &gt; tr[p].v] = u;<br>    }<br>    tr[u].<span class="hljs-built_in">init</span>(v, p);<br>    <span class="hljs-built_in">Splay</span>(u, <span class="hljs-number">0</span>);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getValByRank</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rk)</span> </span>{<br>    <span class="hljs-keyword">int</span> u = Root;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {<br>        <span class="hljs-built_in">Pushdown</span>(u);<br>        <span class="hljs-keyword">if</span>(tr[tr[u].s[<span class="hljs-number">0</span>]].siz &gt;= rk) u = tr[u].s[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tr[tr[u].s[<span class="hljs-number">0</span>]].siz == rk - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> u;<br>        <span class="hljs-keyword">else</span> rk -= (tr[tr[u].s[<span class="hljs-number">0</span>]].siz + <span class="hljs-number">1</span>), u = tr[u].s[<span class="hljs-number">1</span>];<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> u)</span> </span>{<br>    <span class="hljs-comment">//这一步是翻转</span><br>    <span class="hljs-built_in">Pushdown</span>(u);<br>    <span class="hljs-comment">//从u开始中序遍历</span><br>    <span class="hljs-comment">//左</span><br>    <span class="hljs-keyword">if</span>(tr[u].s[<span class="hljs-number">0</span>]) <span class="hljs-built_in">Output</span>(tr[u].s[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">//判定哨兵, 输出当前结点</span><br>    <span class="hljs-keyword">if</span>(tr[u].v &gt;= <span class="hljs-number">1</span> &amp;&amp; tr[u].v &lt;= n) cout &lt;&lt; tr[u].v &lt;&lt; <span class="hljs-string">' '</span>;<br>    <span class="hljs-comment">//右</span><br>    <span class="hljs-keyword">if</span>(tr[u].s[<span class="hljs-number">1</span>]) <span class="hljs-built_in">Output</span>(tr[u].s[<span class="hljs-number">1</span>]);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    cin &gt;&gt; n &gt;&gt; cas;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) {<br>        <span class="hljs-comment">//插入哨兵防止越界</span><br>        <span class="hljs-built_in">Insert</span>(i);<br>    }<br>    <span class="hljs-keyword">while</span>(cas--) {<br>        <span class="hljs-keyword">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        l = <span class="hljs-built_in">getValByRank</span>(l), r = <span class="hljs-built_in">getValByRank</span>(r + <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">Splay</span>(l, <span class="hljs-number">0</span>), <span class="hljs-built_in">Splay</span>(r, l);<br>        tr[tr[r].s[<span class="hljs-number">0</span>]].flag ^= <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-built_in">Output</span>(Root);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-comment">//对零基础即为友好</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> {</span><br><span class="hljs-keyword">int</span> v, p, s[<span class="hljs-number">2</span>], siz;<br><span class="hljs-keyword">bool</span> flag;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> _v, <span class="hljs-keyword">int</span> _p)</span> </span>{<br>v = _v, p = _p;<br>siz = <span class="hljs-number">0</span>;<br>}<br>};<br><br>Node tr[N];<br><span class="hljs-keyword">int</span> n, cas, Root, idx;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 一些宏定义, 用法简单明了, 跟一大堆杂乱无章的中括号说再见!!!</span><br><span class="hljs-comment"> * ex. node(x).init(v, p)//初始化结点x的属性v, p</span><br><span class="hljs-comment"> * siz(left(x))//获取结点x的左子节点size</span><br><span class="hljs-comment"> *siz(node(x).ls)//另一种写法</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls s[0]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs s[1]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> isRoot(x) (x == 0)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> BST_getPos(fa, val) tr[fa].s[(val) &gt; tr[(fa)].v]<span class="hljs-comment">//在fa结点下面根据BST性质插入一个值为val的结点, 判定结点位置(即: 要插在哪里)</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> node(x) tr[(x)]<span class="hljs-comment">//可以理解为x号结点的对象, 方便使用ls, rs</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> left(x) tr[(x)].s[0]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> right(x) tr[(x)].s[1]</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> val(x) tr[(x)].v</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> siz(x) tr[(x)].siz</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> flag(x) tr[(x)].flag</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> pa(x) tr[(x)].p</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> son(fa, x) tr[(fa)].s[(x)]<span class="hljs-comment">//获取结点fa的儿子, 参数x为左右, 左0右1</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LoR(fa, x) (tr[(fa)].s[1] == (x))<span class="hljs-comment">//L or R, x是fa的哪个儿子</span></span><br><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{<br><span class="hljs-built_in">siz</span>(x) = <span class="hljs-built_in">siz</span>(<span class="hljs-built_in">left</span>(x)) + <span class="hljs-built_in">siz</span>(<span class="hljs-built_in">right</span>(x)) + <span class="hljs-number">1</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Pushdown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">flag</span>(x)) {<br><span class="hljs-built_in">swap</span>(<span class="hljs-built_in">left</span>(x), <span class="hljs-built_in">right</span>(x));<br><span class="hljs-built_in">flag</span>(<span class="hljs-built_in">left</span>(x)) ^= <span class="hljs-number">1</span>;<br><span class="hljs-built_in">flag</span>(<span class="hljs-built_in">right</span>(x)) ^= <span class="hljs-number">1</span>;<br><span class="hljs-built_in">flag</span>(x) = <span class="hljs-number">0</span>;<br>}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{<br><span class="hljs-keyword">int</span> y = <span class="hljs-built_in">pa</span>(x), z = <span class="hljs-built_in">pa</span>(y);<br><span class="hljs-keyword">int</span> k = <span class="hljs-built_in">LoR</span>(y, x);<br><span class="hljs-built_in">son</span>(z, <span class="hljs-built_in">LoR</span>(z, y)) = x, <span class="hljs-built_in">pa</span>(x) = z;<br><span class="hljs-built_in">son</span>(y, k) = <span class="hljs-built_in">son</span>(x, k ^ <span class="hljs-number">1</span>), <span class="hljs-built_in">pa</span>(<span class="hljs-built_in">son</span>(x, k ^ <span class="hljs-number">1</span>)) = y;<br><span class="hljs-built_in">son</span>(x, k ^ <span class="hljs-number">1</span>) = y, <span class="hljs-built_in">pa</span>(y) = x;<br><span class="hljs-built_in">Pushup</span>(y), <span class="hljs-built_in">Pushup</span>(x);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Splay</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> goal)</span> </span>{<br><span class="hljs-keyword">while</span>(<span class="hljs-built_in">pa</span>(x) != goal) {<br><span class="hljs-keyword">int</span> y = <span class="hljs-built_in">pa</span>(x), z = <span class="hljs-built_in">pa</span>(y);<br><span class="hljs-keyword">if</span>(z != goal) {<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">LoR</span>(z, y) ^ <span class="hljs-built_in">LoR</span>(y, x)) {<br><span class="hljs-built_in">Rotate</span>(x);<br>} <span class="hljs-keyword">else</span> {<br><span class="hljs-built_in">Rotate</span>(y);<br>}<br>}<br><span class="hljs-built_in">Rotate</span>(x);<br>}<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">isRoot</span>(goal)) Root = x;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>{<br><span class="hljs-keyword">int</span> u = Root, p = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span>(u) {<br>p = u, u = <span class="hljs-built_in">BST_getPos</span>(u, v);<br>}<br>u = ++idx;<br><span class="hljs-keyword">if</span>(!<span class="hljs-built_in">isRoot</span>(p)) {<br><span class="hljs-built_in">BST_getPos</span>(p, v) = u;<br>}<br><span class="hljs-built_in">node</span>(u).<span class="hljs-built_in">init</span>(v, p);<br><span class="hljs-built_in">Splay</span>(u, <span class="hljs-number">0</span>);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getValByRank</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rk)</span> </span>{<br><span class="hljs-keyword">int</span> u = Root;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {<br><span class="hljs-built_in">Pushdown</span>(u);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">siz</span>(<span class="hljs-built_in">left</span>(u)) &gt;= rk) u = <span class="hljs-built_in">left</span>(u);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">siz</span>(<span class="hljs-built_in">left</span>(u)) == rk - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> u;<br><span class="hljs-keyword">else</span> rk -= <span class="hljs-built_in">siz</span>(<span class="hljs-built_in">left</span>(u)) + <span class="hljs-number">1</span>, u = <span class="hljs-built_in">right</span>(u);<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Output</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{<br><span class="hljs-built_in">Pushdown</span>(x);<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">left</span>(x)) <span class="hljs-built_in">Output</span>(<span class="hljs-built_in">left</span>(x));<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">val</span>(x) &gt;= <span class="hljs-number">1</span> &amp;&amp; <span class="hljs-built_in">val</span>(x) &lt;= n) cout &lt;&lt; <span class="hljs-built_in">val</span>(x) &lt;&lt; <span class="hljs-string">' '</span>;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">right</span>(x)) <span class="hljs-built_in">Output</span>(<span class="hljs-built_in">right</span>(x)); <br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>cin &gt;&gt; n &gt;&gt; cas;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= n + <span class="hljs-number">1</span>; ++i) {<br><span class="hljs-built_in">Insert</span>(i);<br>}<br><span class="hljs-keyword">while</span>(cas--) {<br><span class="hljs-keyword">int</span> l, r;<br>cin &gt;&gt; l &gt;&gt; r;<br>l = <span class="hljs-built_in">getValByRank</span>(l), r = <span class="hljs-built_in">getValByRank</span>(r + <span class="hljs-number">2</span>);<br><span class="hljs-built_in">Splay</span>(l, <span class="hljs-number">0</span>), <span class="hljs-built_in">Splay</span>(r, l);<br><span class="hljs-built_in">flag</span>(<span class="hljs-built_in">left</span>(r)) ^= <span class="hljs-number">1</span>;<br>}<br><span class="hljs-built_in">Output</span>(Root);<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">""</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h3 id="普通平衡树luogu-p3369">普通平衡树(<a href="https://www.luogu.com.cn/problem/P3369">Luogu P3369</a>)</h3><blockquote><p>实现增, 删, 查询排名与反查, 查询前驱与后继功能.</p></blockquote><h4 id="solution1-stdvector">Solution1: <code>std::vector</code></h4><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-keyword">int</span>&gt; v;<br><span class="hljs-keyword">int</span> cas;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>cin &gt;&gt; cas;<br><span class="hljs-keyword">while</span>(cas--) {<br><span class="hljs-keyword">int</span> op, x;<br>cin &gt;&gt; op &gt;&gt; x;<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span>(op) {<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-comment">//insert(x)</span><br>v.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), x), x);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<span class="hljs-comment">//delete(x)</span><br>v.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), x));<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<span class="hljs-comment">//getRank(x)</span><br>cout &lt;&lt; <span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), x) - v.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span> &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<span class="hljs-comment">//getValueByRank(x)</span><br>cout &lt;&lt; v[x - <span class="hljs-number">1</span>] &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<span class="hljs-comment">//getPre(x)</span><br>cout &lt;&lt; *--<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), x) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<span class="hljs-comment">//getNxt(x)</span><br>cout &lt;&lt; *<span class="hljs-built_in">lower_bound</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>(), x + <span class="hljs-number">1</span>) &lt;&lt; endl;<br><span class="hljs-keyword">break</span>;<br>}<br>}<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>平衡树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分</title>
    <link href="/2022/02/20/%E4%BA%8C%E5%88%86/"/>
    <url>/2022/02/20/%E4%BA%8C%E5%88%86/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二分">二分</h1><h2 id="原理及实现">原理及实现</h2><p>能用二分解决的问题本质上是 <strong>求可行域的界</strong> ．在本文中，我们定义：若在一个单调区间 <span class="math inline">\([st, ed]\)</span> 内，问题的最优答案为 <span class="math inline">\(ans\)</span> ，有 <span class="math inline">\(\forall x \in [st, ans]\)</span> 满足问题的要求，则称 <span class="math inline">\([st, ans]\)</span> 为该问题的 <strong>可行域</strong>．即，在 <span class="math inline">\((ans, ed]\)</span> 的答案都不能满足该问题的条件．因为区间的单调性，可行域的一个界往往是最优答案. （这玩意是自己定义方便理解的）</p><p>二分算法的本质实际上使用两个指针 <span class="math inline">\(l、r\)</span> 确定查找的区间，通过 <span class="math inline">\(mid\)</span> 来判断区间是否在可行域内以及是否需要进一步缩小，迭代地逐步缩小这个区间．循环结束，某一个指针停留在可行域的某一端点上，表示了最终答案．</p><h3 id="二分的一般思路">二分的一般思路</h3><h4 id="可行域的确定">1. 可行域的确定</h4><p><strong>明确单调性．</strong>即明确该问题是否能用二分解决，这类问题一般需要：</p><ol type="1"><li>容易判断答案是否可行；</li><li>区间离散（即只含有有限个元素）；</li><li>区间单调（区间的一侧是可行域，另一侧不满足要求）．</li></ol><p><strong>判定可行性．</strong>对于一个候选答案，如何判定是否可行？</p><p><strong>获得上下界．</strong>可行域的一个界往往是最优答案，我们需要大致描绘这个界的情况（如：答案位于可行域上界还是下界？）．</p><p><strong>划分区间．</strong>设计算法，让二分结束后（区间不再进一步缩小时），一个指针停在这个界上．</p><hr><h3 id="例一二分查找">例一：二分查找</h3><p>给定一个 <strong>单调递增的</strong> 序列 <code>a[1...n]</code> ，返回指定元素 <span class="math inline">\(key\)</span> 在序列中的位置. 如不存在值为 <span class="math inline">\(key\)</span> 的元素，则返回 <span class="math inline">\(key\)</span> 的后继（第一个大于 <span class="math inline">\(key\)</span> 的元素）的位置．</p><h4 id="问题分析">问题分析</h4><p><strong>【单调性】</strong> 该序列本身单调递增，同时可以得到可行域的界：设 <span class="math inline">\(i\)</span> 为答案（即 <span class="math inline">\(a_i\)</span> 为 <span class="math inline">\(key\)</span> 或 <span class="math inline">\(key\)</span> 的后继），有 <span class="math inline">\(a_{i - 1} \lt a_i\)</span> ，则 <span class="math inline">\(i - 1\)</span> 不为答案．</p><p><strong>【可行域】</strong> 集合 <span class="math inline">\(\{i | a_i \ge key \and 1 \le i \le n\}\)</span>．（可能需要取到后继，所以是往大取）</p><p><strong>【流程】</strong>维护两个指针 <span class="math inline">\(l、r\)</span> ．我们知道答案为可行域的下界，就让搜索结束后 <span class="math inline">\(l\)</span> 为答案．</p><ol type="1"><li>计算 <span class="math inline">\(mid\)</span> ；</li><li>将整个查找区间划分为 <span class="math inline">\([l, mid]\)</span> 和 <span class="math inline">\([mid + 1, r]\)</span>；</li><li>当 <span class="math inline">\(a_{mid} \ge key\)</span> 时，<span class="math inline">\(mid\)</span> 在可行域内，移动 <span class="math inline">\(r\)</span> 到 <span class="math inline">\(mid\)</span> ，缩小搜索区间；否则，<span class="math inline">\(a_{mid} \le key\)</span> ，移动 <span class="math inline">\(l\)</span> 到 <span class="math inline">\(mid + 1\)</span>，使搜索区间逼近可行域；</li><li>当 <span class="math inline">\(l = r\)</span> 时，搜索结束，<span class="math inline">\(l\)</span> 即为答案．</li></ol><h4 id="代码实现">代码实现</h4><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a[], <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>{<br>    <span class="hljs-keyword">while</span>(l &lt; r) {<br>        <span class="hljs-keyword">int</span> mid = l + (r - l &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(a[mid] &gt;= key) r = mid; <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-keyword">return</span> l;<br>}<br></code></pre></div></td></tr></tbody></table></figure><h4 id="注">注</h4><p>二分的一般流程如下：</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{<br>    <span class="hljs-comment">// 该函数作用为返回 mid 是否处于可行域内</span><br>    <span class="hljs-keyword">return</span> 当 x 作为问题答案时是否可行;<br>}<br><span class="hljs-keyword">int</span> l = 左端点, r = 右端点;<br><span class="hljs-keyword">while</span>(搜索未结束) {<br>    <span class="hljs-keyword">int</span> mid = (l + r) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 注意是否需要 +1 或 -1，否则会造成死循环</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">check</span>(mid)) {<br>        （用l、r其中一个端点）进一步缩小区间;<br>    } <span class="hljs-keyword">else</span> {<br>        （用另一个端点）将区间缩小到可行域内;<br>    }<br>}<br>输出(答案所在的端点);<br></code></pre></div></td></tr></tbody></table></figure><h2 id="应用">应用</h2><h3 id="二分答案">二分答案</h3><p>我们经常需要在一个 <strong>离散的单调区间</strong> （该区间内有有限个元素且满足单调性）内枚举问题的答案，例如猜 <span class="math inline">\([1, 1e9]\)</span> 中的某个整数，每次猜测可以得知猜的数字大了还是小了．这是可以从 <span class="math inline">\(1\)</span> 尝试到 <span class="math inline">\(1e9\)</span>．有的时候不能猜这么多次，该怎么办呢？</p><p>可以使用二分答案, 使用二分优化枚举的过程.</p><h3 id="p1873-砍树">P1873 砍树</h3><p>如果枚举<span class="math inline">\([1, 1\times 10^9]\)</span>会超时, 使用二分答案.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> LL = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> n;<br>LL a[N], m;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(LL height)</span> </span>{<br>    LL got = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        got += <span class="hljs-built_in">max</span>(a[i] - height, <span class="hljs-number">0ll</span>);<br>    }<br>    <span class="hljs-keyword">return</span> got &gt;= m;<br>}<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) {<br>        cin &gt;&gt; a[i];<br>    }<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">1</span>, r = <span class="hljs-number">1e9</span> + <span class="hljs-number">1</span>;<span class="hljs-comment">//闭合的区间, 1e9需要加一</span><br>    <span class="hljs-keyword">while</span>(l + <span class="hljs-number">1</span> &lt; r) {<span class="hljs-comment">//l, r不能相邻</span><br>        <span class="hljs-keyword">int</span> mid = l + (r - l &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isValid</span>(mid)) {<br>            l = mid;<br>        } <span class="hljs-keyword">else</span> {<br>            r = mid;<br>        }<br>    }<br>    cout &lt;&lt; l &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>OI笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FREE-Figurines</title>
    <link href="/2021/12/04/FREE-Figurines/"/>
    <url>/2021/12/04/FREE-Figurines/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">两种操作: 接在后面 / 删除最前面.</span><br><span class="hljs-comment">最差情况: "重组", 即全部删了再拼起来. 需要2n次操作.</span><br><span class="hljs-comment">优化: 尾巴上的节点不需要操作. 可以统计有多少个这种节点, 减去节点数 * 2即可.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">int</span> src[N], dest[N], len[N], n, ans;<br><span class="hljs-keyword">bool</span> vis[N];<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span> </span>{<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"ans = %d\n"</span>, ans);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    cin &gt;&gt; n;<br>    <span class="hljs-comment">/*预处理, 统计最坏情况ans*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        cin &gt;&gt; src[i];<br>        vis[src[i]] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(src[i]) ans++;<br>    }<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        cin &gt;&gt; dest[i];<br>        vis[dest[i]] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(dest[i]) ans++;<br>    }<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) {<br>        <span class="hljs-keyword">if</span>(!vis[i]) {<br>            <span class="hljs-keyword">int</span> tmpi = i;<br>            <span class="hljs-keyword">while</span>(src[tmpi] * dest[tmpi] &amp;&amp; src[tmpi] == dest[tmpi]) {   <span class="hljs-comment">//不为自由的 &amp;&amp; 相等就是不用断开的链</span><br>                ans -= <span class="hljs-number">2</span>;<br>                tmpi = src[tmpi];<br>            }<br>        }<br>    }<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></div></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>POI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>POI2010 - TESIntelligence Test</title>
    <link href="/2021/11/21/POI2010-TESIntelligence-Test/"/>
    <url>/2021/11/21/POI2010-TESIntelligence-Test/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight c++"><table><tbody><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N = <span class="hljs-number">1e6</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> YES puts(<span class="hljs-meta-string">"TAK"</span>)</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NO puts(<span class="hljs-meta-string">"NIE"</span>);</span><br><br><span class="hljs-keyword">int</span> len, tc;<br>vector&lt;<span class="hljs-keyword">int</span>&gt; nxt[N];<br><br><span class="hljs-comment">//思路 开二维vector存一堆指针 nxt[x][y]就是数字x出现的第y次的位置.</span><br><span class="hljs-comment">//vector动态开内存 不会爆空间.</span><br><span class="hljs-comment">//二分去找"数字k出现第x次的位置", 实现"快速跳转".</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bsearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num, <span class="hljs-keyword">int</span> expected_pos)</span> </span>{<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>, r = nxt[num].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, res = len + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt;= r) {<br>        <span class="hljs-keyword">int</span> mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nxt[num][mid] &gt; expected_pos) {<br>            r = mid - <span class="hljs-number">1</span>;<br>            res = mid;<br>        } <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    }<br>    <span class="hljs-comment">//return nxt[num][res];</span><br>    <span class="hljs-keyword">return</span> (res == len + <span class="hljs-number">1</span> ? res : nxt[num][res]);<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>{<br>    ios_base::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>); cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    cin &gt;&gt; len;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= len; i++) {<br>        <span class="hljs-keyword">int</span> tmp;<br>        cin &gt;&gt; tmp;<br>        nxt[tmp].<span class="hljs-built_in">push_back</span>(i);<br>    }<br><br>    cin &gt;&gt; tc;<br>    <span class="hljs-keyword">while</span>(tc--) {<br>        <span class="hljs-keyword">int</span> l, a[N];<br>        cin &gt;&gt; l;<br>        <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>; <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= l; i++) cin &gt;&gt; a[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= l; i++) {<br>            pos = <span class="hljs-built_in">bsearch</span>(a[i], pos);<br>            <span class="hljs-comment">//fprintf(stderr, "a[%d] = %d,\tpos = %d\n", i, a[i], pos);</span><br>            <span class="hljs-keyword">if</span>(pos &gt; len) { flag = <span class="hljs-number">0</span>; <span class="hljs-keyword">break</span>; }<br>        }<br>        <br>        flag ? YES : NO;<br>    }<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br><br></code></pre></div></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>题解</category>
      
    </categories>
    
    
    <tags>
      
      <tag>POI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/10/06/hello-world/"/>
    <url>/2021/10/06/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>如题, 这是我的第一篇文章.</p>]]></content>
    
    
    <categories>
      
      <category>随记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
